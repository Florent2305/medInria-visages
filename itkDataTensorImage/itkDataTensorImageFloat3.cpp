// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkDataTensorImageFloat3.h"

#include <dtkCore/dtkAbstractDataFactory.h>

#include <itkTensor.h>
#include <itkImage.h>
#include <itkImageRegionConstIterator.h>
#include <itkImageRegionIteratorWithIndex.h>
#include <itkImageFileWriter.h>
#include <itkVectorImage.h>
#include <itkVector.h>


// /////////////////////////////////////////////////////////////////
// itkDataTensorImagePrivate
// /////////////////////////////////////////////////////////////////

class itkDataTensorImageFloat3Private
{
public:
    typedef itk::Tensor<float, 3>    TensorType;
    typedef itk::Image<TensorType, 3> TensorImageType;
  
    TensorImageType::Pointer tensors;
};

// /////////////////////////////////////////////////////////////////
// itkDataTensorImage
// /////////////////////////////////////////////////////////////////

itkDataTensorImageFloat3::itkDataTensorImageFloat3(void) : dtkAbstractDataImage(), d(new itkDataTensorImageFloat3Private)
{
    d->tensors = 0;
}

itkDataTensorImageFloat3::~itkDataTensorImageFloat3(void)
{
    delete d;
    d = 0;
}

bool itkDataTensorImageFloat3::registered(void)
{
    return dtkAbstractDataFactory::instance()->registerDataType("itkDataTensorImageFloat3", createItkDataTensorImageFloat3);
}

QString itkDataTensorImageFloat3::description(void) const
{
    return "itkDataTensorImageFloat3";
}

void *itkDataTensorImageFloat3::data(void)
{
    return d->tensors.GetPointer();
}

void *itkDataTensorImageFloat3::output(void)
{
    return d->tensors.GetPointer();
}

void itkDataTensorImageFloat3::setData(void *data)
{
    typedef itkDataTensorImageFloat3Private::TensorImageType TensorImageType;

    if( TensorImageType* tensors = dynamic_cast<TensorImageType*>( (itk::Object*)(data) ) ){
        d->tensors = tensors;
    }
    else
      qDebug() << "Cannot cast pointer to correct tensor type";
}

int itkDataTensorImageFloat3::xDimension (void)
{
    if (!d->tensors.IsNull())
      return d->tensors->GetLargestPossibleRegion().GetSize()[0];
    return -1;
}

int itkDataTensorImageFloat3::yDimension (void)
{
    if (!d->tensors.IsNull())
        return d->tensors->GetLargestPossibleRegion().GetSize()[1];
    return -1;
}

int itkDataTensorImageFloat3::zDimension (void)
{
    if (!d->tensors.IsNull())
        return d->tensors->GetLargestPossibleRegion().GetSize()[2];
    return -1;
}

bool itkDataTensorImageFloat3::write (const QString &path)
{
    if(d->tensors.IsNull())
        return false;

    typedef itk::Vector<float, 6>     VectorType;
    typedef itk::Image<VectorType, 3> VectorImageType;
    typedef itkDataTensorImageFloat3Private::TensorType TensorType;
    typedef itkDataTensorImageFloat3Private::TensorImageType TensorImageType;

    VectorImageType::Pointer myTensorImage = VectorImageType::New();
    
    TensorImageType::RegionType region = d->tensors->GetLargestPossibleRegion();
    
    myTensorImage->SetRegions (region);
    myTensorImage->SetSpacing (d->tensors->GetSpacing());
    myTensorImage->SetOrigin (d->tensors->GetOrigin());
    myTensorImage->SetDirection (d->tensors->GetDirection());
    try {
      myTensorImage->Allocate();
    }
    catch (itk::ExceptionObject &e) {
      std::cerr << e;
      throw itk::ExceptionObject (__FILE__,__LINE__,"Error during memory allocation.");
    }

    typedef itk::ImageRegionConstIterator<TensorImageType> IteratorType;
    IteratorType it (d->tensors, d->tensors->GetLargestPossibleRegion());
    
    itk::ImageRegionIteratorWithIndex<VectorImageType> itOut(myTensorImage, myTensorImage->GetLargestPossibleRegion());

    while( !it.IsAtEnd() )
    {
      TensorType tensor = it.Get();
      VectorType vec;
	  
      for( unsigned int i=0; i<6; i++) {
        vec[i] = static_cast<float>(tensor[i]);
      }      
      itOut.Set (vec);
      
      ++it;
      ++itOut;
    }
    
    itk::ImageFileWriter<VectorImageType>::Pointer myWriter = itk::ImageFileWriter<VectorImageType>::New();
    myWriter->SetFileName(path.toAscii().constData());
    myWriter->SetInput(myTensorImage);
    try {
        myWriter->Write();
    }
    catch(itk::ExceptionObject &e) {
      qDebug() << e.GetDescription();
      return false;
    }

    return true;
}

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractData *createItkDataTensorImageFloat3(void)
{
    return new itkDataTensorImageFloat3;
}
