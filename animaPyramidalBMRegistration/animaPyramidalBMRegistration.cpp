// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaPyramidalBMRegistration.h"

#include <dtkCore/dtkAbstractProcessFactory.h>

#include "itkImageRegistrationMethod.h"

#include "itkImage.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"

#include "time.h"

// Include specific RPI implementation of the registration method
#include <rpiAnimaPyramidalBMRegistration.h>
#include <rpiCommonTools.hxx>

#include <animaPyramidalBMRegistrationToolBox.h>
#include <medAbstractDataFactory.h>
#include <medLinearTransformation.h>
#include <medToolBoxHeader.h>


// /////////////////////////////////////////////////////////////////
// animaPyramidalBMRegistrationPrivate
// /////////////////////////////////////////////////////////////////

class animaPyramidalBMRegistrationPrivate
{
public:
    animaPyramidalBMRegistration * proc;
    template <class PixelType>
    int update(void);
    
    template <typename PixelType>
    bool writeTransform(const QString& file);
    
    template <typename PixelType>
    void abort(void);
    
    static void eventCallback ( itk::Object *caller, const itk::EventObject& event, void *clientData );
    
    void * registrationMethod;
    
    QString initTransformFile;

    animaPyramidalBMRegistrationToolBox *toolbox;
    
    animaPyramidalBMRegistration* parent;
    itk::CStyleCommand::Pointer callback;
    
};

// /////////////////////////////////////////////////////////////////
// animaPyramidalBMRegistration
// /////////////////////////////////////////////////////////////////

animaPyramidalBMRegistration::animaPyramidalBMRegistration(void) : itkProcessRegistration(), d(new animaPyramidalBMRegistrationPrivate)
{
    d->proc = this;
    d->registrationMethod = NULL;
    
    d->parent = this;
    this->setProperty("transformType","rigid");

    d->toolbox = new animaPyramidalBMRegistrationToolBox();
    d->toolbox->addWidget(itkProcessRegistration::toolbox());
    itkProcessRegistration::toolbox()->header()->hide();
}

animaPyramidalBMRegistration::~animaPyramidalBMRegistration(void)
{
    d->proc = NULL;

    typedef itk::Image< float, 3 >  RegImageType;
    
    if (d->registrationMethod)
        delete static_cast<rpi::AnimaPyramidalBMRegistration< RegImageType, RegImageType,double > *>(d->registrationMethod);

    d->registrationMethod = NULL;
    
    delete d;
    d = 0;
}

bool animaPyramidalBMRegistration::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaPyramidalBMRegistration",
                                                                 createAnimaPyramidalBMRegistration, "medAbstractEstimateTransformationProcess");
}

QString animaPyramidalBMRegistration::description(void) const
{
    return "Linear BM Registration";
}

QString animaPyramidalBMRegistration::identifier(void) const
{
    return "animaPyramidalBMRegistration";
}

itk::Transform<double,3,3>::Pointer animaPyramidalBMRegistration::getTransform()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return NULL;
}

QString animaPyramidalBMRegistration::getTitleAndParameters()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    typedef rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> RegistrationType;
    RegistrationType * registration = static_cast<RegistrationType *>(d->registrationMethod);
    
    QString titleAndParameters;
    titleAndParameters += "Linear BM Registration\n";
    titleAndParameters += " Number of pyramid levels: " + QString::number(registration->GetNumberOfPyramidLevels()) + "\n";
    titleAndParameters += " Number of iterations per level: " + QString::number(registration->GetMaximumIterations()) + "\n";

    //TO DO : add transform type and optimizer used to parameters given
    return titleAndParameters;
}


medToolBox* animaPyramidalBMRegistration::toolbox()
{
    return d->toolbox;
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

void animaPyramidalBMRegistrationPrivate::eventCallback ( itk::Object* caller, const itk::EventObject& event, void* clientData )
{
    animaPyramidalBMRegistrationPrivate * source = reinterpret_cast<animaPyramidalBMRegistrationPrivate *> ( clientData );
    itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;

    if ( !source )
        qDebug() << "Source is null";

    source->parent->emitProgress((int) (processObject->GetProgress() * 100));
}

 
void animaPyramidalBMRegistration::emitProgress(int prog)
{
    emit progressed(prog);
}

template <typename PixelType>
int animaPyramidalBMRegistrationPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
        
    typename rpi::AnimaPyramidalBMRegistration<FixedImageType,MovingImageType, double> * registration =
    new rpi::AnimaPyramidalBMRegistration<FixedImageType,MovingImageType,double> ();
    
    // set callback
    callback = itk::CStyleCommand::New();
    callback->SetClientData ( ( void * ) this );
    callback->SetCallback ( animaPyramidalBMRegistrationPrivate::eventCallback );
    registration->SetProgressCallback(callback);
    
    registrationMethod = registration;
    
    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImages()[0].GetPointer());
    
    if(!initTransformFile.isEmpty())
       registration->SetInitialTransform( initTransformFile.toStdString() );
    
    registration->SetBlockSize( toolbox->blockSize());
    registration->SetBlockSpacing( toolbox->blockSpacing());
    registration->SetStDevThreshold( toolbox->stDevThreshold());
    registration->SetTransform( toolbox->transform());
    registration->SetMetric( toolbox->metric());
    registration->SetOptimizer( toolbox->optimizer());
    registration->SetMaximumIterations( toolbox->maximumIterations());
    registration->SetMinimalTransformError( toolbox->minimalTransformError());
    registration->SetOptimizerMaximumIterations( toolbox->optimizerMaximumIterations());
    registration->SetSearchRadius( toolbox->searchRadius());
    registration->SetSearchAngleRadius( toolbox->searchAngleRadius());
    registration->SetSearchSkewRadius( toolbox->searchSkewRadius());
    registration->SetSearchScaleRadius( toolbox->searchScaleRadius());
    registration->SetFinalRadius( toolbox->finalRadius());
    registration->SetStepSize( toolbox->stepSize());
    registration->SetTranslateUpperBound( toolbox->translateUpperBound());
    registration->SetAngleUpperBound( toolbox->angleUpperBound());
    registration->SetSkewUpperBound( toolbox->skewUpperBound());
    registration->SetScaleUpperBound( toolbox->scaleUpperBound());
    registration->SetAgregator( toolbox->agregator());
    registration->SetOutputTransformType( toolbox->outputTransformType());
    registration->SetAgregThreshold( toolbox->agregThreshold());
    registration->SetSeStoppingThreshold( toolbox->seStoppingThreshold());
    registration->SetNumberOfPyramidLevels( toolbox->numberOfPyramidLevels());
    registration->SetLastPyramidLevel( toolbox->lastPyramidLevel());
    registration->SetPercentageKept( toolbox->percentageKept());
    registration->SetInitializeOnCenterOfGravity( toolbox->initializeOnCenterOfGravity());
    registration->SetNumberOfThreads( toolbox->numberOfThreads());
    
    
    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }
    
    time_t t2 = clock();
    
    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    

    medLinearTransformation *transfo = new medLinearTransformation;
    itk::AffineTransform<>* affineTransform = dynamic_cast<itk::AffineTransform<> *>(static_cast<itk::Object*>(registration->GetTransformation()));
    if(affineTransform)
    {
        QMatrix4x4 qmatrix;
        for(int i=0; i<3; i++)
            for(int j=0; j<3; j++)
                qmatrix(i,j) =  affineTransform->GetMatrix()[i][j];

        for(int i=0; i<3; i++)
            qmatrix(i,3) = affineTransform->GetOffset()[i];

        qmatrix(3,3) = 1;

      transfo->setMatrix(qmatrix);
    }

    proc->setOutput(transfo, 0);

    return 0;
}

/**
 * @brief Runs the process.
 *
 * @param ImageType the fixed image image type.
 * @return int successful or not.
 */
int animaPyramidalBMRegistration::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages()[0].IsNull())
        return 1;

    return d->update<float>();
}


template <typename PixelType>
bool animaPyramidalBMRegistrationPrivate::writeTransform(const QString& file)
{
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod))
    {
        try
        {
            rpi::writeLinearTransformation<TransformScalarType, 3>(registration->GetTransformation(),
                                                                              file.toStdString());
            
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
    
}

/**
 * @brief
 *
 * @param file The path to the file is assumed to be existing. However the file may not exist beforehand.
 * @return bool successful or not.
 */
bool animaPyramidalBMRegistration::writeTransform(const QString& file)
{
    if(d->registrationMethod == NULL)
        return 1;
    
    return d->writeTransform<float>(file);
}


template <typename PixelType>
void animaPyramidalBMRegistrationPrivate::abort (void)
{  
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaPyramidalBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod)) 
    {
        registration->Abort();   
    }
}

void animaPyramidalBMRegistration::onCanceled (void)
{   
    if(d->registrationMethod != NULL)
        d->abort<float>();
}


void animaPyramidalBMRegistration::initTransformFile(QString initTransformFile)
{
    d->initTransformFile = initTransformFile;
}
   

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createAnimaPyramidalBMRegistration(void)
{
    return new animaPyramidalBMRegistration;
}



