// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaPyramidalBMRegistration.h"

#include <dtkCoreSupport/dtkAbstractProcessFactory.h>

#include "itkImageRegistrationMethod.h"

#include "itkImage.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"


#include "time.h"

// Include specific RPI implementation of the registration method
#include <rpiCommonTools.hxx>

// /////////////////////////////////////////////////////////////////
// animaPyramidalBMRegistrationPrivate
// /////////////////////////////////////////////////////////////////

class animaPyramidalBMRegistrationPrivate
{
public:
    animaPyramidalBMRegistration * proc;
    template <class PixelType>
    int update(void);
    
    template <typename PixelType>
    bool writeTransform(const QString& file);
    
    template <typename PixelType>
    void abort(void);
    
    static void eventCallback ( itk::Object *caller, const itk::EventObject& event, void *clientData );
    
    void * registrationMethod;
    
    QString initTransformFile;
    unsigned int blockSize;
    unsigned int blockSpacing;
    float stDevThreshold;
    unsigned int transform;
    unsigned int metric;  
    unsigned int optimizer;
    unsigned int maximumIterations;
    float minimalTransformError;
    unsigned int optimizerMaximumIterations;
    double searchRadius;
    double searchAngleRadius;
    double searchScaleRadius;
    double finalRadius;
    double stepSize;
    double translateUpperBound;
    double angleUpperBound;
    double scaleUpperBound;
    unsigned int agregator;
    unsigned int outputTransformType;
    float agregThreshold;
    float seStoppingThreshold;
    unsigned int numberOfPyramidLevels;
    unsigned int lastPyramidLevel;
    double percentageKept;
    animaPyramidalBMRegistration::InitializationType transformInitializationType;
    unsigned int numberOfThreads;
    
    animaPyramidalBMRegistration* parent;
    itk::CStyleCommand::Pointer callback;
    
};

// /////////////////////////////////////////////////////////////////
// animaPyramidalBMRegistration
// /////////////////////////////////////////////////////////////////

animaPyramidalBMRegistration::animaPyramidalBMRegistration(void) : itkProcessRegistration(), d(new animaPyramidalBMRegistrationPrivate)
{
    d->proc = this;
    d->registrationMethod = NULL;
    
    d->blockSize = 5;
    d->blockSpacing = 5;
    d->stDevThreshold = 5;
    d->transform = RegistrationType::PyramidBMType::Translation;
    d->metric = RegistrationType::PyramidBMType::SquaredCorrelation;
    d->optimizer = RegistrationType::PyramidBMType::Bobyqa;
    d->maximumIterations = 10;
    d->minimalTransformError = 0.01;
    d->optimizerMaximumIterations = 100;
    d->searchRadius = 2;
    d->searchAngleRadius = 5;
    d->searchScaleRadius = 0.1;
    d->finalRadius = 0.001;
    d->stepSize = 1;
    d->translateUpperBound = 50;
    d->angleUpperBound = 180;
    d->scaleUpperBound = 3;
    d->agregator = RegistrationType::PyramidBMType::MEstimation;
    d->outputTransformType = RegistrationType::PyramidBMType::outRigid;
    d->agregThreshold = 0.5;
    d->seStoppingThreshold = 0.01;
    d->numberOfPyramidLevels = 3;
    d->lastPyramidLevel = 0;
    d->percentageKept = 0.8;
    d->transformInitializationType = RegistrationType::PyramidBMType::Identity;
    d->numberOfThreads = 2;
    
    d->parent = this;
    this->setProperty("transformType","rigid");
}

animaPyramidalBMRegistration::~animaPyramidalBMRegistration(void)
{
    d->proc = NULL;

    typedef itk::Image< float, 3 >  RegImageType;
    
    if (d->registrationMethod)
        delete static_cast<rpi::AnimaPyramidalBMRegistration< RegImageType, RegImageType,double > *>(d->registrationMethod);

    d->registrationMethod = NULL;
    
    delete d;
    d = 0;
}

bool animaPyramidalBMRegistration::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaPyramidalBMRegistration",
                                                                 createAnimaPyramidalBMRegistration);
}

QString animaPyramidalBMRegistration::description(void) const
{
    return "Linear BM Registration";
}

QString animaPyramidalBMRegistration::identifier(void) const
{
    return "animaPyramidalBMRegistration";
}

itk::Transform<double,3,3>::Pointer animaPyramidalBMRegistration::getTransform()
{
    if (RegistrationType * registration =
        static_cast<RegistrationType *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return nullptr;
}

QString animaPyramidalBMRegistration::getTitleAndParameters()
{
    RegistrationType * registration = static_cast<RegistrationType *>(d->registrationMethod);
    
    QString titleAndParameters;
    titleAndParameters += "Linear BM Registration\n";
    titleAndParameters += " Number of pyramid levels: " + QString::number(registration->GetNumberOfPyramidLevels()) + "\n";
    titleAndParameters += " Number of iterations per level: " + QString::number(registration->GetMaximumIterations()) + "\n";

    //TO DO : add transform type and optimizer used to parameters given
    return titleAndParameters;
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

void animaPyramidalBMRegistrationPrivate::eventCallback ( itk::Object* caller, const itk::EventObject& event, void* clientData )
{
    animaPyramidalBMRegistrationPrivate * source = reinterpret_cast<animaPyramidalBMRegistrationPrivate *> ( clientData );
    itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;

    if ( !source )
        qDebug() << "Source is null";

    source->parent->emitProgress((int) (processObject->GetProgress() * 100));
}

 
void animaPyramidalBMRegistration::emitProgress(int prog)
{
    emit progressed(prog);
}

template <typename PixelType>
int animaPyramidalBMRegistrationPrivate::update(void)
{
    typename animaPyramidalBMRegistration::RegistrationType * registration = new animaPyramidalBMRegistration::RegistrationType ();
    
    // set callback
    callback = itk::CStyleCommand::New();
    callback->SetClientData ( ( void * ) this );
    callback->SetCallback ( animaPyramidalBMRegistrationPrivate::eventCallback );
    registration->SetProgressCallback(callback);
    
    registrationMethod = registration;
    
    registration->SetFixedImage((const animaPyramidalBMRegistration::RegImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const animaPyramidalBMRegistration::RegImageType*) proc->movingImages()[0].GetPointer());
    
    if(!initTransformFile.isEmpty())
       registration->SetInitialTransform( initTransformFile.toStdString() );
    
    registration->SetBlockSize( blockSize);
    registration->SetBlockSpacing( blockSpacing);
    registration->SetStDevThreshold( stDevThreshold);
    registration->SetTransform( transform);
    registration->SetMetric( metric);
    registration->SetOptimizer( optimizer);
    registration->SetMaximumIterations( maximumIterations);
    registration->SetMinimalTransformError( minimalTransformError);   
    registration->SetOptimizerMaximumIterations( optimizerMaximumIterations);
    registration->SetSearchRadius( searchRadius);
    registration->SetSearchAngleRadius( searchAngleRadius);
    registration->SetSearchScaleRadius( searchScaleRadius);
    registration->SetFinalRadius( finalRadius);
    registration->SetStepSize( stepSize);
    registration->SetTranslateUpperBound( translateUpperBound);
    registration->SetAngleUpperBound( angleUpperBound);
    registration->SetScaleUpperBound( scaleUpperBound);
    registration->SetAgregator( agregator);
    registration->SetOutputTransformType( outputTransformType);    
    registration->SetAgregThreshold( agregThreshold);    
    registration->SetSeStoppingThreshold( seStoppingThreshold);
    registration->SetNumberOfPyramidLevels( numberOfPyramidLevels);
    registration->SetLastPyramidLevel( lastPyramidLevel);
    registration->SetPercentageKept( percentageKept);
    registration->SetTransformInitializationType(transformInitializationType);
    registration->SetNumberOfThreads( numberOfThreads);
    
    
    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }
    
    time_t t2 = clock();
    
    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    
    typedef itk::ResampleImageFilter< animaPyramidalBMRegistration::RegImageType,animaPyramidalBMRegistration::RegImageType,double > ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const animaPyramidalBMRegistration::RegImageType*)proc->movingImages()[0].GetPointer());
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );
    
    
    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << e.GetDescription();
        return 1;
    }
    
    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    result->DisconnectPipeline();
    
    if (proc->output())
        proc->output()->setData (result);
    return 0;
}

int animaPyramidalBMRegistration::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages()[0].IsNull())
        return 1;

    return d->update<float>();
}


template <typename PixelType>
bool animaPyramidalBMRegistrationPrivate::writeTransform(const QString& file)
{
    if (animaPyramidalBMRegistration::RegistrationType * registration =
        static_cast<animaPyramidalBMRegistration::RegistrationType *>(registrationMethod))
    {
        try
        {
            rpi::writeLinearTransformation<animaPyramidalBMRegistration::TransformScalarType, 3>(registration->GetTransformation(),
                                                                                                 file.toStdString());
            
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
    
}

bool animaPyramidalBMRegistration::writeTransform(const QString& file)
{
    if(d->registrationMethod == NULL)
        return 1;
    
    return d->writeTransform<float>(file);
}


template <typename PixelType>
void animaPyramidalBMRegistrationPrivate::abort (void)
{  
    if (animaPyramidalBMRegistration::RegistrationType * registration =
        static_cast<animaPyramidalBMRegistration::RegistrationType *>(registrationMethod))
    {
        registration->Abort();   
    }
}

void animaPyramidalBMRegistration::onCanceled (void)
{   
    if(d->registrationMethod != NULL)
        d->abort<float>();
}


void animaPyramidalBMRegistration::initTransformFile(QString initTransformFile)
{
    d->initTransformFile = initTransformFile;
}
   
void animaPyramidalBMRegistration::setBlockSize(int blockSize)
{
    d->blockSize=blockSize;
}

void animaPyramidalBMRegistration::setBlockSpacing(unsigned int blockSpacing) 
{
    d->blockSpacing=blockSpacing;
}

void animaPyramidalBMRegistration::setStDevThreshold(float StDevThreshold) 
{
    d->stDevThreshold=StDevThreshold;
}

void animaPyramidalBMRegistration::setTransform(unsigned int transform) 
{
    d->transform=transform;
}

void animaPyramidalBMRegistration::setMetric(unsigned int metric) 
{
    d->metric=metric;
}

void animaPyramidalBMRegistration::setOptimizer(unsigned int optimizer)
{
    d->optimizer=optimizer;
}

void animaPyramidalBMRegistration::setMaximumIterations(unsigned int MaximumIterations) 
{
    d->maximumIterations=MaximumIterations;
}

void animaPyramidalBMRegistration::setMinimalTransformError(float MinimalTransformError) 
{
    d->minimalTransformError=MinimalTransformError;
}

void animaPyramidalBMRegistration::setOptimizerMaximumIterations(unsigned int OptimizerMaximumIterations) 
{
    d->optimizerMaximumIterations=OptimizerMaximumIterations;
}

void animaPyramidalBMRegistration::setSearchRadius(double SearchRadius) 
{
    d->searchRadius=SearchRadius;
}

void animaPyramidalBMRegistration::setSearchAngleRadius(double SearchAngleRadius) 
{
    d->searchAngleRadius=SearchAngleRadius;
}

void animaPyramidalBMRegistration::setSearchScaleRadius(double SearchScaleRadius) 
{
    d->searchScaleRadius=SearchScaleRadius;
}

void animaPyramidalBMRegistration::setFinalRadius(double FinalRadius) 
{
    d->finalRadius=FinalRadius;
}

void animaPyramidalBMRegistration::setStepSize(double StepSize) 
{
    d->stepSize=StepSize;
}

void animaPyramidalBMRegistration::setTranslateUpperBound(double TranslateUpperBound)
{
    d->translateUpperBound=TranslateUpperBound;
}

void animaPyramidalBMRegistration::setAngleUpperBound(double AngleUpperBound) 
{
    d->angleUpperBound=AngleUpperBound;
}

void animaPyramidalBMRegistration::setScaleUpperBound(double ScaleUpperBound) 
{
    d->scaleUpperBound=ScaleUpperBound;
}

void animaPyramidalBMRegistration::setAgregator(unsigned int agregator)
{
    d->agregator=agregator;
}

void animaPyramidalBMRegistration::setOutputTransformType(unsigned int outputTransform)
{
   d-> outputTransformType=outputTransform;
}

void animaPyramidalBMRegistration::setAgregThreshold(float AgregThreshold)
{
    d->agregThreshold=AgregThreshold;
}

void animaPyramidalBMRegistration::setSeStoppingThreshold(float SeStoppingThreshold)
{
    d->seStoppingThreshold=SeStoppingThreshold;
}

void animaPyramidalBMRegistration::setNumberOfPyramidLevels(unsigned int NumberOfPyramidLevels)
{
    d->numberOfPyramidLevels=NumberOfPyramidLevels;
}

void animaPyramidalBMRegistration::setLastPyramidLevel(unsigned int LastPyramidLevel) 
{
    d->lastPyramidLevel=LastPyramidLevel;
}

void animaPyramidalBMRegistration::setPercentageKept(double PercentageKept)
{
    d->percentageKept=PercentageKept;
}

void animaPyramidalBMRegistration::setTransformInitializationType(unsigned int initializationType)
{
    d->transformInitializationType = (InitializationType) initializationType;
}

void animaPyramidalBMRegistration::setNumberOfThreads(int numberOfThreads) 
{
    d->numberOfThreads=numberOfThreads;
}


// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createAnimaPyramidalBMRegistration(void)
{
    return new animaPyramidalBMRegistration;
}



