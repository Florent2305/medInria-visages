// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaDenseBMRegistration.h"

#include <dtkCore/dtkAbstractProcessFactory.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include <itkImageRegistrationMethod.h>

#include <itkImage.h>
#include <itkResampleImageFilter.h>
#include <itkCastImageFilter.h>
#include <itkStationaryVelocityFieldTransform.h>


#include "time.h"

// Include specific RPI implementation of the registration method
#include <rpiAnimaDenseBMRegistration.h>
#include <rpiCommonTools.hxx>

#include <animaDenseBMRegistrationToolBox.h>
#include <medAbstractDataFactory.h>
#include <medSVFTransformation.h>
#include <medToolBoxHeader.h>


// /////////////////////////////////////////////////////////////////
// animaDenseBMRegistrationPrivate
// /////////////////////////////////////////////////////////////////

class animaDenseBMRegistrationPrivate
{
public:
    animaDenseBMRegistration * proc;
    template <class PixelType>
    int update(void);
    
    template <typename PixelType>
    bool writeTransform(const QString& file);
    
    template <typename PixelType>
    void abort(void);
    
    static void eventCallback ( itk::Object *caller, const itk::EventObject& event, void *clientData );
    
    void * registrationMethod;

    animaDenseBMRegistrationToolBox *toolbox;
    
    animaDenseBMRegistration* parent;
    itk::CStyleCommand::Pointer callback;
    
};

// /////////////////////////////////////////////////////////////////
// animaDenseBMRegistration
// /////////////////////////////////////////////////////////////////

animaDenseBMRegistration::animaDenseBMRegistration(void) : itkProcessRegistration(), d(new animaDenseBMRegistrationPrivate)
{
    d->proc = this;
    d->registrationMethod = NULL;
    
    d->parent = this;
    this->setProperty("transformType","nonRigid");

    d->toolbox = new animaDenseBMRegistrationToolBox();
    d->toolbox->addWidget(itkProcessRegistration::toolbox());
    itkProcessRegistration::toolbox()->header()->hide();
}

animaDenseBMRegistration::~animaDenseBMRegistration(void)
{
    d->proc = NULL;

    typedef itk::Image< float, 3 >  RegImageType;
    
    if (d->registrationMethod)
        delete static_cast<rpi::AnimaDenseBMRegistration< RegImageType, RegImageType,double > *>(d->registrationMethod);

    d->registrationMethod = NULL;
    
    delete d;
    d = 0;
}

bool animaDenseBMRegistration::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaDenseBMRegistration",
                                                                      createAnimaDenseBMRegistration, "medAbstractEstimateTransformationProcess");
}

QString animaDenseBMRegistration::description(void) const
{
    return "Dense Anatomical BM Registration";
}

QString animaDenseBMRegistration::identifier(void) const
{
    return "animaDenseBMRegistration";
}

itk::Transform<double,3,3>::Pointer animaDenseBMRegistration::getTransform()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return NULL;
}

QString animaDenseBMRegistration::getTitleAndParameters()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    typedef rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> RegistrationType;
    RegistrationType * registration = static_cast<RegistrationType *>(d->registrationMethod);
    
    QString titleAndParameters;
    titleAndParameters += "Dense Anatomical BM Registration\n";
    titleAndParameters += " Number of pyramid levels: " + QString::number(registration->GetNumberOfPyramidLevels()) + "\n";
    titleAndParameters += " Number of iterations per level: " + QString::number(registration->GetMaximumIterations()) + "\n";

    //TO DO : add sigmas and optimizer used to parameters given
    return titleAndParameters;
}

medToolBox* animaDenseBMRegistration::toolbox()
{
    return d->toolbox;
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

void animaDenseBMRegistrationPrivate::eventCallback ( itk::Object* caller, const itk::EventObject& event, void* clientData )
{
    animaDenseBMRegistrationPrivate * source = reinterpret_cast<animaDenseBMRegistrationPrivate *> ( clientData );
    itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;

    if ( !source )
        qDebug() << "Source is null";

    source->parent->emitProgress((int) (processObject->GetProgress() * 100));
}

 
void animaDenseBMRegistration::emitProgress(int prog)
{
    emit progressed(prog);
}

template <typename PixelType>
int animaDenseBMRegistrationPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
        
    typename rpi::AnimaDenseBMRegistration<FixedImageType,MovingImageType, double> * registration =
    new rpi::AnimaDenseBMRegistration<FixedImageType,MovingImageType,double> ();
    
    // set callback
    callback = itk::CStyleCommand::New();
    callback->SetClientData ( ( void * ) this );
    callback->SetCallback ( animaDenseBMRegistrationPrivate::eventCallback );
    registration->SetProgressCallback(callback);
    
    registrationMethod = registration;
    
    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImages()[0].GetPointer());
    
    registration->SetBlockSize (toolbox->blockSize());
    registration->SetBlockSpacing (toolbox->blockSpacing());
    registration->SetStDevThreshold (toolbox->stDevThreshold());
    registration->SetTransform (toolbox->transform());
    registration->SetMetric (toolbox->metric());
    registration->SetOptimizer (toolbox->optimizer());
    registration->SetMaximumIterations (toolbox->maximumIterations());
    registration->SetMinimalTransformError (toolbox->minimalTransformError());
    registration->SetOptimizerMaximumIterations (toolbox->optimizerMaximumIterations());
    registration->SetSearchRadius (toolbox->searchRadius());
    registration->SetSearchAngleRadius (toolbox->searchAngleRadius());
    registration->SetSearchSkewRadius (toolbox->searchSkewRadius());
    registration->SetSearchScaleRadius (toolbox->searchScaleRadius());
    registration->SetFinalRadius (toolbox->finalRadius());
    registration->SetStepSize (toolbox->stepSize());
    registration->SetTranslateUpperBound (toolbox->translateUpperBound());
    registration->SetAngleUpperBound (toolbox->angleUpperBound());
    registration->SetSkewUpperBound (toolbox->skewUpperBound());
    registration->SetScaleUpperBound (toolbox->scaleUpperBound());
    registration->SetAgregator (toolbox->agregator());
    registration->SetExtrapolationSigma (toolbox->extrapolationSigma());
    registration->SetElasticSigma (toolbox->elasticSigma());
    registration->SetOutlierSigma (toolbox->outlierSigma());
    registration->SetMEstimateConvergenceThreshold (toolbox->mEstimateConvergenceThreshold());
    registration->SetNeighborhoodApproximation (toolbox->neighborhoodApproximation());
    registration->SetUseTransformationDam (toolbox->useTransformationDam());
    registration->SetDamDistance (toolbox->damDistance());
    registration->SetNumberOfPyramidLevels (toolbox->numberOfPyramidLevels());
    registration->SetLastPyramidLevel (toolbox->lastPyramidLevel());
    registration->SetPercentageKept (toolbox->percentageKept());
    registration->SetNumberOfThreads (toolbox->numberOfThreads());
    
    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }
    
    time_t t2 = clock();
    
    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    
    medAbstractData *imageTransfo = medAbstractDataFactory::instance()->create("medItkVectorDouble3ImageData");

    itk::StationaryVelocityFieldTransform<double> *rpiTransfo =
            dynamic_cast< itk::StationaryVelocityFieldTransform<double>* >(static_cast<itk::Object*>(registration->GetTransformation()) );

    if(rpiTransfo)
    {
        typedef itk::StationaryVelocityFieldTransform<double>::VectorFieldType VectorFieldType;
        VectorFieldType::Pointer temp = const_cast<VectorFieldType*>(rpiTransfo->GetParametersAsVectorField());
        imageTransfo->setData(temp);
    }

    medSVFTransformation *transfo = new medSVFTransformation;
    transfo->setParameter(imageTransfo);

    proc->setOutput(transfo, 0);

    return 0;
}

int animaDenseBMRegistration::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages()[0].IsNull())
        return 1;

    return d->update<float>();
}


template <typename PixelType>
bool animaDenseBMRegistrationPrivate::writeTransform(const QString& file)
{
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod))
    {
        try
        {

            //rpi::writeDisplacementFieldTransformation<TransformScalarType, 3>(registration->GetTransformation(), file.toStdString());
            rpi::writeStationaryVelocityFieldTransformation<TransformScalarType, 3>(registration->GetTransformation(), file.toStdString());
            
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
    
}


/**
 * @brief
 *
 * @param file The path to the file is assumed to be existing. However the file may not exist beforehand.
 * @return bool successful or not.
 */
bool animaDenseBMRegistration::writeTransform(const QString& file)
{
    if(d->registrationMethod == NULL)
        return 1;
    
    return d->writeTransform<float>(file);
}


template <typename PixelType>
void animaDenseBMRegistrationPrivate::abort (void)
{  
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod)) 
    {
        registration->Abort();   
    }
}

void animaDenseBMRegistration::onCanceled (void)
{   
    if(d->registrationMethod != NULL)
        d->abort<float>();
}


// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createAnimaDenseBMRegistration(void)
{
    return new animaDenseBMRegistration;
}



