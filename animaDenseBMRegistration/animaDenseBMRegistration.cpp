// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaDenseBMRegistration.h"

#include <dtkCore/dtkAbstractProcessFactory.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include "itkImageRegistrationMethod.h"

#include "itkImage.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"


#include "time.h"

// Include specific RPI implementation of the registration method
#include <rpiAnimaDenseBMRegistration.h>
#include <rpiCommonTools.hxx>



// /////////////////////////////////////////////////////////////////
// animaDenseBMRegistrationPrivate
// /////////////////////////////////////////////////////////////////

class animaDenseBMRegistrationPrivate
{
public:
    animaDenseBMRegistration * proc;
    template <class PixelType>
    int update(void);
    
    template <typename PixelType>
    bool writeTransform(const QString& file);
    
    template <typename PixelType>
    void abort(void);
    
    static void eventCallback ( itk::Object *caller, const itk::EventObject& event, void *clientData );
    
    void * registrationMethod;
    
    unsigned int blockSize;
    unsigned int blockSpacing;
    float stDevThreshold;
    unsigned int transform;
    unsigned int metric;  
    unsigned int optimizer;
    unsigned int maximumIterations;
    float minimalTransformError;
    unsigned int optimizerMaximumIterations;
    double searchRadius;
    double searchAngleRadius;
    double searchSkewRadius;
    double searchScaleRadius;
    double finalRadius;
    double stepSize;
    double translateUpperBound;
    double angleUpperBound;
    double skewUpperBound;
    double scaleUpperBound;
    unsigned int agregator;
    double extrapolationSigma;
    double elasticSigma;
    double outlierSigma;
    double mEstimateConvergenceThreshold;
    double neighborhoodApproximation;
    bool useTransformationDam;
    double damDistance;
    unsigned int numberOfPyramidLevels;
    unsigned int lastPyramidLevel;
    double percentageKept;
    unsigned int numberOfThreads;
    
    animaDenseBMRegistration* parent;
    itk::CStyleCommand::Pointer callback;
    
};

// /////////////////////////////////////////////////////////////////
// animaDenseBMRegistration
// /////////////////////////////////////////////////////////////////

animaDenseBMRegistration::animaDenseBMRegistration(void) : itkProcessRegistration(), d(new animaDenseBMRegistrationPrivate)
{
    d->proc = this;
    d->registrationMethod = NULL;
    
    d->blockSize = 5;
    d->blockSpacing = 2;
    d->stDevThreshold = 5;
    d->transform = Translation;
    d->metric = SquaredCorrelation;  
    d->optimizer = Bobyqa;
    d->maximumIterations = 10;
    d->minimalTransformError = 0.01;
    d->optimizerMaximumIterations = 100;
    d->searchRadius = 2;
    d->searchAngleRadius = 5;
    d->searchSkewRadius = 5;
    d->searchScaleRadius = 0.1;
    d->finalRadius = 0.001;
    d->stepSize = 1;
    d->translateUpperBound = 50;
    d->angleUpperBound = 180;
    d->skewUpperBound = 45;
    d->scaleUpperBound = 3;
    d->agregator = Baloo;
    d->extrapolationSigma = 2;
    d->elasticSigma = 2;
    d->outlierSigma = 3;
    d->mEstimateConvergenceThreshold = 0.01;
    d->neighborhoodApproximation = 2.5;
    d->useTransformationDam = true;
    d->damDistance = 2.5;
    d->numberOfPyramidLevels = 3;
    d->lastPyramidLevel = 0;
    d->percentageKept = 0.8;
    d->numberOfThreads = 2;
    
    d->parent = this;
    this->setProperty("transformType","nonRigid");
}

animaDenseBMRegistration::~animaDenseBMRegistration(void)
{
    d->proc = NULL;

    typedef itk::Image< float, 3 >  RegImageType;
    
    if (d->registrationMethod)
        delete static_cast<rpi::AnimaDenseBMRegistration< RegImageType, RegImageType,double > *>(d->registrationMethod);

    d->registrationMethod = NULL;
    
    delete d;
    d = 0;
}

bool animaDenseBMRegistration::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaDenseBMRegistration",
                                                                      createAnimaDenseBMRegistration);
}

QString animaDenseBMRegistration::description(void) const
{
    return "Dense Anatomical BM Registration";
}

QString animaDenseBMRegistration::identifier(void) const
{
    return "animaDenseBMRegistration";
}

itk::Transform<double,3,3>::Pointer animaDenseBMRegistration::getTransform()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return NULL;
}

QString animaDenseBMRegistration::getTitleAndParameters()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    typedef rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> RegistrationType;
    RegistrationType * registration = static_cast<RegistrationType *>(d->registrationMethod);
    
    QString titleAndParameters;
    titleAndParameters += "Dense Anatomical BM Registration\n";
    titleAndParameters += " Number of pyramid levels: " + QString::number(registration->GetNumberOfPyramidLevels()) + "\n";
    titleAndParameters += " Number of iterations per level: " + QString::number(registration->GetMaximumIterations()) + "\n";

    //TO DO : add sigmas and optimizer used to parameters given
    return titleAndParameters;
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

void animaDenseBMRegistrationPrivate::eventCallback ( itk::Object* caller, const itk::EventObject& event, void* clientData )
{
    animaDenseBMRegistrationPrivate * source = reinterpret_cast<animaDenseBMRegistrationPrivate *> ( clientData );
    itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;

    if ( !source )
        qDebug() << "Source is null";

    source->parent->emitProgress((int) (processObject->GetProgress() * 100));
}

 
void animaDenseBMRegistration::emitProgress(int prog)
{
    emit progressed(prog);
}

template <typename PixelType>
int animaDenseBMRegistrationPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
        
    typename rpi::AnimaDenseBMRegistration<FixedImageType,MovingImageType, double> * registration =
    new rpi::AnimaDenseBMRegistration<FixedImageType,MovingImageType,double> ();
    
    // set callback
    callback = itk::CStyleCommand::New();
    callback->SetClientData ( ( void * ) this );
    callback->SetCallback ( animaDenseBMRegistrationPrivate::eventCallback );
    registration->SetProgressCallback(callback);
    
    registrationMethod = registration;
    
    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImages()[0].GetPointer());
    
    registration->SetBlockSize (blockSize);
    registration->SetBlockSpacing (blockSpacing);
    registration->SetStDevThreshold (stDevThreshold);
    registration->SetTransform (transform);
    registration->SetMetric (metric);
    registration->SetOptimizer (optimizer);
    registration->SetMaximumIterations (maximumIterations);
    registration->SetMinimalTransformError (minimalTransformError);
    registration->SetOptimizerMaximumIterations (optimizerMaximumIterations);
    registration->SetSearchRadius (searchRadius);
    registration->SetSearchAngleRadius (searchAngleRadius);
    registration->SetSearchSkewRadius (searchSkewRadius);
    registration->SetSearchScaleRadius (searchScaleRadius);
    registration->SetFinalRadius (finalRadius);
    registration->SetStepSize (stepSize);
    registration->SetTranslateUpperBound (translateUpperBound);
    registration->SetAngleUpperBound (angleUpperBound);
    registration->SetSkewUpperBound (skewUpperBound);
    registration->SetScaleUpperBound (scaleUpperBound);
    registration->SetAgregator (agregator);
    registration->SetExtrapolationSigma (extrapolationSigma);
    registration->SetElasticSigma (elasticSigma);
    registration->SetOutlierSigma (outlierSigma);
    registration->SetMEstimateConvergenceThreshold (mEstimateConvergenceThreshold);
    registration->SetNeighborhoodApproximation (neighborhoodApproximation);
    registration->SetUseTransformationDam (useTransformationDam);
    registration->SetDamDistance (damDistance);
    registration->SetNumberOfPyramidLevels (numberOfPyramidLevels);
    registration->SetLastPyramidLevel (lastPyramidLevel);
    registration->SetPercentageKept (percentageKept);
    registration->SetNumberOfThreads (numberOfThreads);
    
    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }
    
    time_t t2 = clock();
    
    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    
    typedef itk::ResampleImageFilter< MovingImageType,MovingImageType,double >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const MovingImageType*)proc->movingImages()[0].GetPointer());
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );
    
    
    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << e.GetDescription();
        return 1;
    }
    
    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    result->DisconnectPipeline();
    
    if (proc->output())
        proc->output()->setData (result);
    return 0;
}

int animaDenseBMRegistration::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages()[0].IsNull())
        return 1;

    return d->update<float>();
}


template <typename PixelType>
bool animaDenseBMRegistrationPrivate::writeTransform(const QString& file)
{
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod))
    {
        try
        {
            rpi::writeLinearTransformation<TransformScalarType, 3>(registration->GetTransformation(),
                                                                              file.toStdString());
            
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
    
}

bool animaDenseBMRegistration::writeTransform(const QString& file)
{
    if(d->registrationMethod == NULL)
        return 1;
    
    return d->writeTransform<float>(file);
}


template <typename PixelType>
void animaDenseBMRegistrationPrivate::abort (void)
{  
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::AnimaDenseBMRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod)) 
    {
        registration->Abort();   
    }
}

void animaDenseBMRegistration::onCanceled (void)
{   
    if(d->registrationMethod != NULL)
        d->abort<float>();
}

void animaDenseBMRegistration::setBlockSize(int blockSize)
{
    d->blockSize=blockSize;
}

void animaDenseBMRegistration::setBlockSpacing(unsigned int blockSpacing) 
{
    d->blockSpacing=blockSpacing;
}

void animaDenseBMRegistration::setStDevThreshold(float StDevThreshold) 
{
    d->stDevThreshold=StDevThreshold;
}

void animaDenseBMRegistration::setTransform(unsigned int transform) 
{
    d->transform=transform;
}

void animaDenseBMRegistration::setMetric(unsigned int metric) 
{
    d->metric=metric;
}

void animaDenseBMRegistration::setOptimizer(unsigned int optimizer)
{
    d->optimizer=optimizer;
}

void animaDenseBMRegistration::setMaximumIterations(unsigned int MaximumIterations) 
{
    d->maximumIterations=MaximumIterations;
}

void animaDenseBMRegistration::setMinimalTransformError(float MinimalTransformError) 
{
    d->minimalTransformError=MinimalTransformError;
}

void animaDenseBMRegistration::setOptimizerMaximumIterations(unsigned int OptimizerMaximumIterations) 
{
    d->optimizerMaximumIterations=OptimizerMaximumIterations;
}

void animaDenseBMRegistration::setSearchRadius(double SearchRadius) 
{
    d->searchRadius=SearchRadius;
}

void animaDenseBMRegistration::setSearchAngleRadius(double SearchAngleRadius) 
{
    d->searchAngleRadius=SearchAngleRadius;
}

void animaDenseBMRegistration::setSearchSkewRadius(double SearchSkewRadius) 
{
    d->searchSkewRadius=SearchSkewRadius;
}

void animaDenseBMRegistration::setSearchScaleRadius(double SearchScaleRadius) 
{
    d->searchScaleRadius=SearchScaleRadius;
}

void animaDenseBMRegistration::setFinalRadius(double FinalRadius) 
{
    d->finalRadius=FinalRadius;
}

void animaDenseBMRegistration::setStepSize(double StepSize) 
{
    d->stepSize=StepSize;
}

void animaDenseBMRegistration::setTranslateUpperBound(double TranslateUpperBound)
{
    d->translateUpperBound=TranslateUpperBound;
}

void animaDenseBMRegistration::setAngleUpperBound(double AngleUpperBound) 
{
    d->angleUpperBound=AngleUpperBound;
}

void animaDenseBMRegistration::setSkewUpperBound(double SkewUpperBound)
{
    d->skewUpperBound=SkewUpperBound;
}

void animaDenseBMRegistration::setScaleUpperBound(double ScaleUpperBound) 
{
    d->scaleUpperBound=ScaleUpperBound;
}

void animaDenseBMRegistration::setAgregator(unsigned int agregator)
{
    d->agregator=agregator;
}

void animaDenseBMRegistration::setExtrapolationSigma(double extrapolationSigma)
{
    d->extrapolationSigma = extrapolationSigma;
}

void animaDenseBMRegistration::setElasticSigma(double elasticSigma)
{
    d->elasticSigma = elasticSigma;
}

void animaDenseBMRegistration::setOutlierSigma(double outlierSigma)
{
    d->outlierSigma = outlierSigma;
}

void animaDenseBMRegistration::setMEstimateConvergenceThreshold(double mEstimateConvergenceThreshold)
{
    d->mEstimateConvergenceThreshold = mEstimateConvergenceThreshold;
}

void animaDenseBMRegistration::setNeighborhoodApproximation(double neighborhoodApproximation)
{
    d->neighborhoodApproximation = neighborhoodApproximation;
}

void animaDenseBMRegistration::setUseTransformationDam(bool useTransformationDam)
{
    d->useTransformationDam = useTransformationDam;
}

void animaDenseBMRegistration::setDamDistance(double damDistance)
{
    d->damDistance = damDistance;
}

void animaDenseBMRegistration::setNumberOfPyramidLevels(unsigned int NumberOfPyramidLevels)
{
    d->numberOfPyramidLevels=NumberOfPyramidLevels;
}

void animaDenseBMRegistration::setLastPyramidLevel(unsigned int LastPyramidLevel) 
{
    d->lastPyramidLevel=LastPyramidLevel;
}

void animaDenseBMRegistration::setPercentageKept(double PercentageKept)
{
    d->percentageKept=PercentageKept;
}

void animaDenseBMRegistration::setNumberOfThreads(int numberOfThreads) 
{
    d->numberOfThreads=numberOfThreads;
}


// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createAnimaDenseBMRegistration(void)
{
    return new animaDenseBMRegistration;
}



