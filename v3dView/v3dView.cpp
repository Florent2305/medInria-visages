// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include <vtkINRIA3DConfigure.h>

#ifdef vtkINRIA3D_USE_ITK
#include "itkExtractImageFilter.h"
#endif

#include "v3dView.h"

#include <dtkCore/dtkAbstractViewFactory.h>
#include <dtkCore/dtkAbstractDataImage.h>
#include <dtkCore/dtkAbstractProcess.h>
#include <dtkCore/dtkAbstractProcessFactory.h>

#include <vtkCamera.h>
#include <vtkCommand.h>
#include <vtkRenderer.h>
#include <vtkRenderWindow.h>
#include <vtkLookupTableManager.h>
#include <vtkTransferFunctionPresets.h>
#include <vtkImageActor.h>
#include <vtkImageData.h>
#include <vtkPointSet.h>
#include <vtkTextProperty.h>
#include <vtkImageMapToColors.h>
#include <vtkOrientedBoxWidget.h>

#include <vtkImageView2D.h>
#include <vtkImageView3D.h>
#include <vtkImageView2DCommand.h>
#include <vtkInteractorStyleImageView2D.h>
#include <vtkInteractorStyleTrackballCamera2.h>
#include <vtkInteractorStyleTrackballActor.h>
#include <vtkImageViewCollection.h>
#include <vtkColorTransferFunction.h>
#include <vtkPiecewiseFunction.h>
#include <QVTKWidget.h>

#include <QtGui>
#include <QMenu>
#include <QMouseEvent>

// /////////////////////////////////////////////////////////////////////////////////////////////////////////
// v3dViewObserver: links a QSlider with the CurrentPointChangedEvent of a vtkImageView instance.
// /////////////////////////////////////////////////////////////////////////////////////////////////////////

class v3dViewObserver : public vtkCommand
{
public:
    static v3dViewObserver* New(void) { return new v3dViewObserver; }
    
    void Execute(vtkObject *caller, unsigned long event, void *callData);
    
    void setSlider(QSlider *slider) {
        this->slider = slider;
    }
    
    void setView(v3dView *view){
        this->view = view;
    }
    
    inline void   lock(void) { this->m_lock = 1; }
    inline void unlock(void) { this->m_lock = 0; }
    
protected:
    v3dViewObserver(void);
    ~v3dViewObserver(void);
    
private:
    int             m_lock;
    QSlider        *slider;
    v3dView        *view;
};

v3dViewObserver::v3dViewObserver(void)
{
    this->slider = 0;
    this->m_lock = 0;
}

v3dViewObserver::~v3dViewObserver(void)
{
    
}

void v3dViewObserver::Execute(vtkObject *caller, unsigned long event, void *callData)
{
    if (this->m_lock)
        return;
    
	if (!this->slider || !this->view)
        return;
        
    switch(event)
    {
        case vtkImageView::CurrentPointChangedEvent:
           {
              unsigned int zslice = this->view->view2d()->GetSlice();
              this->slider->blockSignals (true);
              this->slider->setValue (zslice);
              this->slider->update();
              this->slider->blockSignals (false);
              
              double *pos = this->view->currentView()->GetCurrentPoint();
              QVector3D qpos (pos[0], pos[1], pos[2]);
              this->view->emitViewPositionChangedEvent(qpos);
           }
           break;
           
        case vtkImageView2DCommand::CameraZoomEvent:
            {
               double zoom = this->view->currentView()->GetZoom();
               this->view->emitViewZoomChangedEvent(zoom);
            }
           break;
           
        case vtkImageView2DCommand::CameraPanEvent:
            {
               double *pan = this->view->view2d()->GetPan();
               QVector2D qpan (pan[0],pan[1]);
               this->view->emitViewPanChangedEvent(qpan);
            }
           break;
           
        case vtkImageView::WindowLevelChangedEvent:
            {
               double level = this->view->currentView()->GetColorLevel();
               double window = this->view->currentView()->GetColorWindow();
          
               this->view->emitViewWindowingChangedEvent(level, window);
            }
           break;
           
        case vtkCommand::InteractionEvent:
            {
               double *pos = this->view->renderer3d()->GetActiveCamera()->GetPosition();
               double *vup = this->view->renderer3d()->GetActiveCamera()->GetViewUp();
               double *foc = this->view->renderer3d()->GetActiveCamera()->GetFocalPoint();
               double   ps = this->view->renderer3d()->GetActiveCamera()->GetParallelScale();
               
               QVector3D position (pos[0], pos[1], pos[2]);
               QVector3D viewup (vup[0], vup[1], vup[2]);
               QVector3D focal (foc[0], foc[1], foc[2]);
               
               this->view->emitViewCameraChangedEvent(position, viewup, focal, ps);
            }
           
           break;           
	}
}

// /////////////////////////////////////////////////////////////////
// v3dViewPrivate
// /////////////////////////////////////////////////////////////////

class v3dViewPrivate
{
public:
    vtkRenderer *renderer2d;
    vtkRenderer *renderer3d;
    vtkImageView2D *view2d;
    vtkImageView3D *view3d;
    
    vtkImageView *currentView;
    
    vtkImageViewCollection *collection;

    v3dViewObserver *observer;
    
    QWidget    *widget;
    QSlider    *slider;
    QComboBox  *dimensionBox;
    QPushButton *anchorButton;
    QPushButton *linkButton;
    QPushButton *linkWLButton;
    QPushButton *registerButton;
    QPushButton *playButton;
    QPushButton *closeButton;
    QPushButton *fullScreenButton;
    QVTKWidget *vtkWidget;
    QMenu      *menu;
    QString orientation;
    
    dtkAbstractData      *data;
    dtkAbstractDataImage *imageData;
    
    QTimeLine *timeline;
};

// /////////////////////////////////////////////////////////////////
// v3dView
// /////////////////////////////////////////////////////////////////

v3dView::v3dView(void) : medAbstractView(), d(new v3dViewPrivate)
{
    d->data       = 0;
	d->imageData  = 0;
    d->orientation = "Axial";
    
    d->timeline = new QTimeLine(1000, this);
	d->timeline->setLoopCount(0);
    connect(d->timeline, SIGNAL(frameChanged(int)), this, SLOT(onZSliderValueChanged(int)));
    
    // Setting up 2D view
    
    d->renderer2d = vtkRenderer::New();
    d->view2d = vtkImageView2D::New();    
    d->view2d->SetRenderer(d->renderer2d);
    d->view2d->SetBackground(0.0, 0.0, 0.0);
    d->view2d->SetLeftButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypeZoom);
    d->view2d->SetMiddleButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypePan);
    d->view2d->SetRightButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypeNull);
    d->view2d->SetSliceOrientation(vtkImageView2D::VIEW_ORIENTATION_AXIAL);
    d->view2d->CursorFollowMouseOff();
    d->view2d->ShowImageAxisOff();
    d->view2d->ShowScalarBarOff();
    d->view2d->ShowRulerWidgetOn();
        
    // Setting up 3D view
    d->renderer3d = vtkRenderer::New();
    d->renderer3d->GetActiveCamera()->SetPosition(0, -1, 0);
    d->renderer3d->GetActiveCamera()->SetViewUp(0, 0, 1);
    d->renderer3d->GetActiveCamera()->SetFocalPoint(0, 0, 0);
    
    d->view3d = vtkImageView3D::New();
    d->view3d->SetRenderer(d->renderer3d);
    d->view3d->SetShowBoxWidget(0);
    d->view3d->SetCroppingModeToOff();
    d->view3d->ShowScalarBarOff();
    d->view3d->GetTextProperty()->SetColor(1.0, 1.0, 1.0);
    d->view3d->ShadeOn();
    
    d->currentView = d->view2d;

    vtkInteractorStyleTrackballCamera2 *interactorStyle = vtkInteractorStyleTrackballCamera2::New();
    d->view3d->SetInteractorStyle(interactorStyle);
    interactorStyle->Delete();
    
    d->widget = new QWidget;
    
    d->slider = new QSlider(Qt::Horizontal, d->widget);
    d->slider->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
    d->slider->setFocusPolicy(Qt::NoFocus);
	
    d->dimensionBox = new QComboBox(d->widget);
    d->dimensionBox->setFocusPolicy(Qt::NoFocus);
    d->dimensionBox->addItem( tr("Space") );
    d->dimensionBox->addItem( tr("Time") );
    d->dimensionBox->setCurrentIndex( 0 );
    d->dimensionBox->setMaximumHeight(16);
    d->dimensionBox->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
    d->dimensionBox->setMaximumWidth(64);
    
    d->anchorButton = new QPushButton(d->widget);
    d->anchorButton->setIcon (QIcon(":/icons/anchor.png"));
    //d->anchorButton->setText("a");
    d->anchorButton->setCheckable(true);
    d->anchorButton->setMaximumHeight(16);
    d->anchorButton->setMaximumWidth(16);
    d->anchorButton->setFocusPolicy(Qt::NoFocus);
    d->anchorButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->anchorButton->setObjectName("tool");
    
    connect(d->anchorButton, SIGNAL(clicked(bool)), this, SIGNAL(becomeDaddy(bool)));
    
    d->linkButton = new QPushButton(d->widget);
    d->linkButton->setIcon (QIcon(":/icons/link.png"));
    //d->linkButton->setText("l");
    d->linkButton->setCheckable(true);
    d->linkButton->setMaximumHeight(16);
    d->linkButton->setMaximumWidth(16);
    d->linkButton->setFocusPolicy(Qt::NoFocus);
    d->linkButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->linkButton->setObjectName("tool");
    
    connect(d->linkButton, SIGNAL(clicked(bool)), this, SLOT(setLinkPosition(bool)));
    connect(d->linkButton, SIGNAL(clicked(bool)), this, SLOT(setLinkCamera(bool)));
    
    d->linkWLButton = new QPushButton(d->widget);
    d->linkWLButton->setIcon (QIcon(":/icons/link_wl.png"));
    //d->linkWLButton->setText("l");
    d->linkWLButton->setCheckable(true);
    d->linkWLButton->setMaximumHeight(16);
    d->linkWLButton->setMaximumWidth(16);
    d->linkWLButton->setFocusPolicy(Qt::NoFocus);
    d->linkWLButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->linkWLButton->setObjectName("tool");

    connect(d->linkWLButton, SIGNAL(clicked(bool)), this, SLOT(setLinkWindowing(bool)));
    
    d->fullScreenButton = new QPushButton(d->widget);
    // d->fullScreenButton->setIcon (QIcon(":/icons/link_wl.png"));
    d->fullScreenButton->setText("M");
    d->fullScreenButton->setCheckable(true);
    d->fullScreenButton->setMaximumHeight(16);
    d->fullScreenButton->setMaximumWidth(16);
    d->fullScreenButton->setFocusPolicy(Qt::NoFocus);
    d->fullScreenButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->fullScreenButton->setObjectName("tool");
    
    connect(d->fullScreenButton, SIGNAL(clicked(bool)), this, SIGNAL(fullScreen(bool)));
    
    d->registerButton = new QPushButton(d->widget);
    d->registerButton->setIcon (QIcon(":/icons/cog.png"));
    //d->registerButton->setText("r");
    d->registerButton->setCheckable(true);
    d->registerButton->setMaximumHeight(16);
    d->registerButton->setMaximumWidth(16);
    d->registerButton->setFocusPolicy(Qt::NoFocus);
    d->registerButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->registerButton->setObjectName("tool");
    
    connect(d->registerButton, SIGNAL(clicked(bool)), this, SIGNAL(reg(bool)));
    
    d->playButton = new QPushButton(d->widget);
    d->playButton->setText(">");
    d->playButton->setCheckable(true);
    d->playButton->setMaximumHeight(16);
    d->playButton->setMaximumWidth(16);
    d->playButton->setFocusPolicy(Qt::NoFocus);
    d->playButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->playButton->setObjectName("tool");
    
    connect(d->playButton, SIGNAL(clicked(bool)), this, SLOT(play(bool)));
    
    d->closeButton = new QPushButton(d->widget);
    d->closeButton->setText("x");
    d->closeButton->setCheckable(false);
    d->closeButton->setMaximumHeight(16);
    d->closeButton->setMaximumWidth(16);
    d->closeButton->setFocusPolicy(Qt::NoFocus);
    d->closeButton->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    d->closeButton->setObjectName("tool");
    
    connect(d->closeButton, SIGNAL(clicked()), this, SIGNAL(closing()));
    
    QButtonGroup *toolButtonGroup = new QButtonGroup(d->widget);
    toolButtonGroup->addButton(d->anchorButton);
    toolButtonGroup->addButton(d->linkButton);
    toolButtonGroup->setExclusive(false);
    
    d->vtkWidget = new QVTKWidget(d->widget);
    d->vtkWidget->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum);
    d->vtkWidget->setFocusPolicy(Qt::NoFocus);
    
    vtkRenderWindow* renwin = vtkRenderWindow::New();
    renwin->StereoCapableWindowOn();
    renwin->SetStereoTypeToCrystalEyes();
    // if(qApp->arguments().contains("--stereo"))
    //     renwin->SetStereoRender(1);
    
    d->vtkWidget->SetRenderWindow(renwin);
    renwin->Delete();
    
    QHBoxLayout *toolsLayout = new QHBoxLayout;
    toolsLayout->setContentsMargins(0, 0, 0, 0);
    toolsLayout->setSpacing(0);
    toolsLayout->addWidget(d->dimensionBox);
    toolsLayout->addWidget(d->playButton);
    toolsLayout->addWidget(d->slider);
    toolsLayout->addWidget(d->anchorButton);
    toolsLayout->addWidget(d->linkButton);
    toolsLayout->addWidget(d->linkWLButton);
    toolsLayout->addWidget(d->registerButton);
    toolsLayout->addWidget(d->fullScreenButton);
    toolsLayout->addWidget(d->closeButton);
    
    QVBoxLayout *layout = new QVBoxLayout(d->widget);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->setSpacing(0);
    layout->addLayout(toolsLayout);
    layout->addWidget(d->vtkWidget);
    
    //d->view3d->SetRenderWindow(d->vtkWidget->GetRenderWindow());
    d->view3d->SetRenderWindowInteractor(d->vtkWidget->GetRenderWindow()->GetInteractor());
    d->view3d->SetRenderWindow(d->vtkWidget->GetRenderWindow());
    d->view3d->UnInstallInteractor();
    d->vtkWidget->GetRenderWindow()->RemoveRenderer(d->renderer3d);
    
    d->view2d->SetRenderWindow(d->vtkWidget->GetRenderWindow()); // set the interactor as well
    //d->view2d->SetRenderWindowInteractor(d->vtkWidget->GetRenderWindow()->GetInteractor());
    
    d->collection = vtkImageViewCollection::New();
    d->collection->SetLinkCurrentPoint (0);
    d->collection->SetLinkSliceMove (0);
    d->collection->SetLinkColorWindowLevel (0);
    d->collection->SetLinkCamera (0);
    d->collection->SetLinkZoom (0);
    d->collection->SetLinkPan (0);
    d->collection->SetLinkTimeChange (0);
    d->collection->SetLinkRequestedPosition (0);
    
    d->collection->AddItem (d->view2d);
    d->collection->AddItem (d->view3d);
    
    d->observer = v3dViewObserver::New();
    d->observer->setSlider(d->slider);
    d->observer->setView ( this );
    
    //d->view2d->GetInteractorStyle()->AddObserver(vtkImageView2DCommand::SliceMoveEvent, d->observer, 0);
    d->view2d->AddObserver(vtkImageView::CurrentPointChangedEvent, d->observer, 0);
    d->view2d->AddObserver(vtkImageView::WindowLevelChangedEvent,  d->observer, 0);
    d->view2d->GetInteractorStyle()->AddObserver(vtkImageView2DCommand::CameraZoomEvent, d->observer, 0);
    d->view2d->GetInteractorStyle()->AddObserver(vtkImageView2DCommand::CameraPanEvent, d->observer, 0);
    d->view3d->GetInteractorStyle()->AddObserver(vtkCommand::InteractionEvent, d->observer, 0);
    
    
    // 2D mode
    QAction *axialAct = new QAction(tr("Axial"), d->vtkWidget);
    connect(axialAct, SIGNAL(triggered()), this, SLOT(onMenuAxialTriggered()));
    
    QAction *coronalAct = new QAction(tr("Coronal"), d->vtkWidget);
    connect(coronalAct, SIGNAL(triggered()), this, SLOT(onMenuCoronalTriggered()));
    
    QAction *sagittalAct = new QAction(tr("Sagittal"), d->vtkWidget);
    connect(sagittalAct, SIGNAL(triggered()), this, SLOT(onMenuSagittalTriggered()));
    
    // 3D mode
    QAction *vrAct = new QAction(tr("VR"), d->vtkWidget);
    connect(vrAct, SIGNAL(triggered()), this, SLOT(onMenu3DVRTriggered()));
    
    QAction *maxipAct = new QAction(tr("MIP - Max"), d->vtkWidget);
    connect(maxipAct, SIGNAL(triggered()), this, SLOT(onMenu3DMaxIPTriggered()));
    
    QAction *minipAct = new QAction(tr("MIP - Min"), d->vtkWidget);
    connect(minipAct, SIGNAL(triggered()), this, SLOT(onMenu3DMinIPTriggered()));
    
    QAction *mprAct = new QAction(tr("MPR"), d->vtkWidget);
    connect(mprAct, SIGNAL(triggered()), this, SLOT(onMenu3DMPRTriggered()));
	
    QAction *offAct = new QAction(tr("Off"), d->vtkWidget);
    connect(offAct, SIGNAL(triggered()), this, SLOT(onMenu3DOffTriggered())); 
    
    // Volume Mapper
    QAction *gpuAct = new QAction(tr("GPU"), d->vtkWidget);
    connect(gpuAct, SIGNAL(triggered()),
            this,   SLOT(onMenuVRGPUTriggered()));
    
    QAction *rntAct = new QAction(tr("Ray Cast / Texture"), d->vtkWidget);
    connect(rntAct, SIGNAL(triggered()),
            this,   SLOT(onMenuVRRayCastAndTextureTriggered()));
    
    QAction *rayAct = new QAction(tr("Ray Cast"), d->vtkWidget);
    connect(rayAct, SIGNAL(triggered()),
            this,   SLOT(onMenuVRRayCastTriggered()));
        
    QAction *defAct = new QAction(tr("Default"), d->vtkWidget);
    connect(defAct, SIGNAL(triggered()),
            this,   SLOT(onMenuVRDefaultTriggered()));
    
    QAction *lodAct = new QAction(tr("Toggle LOD"), d->vtkWidget);
    connect(lodAct, SIGNAL(triggered()),
            this,   SLOT(onMenu3DLODTriggered()));
    
    // Tools
    QAction *zoomAct = new QAction(tr("Zoom"), d->vtkWidget);
    connect(zoomAct, SIGNAL(triggered()), this, SLOT(onMenuZoomTriggered()));
    
    QAction *wlAct = new QAction(tr("Window / Level"), d->vtkWidget);
    connect(wlAct, SIGNAL(triggered()), this, SLOT(onMenuWindowLevelTriggered()));
    
    QActionGroup *group = new QActionGroup(d->vtkWidget);
    group->addAction(zoomAct);
    group->addAction(wlAct);
    wlAct->setChecked(true);
    
    d->menu = new QMenu(d->vtkWidget );
    d->menu->addAction(axialAct);
    d->menu->addAction(coronalAct);
    d->menu->addAction(sagittalAct);
    
    QMenu *tridMenu = d->menu->addMenu (tr ("3D"));
    tridMenu->addAction (vrAct);
    tridMenu->addAction (maxipAct);
    tridMenu->addAction (minipAct);
    tridMenu->addAction (mprAct);
    tridMenu->addAction (offAct);
    
    QMenu *vrMenu = d->menu->addMenu (tr ("Renderer"));
    vrMenu->addAction (gpuAct);
    vrMenu->addAction (rntAct);
    vrMenu->addAction (rayAct);
    vrMenu->addAction (defAct);
    
    d->menu->addAction(lodAct);
    
    d->menu->addSeparator();
    d->menu->addAction(zoomAct);
    d->menu->addAction(wlAct);
    
    // set property to actually available presets
    QStringList lut = this->getAvailableTransferFunctionPresets();
    this->addProperty ("LookupTable",           lut);
    
    // set default properties
    this->setProperty ("Orientation",           "Axial");
    this->setProperty ("ShowScalarBar",         "false");
    this->setProperty ("ShowAxis",              "false");
    this->setProperty ("ShowRuler",             "true");
    this->setProperty ("ShowAnnotations",       "true");
    this->setProperty ("LookupTable",           "Default");
    this->setProperty ("MouseInteraction",      "Zooming");
    this->setProperty ("3DMode",                "VR");
#ifdef __APPLE__
    this->setProperty ("Renderer", "Ray Cast");
#else
    this->setProperty ("Renderer", "Default");
#endif    
    this->setProperty ("UseLOD",   "On");
    this->setProperty ("Cropping", "false");
    this->setProperty ("Preset",   "None");
    
    this->setProperty ("PositionLinked",   "false");
    this->setProperty ("WindowingLinked",  "false");
    this->setProperty ("Daddy",            "false");
    
    connect(d->vtkWidget,    SIGNAL(mouseEvent(QMouseEvent*)),     this, SLOT(onMousePressEvent(QMouseEvent*)));
    connect(d->slider,       SIGNAL(valueChanged(int)),            this, SLOT(onZSliderValueChanged(int)));
    connect(d->dimensionBox, SIGNAL(currentIndexChanged(QString)), this, SLOT(onDimensionBoxChanged(QString)));
}

v3dView::~v3dView(void)
{
    d->vtkWidget->GetRenderWindow()->RemoveRenderer(d->renderer2d);
    d->vtkWidget->GetRenderWindow()->RemoveRenderer(d->renderer3d);
    
    /*
     d->view2D->SetRenderWindow(0);
     d->view2D->SetRenderWindowInteractor(0);
     d->view3D->SetRenderWindow(0);
     d->view3D->SetRenderWindowInteractor(0);
     */
    
    d->view2d->Delete();
    d->renderer2d->Delete();
    d->view3d->UnInstallInteractor();
    d->view3d->Delete();
    d->renderer3d->Delete();
    
    d->collection->Delete();

    d->observer->Delete();

    d->widget->deleteLater();

    delete d;
    
    d = NULL;
}

bool v3dView::registered(void)
{
    return dtkAbstractViewFactory::instance()->registerViewType("v3dView", createV3dView);
}

QString v3dView::description(void) const
{
    return "v3dView";
}

// /////////////////////////////////////////////////////////////////
// 
// /////////////////////////////////////////////////////////////////

void v3dView::clear(void)
{
    d->collection->SyncSetInput (0); // to be tested
}

void v3dView::reset(void)
{
    if(!d->collection)
        return;
    
    d->collection->SyncReset();
    
    // update slider position
    if (d->currentView)
        d->currentView->GetInteractorStyle()->InvokeEvent(vtkImageView2DCommand::SliceMoveEvent, NULL);
}

void v3dView::update(void)
{
    if( d->currentView ) {
        d->currentView->Render();
    }
    d->vtkWidget->update();
}

void *v3dView::view(void)
{
    return d->currentView;
}

vtkImageView2D *v3dView::view2d(void)
{
    return d->view2d;
}

vtkImageView3D *v3dView::view3d(void)
{
    return d->view3d;
}

vtkImageView *v3dView::currentView(void)
{
    return d->currentView;
}

vtkRenderWindowInteractor *v3dView::interactor(void)
{
    return d->vtkWidget->GetRenderWindow()->GetInteractor();
}

vtkRenderer *v3dView::renderer2d(void)
{
    return d->renderer2d;
}

vtkRenderer *v3dView::renderer3d(void)
{
    return d->renderer3d;
}

void v3dView::setData(dtkAbstractData *data)
{
    if(!data)
        return;

#ifdef vtkINRIA3D_USE_ITK
    if (data->description()=="itkDataImageChar3") {
        if( itk::Image<char, 3>* image = dynamic_cast<itk::Image<char, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageUChar3") {
        if( itk::Image<unsigned char, 3>* image = dynamic_cast<itk::Image<unsigned char, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageShort3") {
        if( itk::Image<short, 3>* image = dynamic_cast<itk::Image<short, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageShort4") {
        if( itk::Image<short, 4>* image = dynamic_cast<itk::Image<short, 4>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput4(image);
            d->view3d->SetITKInput4(image);
        }
    }
    else if (data->description()=="itkDataImageUShort3") {
        if( itk::Image<unsigned short, 3>* image = dynamic_cast<itk::Image<unsigned short, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageUShort4") {
        if( itk::Image<unsigned short, 4>* image = dynamic_cast<itk::Image<unsigned short, 4>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput4(image);
            d->view3d->SetITKInput4(image);
        }
    }
    else if (data->description()=="itkDataImageFloat4") {
        if( itk::Image<float, 4>* image = dynamic_cast<itk::Image<float, 4>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput4(image);
            d->view3d->SetITKInput4(image);
		}
    }	
    else if (data->description()=="itkDataImageInt3") {
        if( itk::Image<int, 3>* image = dynamic_cast<itk::Image<int, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageUInt3") {
        if( itk::Image<unsigned int, 3>* image = dynamic_cast<itk::Image<unsigned int, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageLong3") {
        if( itk::Image<long, 3>* image = dynamic_cast<itk::Image<long, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageULong3") {
        if( itk::Image<unsigned long, 3>* image = dynamic_cast<itk::Image<unsigned long, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageFloat3") {
        if( itk::Image<float, 3>* image = dynamic_cast<itk::Image<float, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageDouble3") {
        if( itk::Image<double, 3>* image = dynamic_cast<itk::Image<double, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageRGB3") {
        if( itk::Image<itk::RGBPixel<unsigned char>, 3> *image = dynamic_cast<itk::Image<itk::RGBPixel<unsigned char>, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else if (data->description()=="itkDataImageVector3") {
        if( itk::Image<itk::Vector<unsigned char, 3>, 3> *image = dynamic_cast<itk::Image<itk::Vector<unsigned char, 3>, 3>*>( (itk::Object*)( data->data() ) ) ) {
            d->view2d->SetITKInput(image);
            d->view3d->SetITKInput(image);
        }
    }
    else
#endif
        if (data->description()=="v3dDataImage") {
            if(vtkImageData *dataset = dynamic_cast<vtkImageData*>((vtkDataObject *)(data->data()))) {
                //d->collection->SyncSetInput(dataset);
                d->view2d->SetInput(dataset);
                d->view3d->SetInput(dataset);
            }
        }
        else if ( data->description() == "vtkDataMesh" ) {
            
            this->enableInteractor ( "v3dViewMeshInteractor" );
            // This will add the data to the interactor.
            dtkAbstractView::setData(data);
        }
	else if ( data->description() == "v3dDataFibers" ) {
            
            this->enableInteractor ( "v3dViewFiberInteractor" );
            // This will add the data to the interactor.
            dtkAbstractView::setData(data);
        }
        else {
            dtkAbstractView::setData(data);
            return;
        }
    
    d->data = data;
    d->imageData = dynamic_cast<dtkAbstractDataImage*> (data);
    
    if (data->hasMetaData("PatientName")){
        const QString patientName = data->metaDataValues(tr("PatientName"))[0];	
        d->view2d->SetPatientName (patientName.toAscii().constData());
        d->view3d->SetPatientName (patientName.toAscii().constData());
    }
    
    if( data->hasMetaData("StudyDescription")){
        const QString studyName = data->metaDataValues(tr("StudyDescription"))[0];
        d->view2d->SetStudyName (studyName.toAscii().constData());
        d->view3d->SetStudyName (studyName.toAscii().constData());
    }
    
    if (data->hasMetaData("SeriesDescription")){
        const QString seriesName = data->metaDataValues(tr("SeriesDescription"))[0];
        d->view2d->SetSeriesName (seriesName.toAscii().constData());
        d->view3d->SetSeriesName (seriesName.toAscii().constData());
    }
    
    
    if(d->imageData) {
        d->slider->blockSignals (true);
        if (d->dimensionBox->currentText()==tr("Space")) {
            if( d->orientation=="Axial") {
                d->slider->setRange(0, d->imageData->zDimension()-1);
            }
            else if( d->orientation=="Sagittal") {
                d->slider->setRange(0, d->imageData->xDimension()-1);
            }
            else if( d->orientation=="Coronal") {
                d->slider->setRange(0, d->imageData->yDimension()-1);
            }
        }
        else if (d->dimensionBox->currentText()==tr("Time")) {
            d->slider->setRange(0, d->imageData->tDimension()-1);
        }
        d->slider->blockSignals (false);
    }

    // this->update(); // update is not the role of the plugin, but of the app
}

void *v3dView::data (void)
{
    return d->data;
}

QWidget *v3dView::receiverWidget(void)
{
    return d->vtkWidget;
}

QWidget *v3dView::widget(void)
{
    return d->widget;
}

void v3dView::play(bool start)
{
    d->timeline->setFrameRange(d->slider->minimum(), d->slider->maximum() );
    
    if(start)
		d->timeline->start();
	else
		d->timeline->stop();
}

void v3dView::onPropertySet(const QString &key, const QString &value)
{
    if(key == "Daddy")
        this->onDaddyPropertySet(value);
    
    if(key == "Orientation")
        this->onOrientationPropertySet(value);
    
    if(key == "ShowScalarBar")
        this->onShowScalarBarPropertySet(value);
    
    if(key == "LookupTable")
        this->onLookupTablePropertySet(value);
    
    if(key == "ShowAxis")
        this->onShowAxisPropertySet(value);
    
    if(key == "ShowRuler")
        this->onShowRulerPropertySet(value);
    
    if(key == "ShowAnnotations")
        this->onShowAnnotationsPropertySet(value);
    
    if(key == "MouseInteraction")
        this->onMouseInteractionPropertySet(value);
    
    if(key == "3DMode")
        this->on3DModePropertySet(value);
    
    if(key == "Renderer")
        this->onRendererPropertySet(value);
    
    if(key == "UseLOD")
        this->onUseLODPropertySet(value);
    
    if(key == "Preset")
        this->onPresetPropertySet(value);
    
    if(key == "Cropping")
        this->onCroppingPropertySet(value);
    
    if(key == "PositionLinked")
        this->onPositionLinkedPropertySet(value);
    
    if(key == "WindowingLinked")
        this->onWindowingLinkedPropertySet(value);
    
    //this->update(); // never update after setting a property, it is not our role
    
}

void v3dView::onOrientationPropertySet(const QString &value)
{
    if (value==d->orientation)
        return;
    
    this->blockSignals(true);
    
    double pos[3], window = 0.0, level = 0.0;
    int timeIndex = 0;
    if( d->currentView ) {
        d->currentView->GetCurrentPoint (pos);
        window = d->currentView->GetColorWindow();
        level  = d->currentView->GetColorLevel();
        timeIndex = d->currentView->GetTimeIndex();
        
        d->currentView->UnInstallInteractor();
        // d->currentView->SetRenderWindow( 0 );
        
        // d->currentView->GetInteractorStyle()->RemoveObserver(d->observer);
        d->vtkWidget->GetRenderWindow()->RemoveRenderer(d->currentView->GetRenderer());
    }
    
    if (value=="3D") {
        d->orientation = "3D";
        d->currentView = d->view3d;	
    }
    
    // in case the max range becomes smaller than the actual value, a signal is emitted and
    // we don't want it
    d->slider->blockSignals (true);
    
    if (value == "Axial") {
        d->orientation = "Axial";
        d->view2d->SetSliceOrientation(vtkImageView2D::VIEW_ORIENTATION_AXIAL);
        d->currentView = d->view2d;
        
        if (d->dimensionBox->currentText()==tr("Space") && d->imageData) {
            d->slider->setRange (0, d->imageData->zDimension()-1);
        }
    }
	
    if (value == "Sagittal") {
        d->orientation = "Sagittal";
        d->view2d->SetSliceOrientation(vtkImageView2D::VIEW_ORIENTATION_SAGITTAL);
        d->currentView = d->view2d;
        
        if (d->dimensionBox->currentText()==tr("Space") && d->imageData) {
            d->slider->setRange (0, d->imageData->xDimension()-1);
        }
    }
    
    if (value == "Coronal") {
        d->orientation = "Coronal";
        d->view2d->SetSliceOrientation(vtkImageView2D::VIEW_ORIENTATION_CORONAL);
        d->currentView = d->view2d;
        
        if (d->dimensionBox->currentText()==tr("Space") && d->imageData) {
            d->slider->setRange (0, d->imageData->yDimension()-1);
        }
    }
    
    if (d->dimensionBox->currentText()==tr("Time") && d->imageData) {
        d->slider->setRange(0, d->imageData->tDimension()-1);
    }
	
    if (!d->currentView) {
        d->slider->blockSignals (false);
        this->blockSignals(false);
        return;
    }
    
    d->currentView->SetRenderWindow ( d->vtkWidget->GetRenderWindow() );
	
    //d->currentView->InstallInteractor();
    //d->currentView->AddObserver(vtkImageView::CurrentPointChangedEvent, d->observer, 15);
    //d->currentView->GetInteractorStyle()->AddObserver(vtkImageView2DCommand::SliceMoveEvent, d->observer, 0);
    /*
     d->currentView->AddObserver(vtkImageView::CurrentPointChangedEvent, d->observer, 0);
     d->currentView->GetInteractorStyle()->AddObserver(vtkImageView2DCommand::CameraZoomEvent, d->observer, 0);
     d->currentView->GetInteractorStyle()->AddObserver(vtkImageView2DCommand::CameraPanEvent, d->observer, 0);
     d->view3d->GetInteractorStyle()->AddObserver(vtkCommand::InteractionEvent, d->observer, 0);
     */
    
    //d->observer->setView ( d->currentView );
    
    d->currentView->SetCurrentPoint (pos);
    d->currentView->SetColorWindow  (window);
    d->currentView->SetColorLevel   (level);
    d->currentView->SetTimeIndex    (timeIndex);
    
    
    // force a correct display of the 2D axis for planar views
    d->currentView->InvokeEvent (vtkImageView::CurrentPointChangedEvent, NULL); // seems not needed anymore
    
    // update slider position
    if (d->dimensionBox->currentText()==tr("Space")) {
        if (vtkImageView2D *view2d = vtkImageView2D::SafeDownCast (d->currentView)) {
            unsigned int zslice = view2d->GetSlice();
            d->slider->setValue (zslice);
        }
    }
    else if (d->dimensionBox->currentText()==tr("Time")) {
        d->slider->setValue(d->currentView->GetTimeIndex());
    }
    
    d->slider->blockSignals (false);
    this->blockSignals(false);
}

void v3dView::on3DModePropertySet (const QString &value)
{
    if (value=="VR") {
        d->view3d->SetRenderingModeToVR();
        d->view3d->SetVolumeRayCastFunctionToComposite();
    }
    
    if (value=="MPR") {
        d->view3d->SetRenderingModeToPlanar();
        d->view3d->ShowActorXOn();
        d->view3d->ShowActorYOn();
        d->view3d->ShowActorZOn();
    }
    
    if (value=="MIP - Maximum") {
        d->view3d->SetRenderingModeToVR();
        d->view3d->SetVolumeRayCastFunctionToMaximumIntensityProjection();
    }
    
    if (value=="MIP - Minimum") {
        d->view3d->SetRenderingModeToVR();
        d->view3d->SetVolumeRayCastFunctionToMinimumIntensityProjection();
    }
	
    if (value=="Off") {
        d->view3d->SetRenderingModeToPlanar();
        d->view3d->ShowActorXOff();
        d->view3d->ShowActorYOff();
        d->view3d->ShowActorZOff();
    } 
}

void v3dView::onRendererPropertySet (const QString &value)
{
    if (value=="GPU")
        d->view3d->SetVolumeMapperToGPU();

    if (value=="Ray Cast / Texture")
        d->view3d->SetVolumeMapperToRayCastAndTexture();
    
    if (value=="Ray Cast")
        d->view3d->SetVolumeMapperToRayCast();

    if (value=="Default")
        d->view3d->SetVolumeMapperToDefault();
}

void v3dView::onUseLODPropertySet (const QString &value)
{
    // if (value == "On")
    //     d->view3d->UseVRQualityOn();
    // else
    //     d->view3d->UseVRQualityOff();
}

void v3dView::onShowScalarBarPropertySet(const QString &value)
{
    if (value == "true") {
        d->collection->SyncSetShowScalarBar(true);
    }
    
    if (value == "false") {
        d->collection->SyncSetShowScalarBar(false);
    }
}

void v3dView::onLookupTablePropertySet(const QString &value)
{
    typedef vtkTransferFunctionPresets Presets;
    
    vtkColorTransferFunction * rgb   = vtkColorTransferFunction::New();
    vtkPiecewiseFunction     * alpha = vtkPiecewiseFunction::New();
    Presets::GetTransferFunction( value.toStdString(), rgb, alpha );
    // d->currentView->SetColorTransferFunction( rgb );
    // d->currentView->SetOpacityTransferFunction( alpha );
    d->collection->SyncSetColorTransferFunction( rgb );
    d->collection->SyncSetOpacityTransferFunction( alpha );
    rgb->Delete();
    alpha->Delete();
    
    emit lutChanged();
}

void v3dView::onShowAxisPropertySet(const QString &value)
{
    if (value == "true") {
        d->collection->SyncSetShowImageAxis(1);
        if (d->currentView) {
            d->currentView->InvokeEvent(vtkImageView2D::CurrentPointChangedEvent);
        }
    }
    
    if (value == "false")
        d->collection->SyncSetShowImageAxis(0);
}

void v3dView::onShowRulerPropertySet(const QString &value)
{
    d->collection->SyncSetShowRulerWidget ((value == "true"));  
}

void v3dView::onShowAnnotationsPropertySet(const QString &value)
{
    d->collection->SyncSetShowAnnotations ((value == "true"));
}

void v3dView::onMouseInteractionPropertySet(const QString &value)
{
    d->collection->SyncSetMiddleButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypeSlice);
    
    if (value == "Zooming") {
        d->collection->SyncSetLeftButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypeZoom);
        d->collection->SyncSetMiddleButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypePan);
    }
    
    if (value == "Windowing") {
        d->collection->SyncSetLeftButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypeWindowLevel);
    }    
    
    if (value == "Slicing") {
        d->collection->SyncSetLeftButtonInteractionStyle(vtkInteractorStyleImageView2D::InteractionTypeSlice);
    }
    
    if (value == "Measuring") {
        d->view2d->ShowDistanceWidgetOn();
    }
    else {
        d->view2d->ShowDistanceWidgetOff();
    }
}

void v3dView::onPresetPropertySet (const QString &value)
{
    if( value == "VR Muscles&Bones" ) {
        
        this->onLookupTablePropertySet ("Muscles & Bones");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (337.0, 0, 1);
        d->collection->SyncSetColorLevel (1237.0, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->collection->SyncSetAboutData ("VR Muscles - Bones - Powered by magic Pedro");
    }
    else if( value == "Vascular I" ) {
        
        this->onLookupTablePropertySet ("Stern");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (388.8, 0, 1);
        d->collection->SyncSetColorLevel (362.9, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Vascular - Powered by magic Pedro");
    }
    else if( value == "Vascular II" ) {
        
        this->onLookupTablePropertySet ("Red Vessels");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (189.6, 0, 1);
        d->collection->SyncSetColorLevel (262.3, 0, 1);
        
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Vascular II - Powered by magic Pedro");
    }
    else if( value == "Vascular III" ) {
        
        this->onLookupTablePropertySet ("Red Vessels");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (284.4, 0, 1);
        d->collection->SyncSetColorLevel (341.7, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Vascular III - Powered by magic Pedro");
    }
    else if( value == "Vascular IV" ) {
        
        this->onLookupTablePropertySet ("Red Vessels");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (272.5, 0, 1);
        d->collection->SyncSetColorLevel (310.9, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Vascular IV - Powered by magic Pedro");
    }
    else if( value == "Standard" ) {
        
        this->onLookupTablePropertySet ("Muscles & Bones");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (243.7, 0, 1);
        d->collection->SyncSetColorLevel (199.6, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Standard - Powered by magic Pedro");
    }
    else if( value == "Soft" ) {
        
        this->onLookupTablePropertySet ("Bones");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (133.5, 0, 1);
        d->collection->SyncSetColorLevel (163.4, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Soft - Powered by magic Pedro");
    }
    else if( value == "Soft on White" ) {
        
        this->onLookupTablePropertySet ("Muscles & Bones");
        
        double color[3] = {1.0,0.98820477724075317,0.98814374208450317};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (449.3, 0, 1);
        d->collection->SyncSetColorLevel (372.8, 0, 1);
        //d->view->SetAboutData ("Soft on White - Powered by magic Pedro");
    }
    else if( value == "Soft on Blue" ) {
        
        this->onLookupTablePropertySet ("Muscles & Bones");
        
        double color[3]={0.0, 0.27507439255714417, 0.26398107409477234};      
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (449.3, 0, 1);
        d->collection->SyncSetColorLevel (372.8, 0, 1);
        //d->collection->SetAboutData ("Soft on Blue - Powered by magic Pedro");
    }
    else if( value == "Red on White" ) {
        
        this->onLookupTablePropertySet ("Red Vessels");

        double color[3]={1.0, 0.98820477724075317, 0.98814374208450317};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (449.3, 0, 1);
        d->collection->SyncSetColorLevel (372.8, 0, 1);
        //d->view->SetAboutData ("Red on White - Powered by magic Pedro");
    }
    else if( value == "Glossy" ) {
        
        this->onLookupTablePropertySet ("Bones");
        
        double color[3] = {0.0, 0.0, 0.0};
        
        d->collection->SyncSetBackground( color );
        d->collection->SyncSetColorWindow (133.5, 0, 1);
        d->collection->SyncSetColorLevel (163.4, 0, 1);
        //d->collection->SyncSetTextColor ( white );
        //d->view->SetAboutData ("Glossy - Powered by magic Pedro");
    }
    else {
        return; // to prevent trigger of event lutChanged()
    }
    
    emit lutChanged();
}

void v3dView::onCroppingPropertySet (const QString &value)
{
    if ( value=="true" ) {
        if (d->view3d->GetBoxWidget()->GetInteractor()) { // avoid VTK warnings
            d->view3d->SetCroppingModeToOutside();
            d->view3d->SetShowBoxWidget ( 1 );
        }
    }
    else {
        if (d->view3d->GetBoxWidget()->GetInteractor()) {
	  // d->view3D->SetCroppingModeToOff ();
            d->view3d->SetShowBoxWidget ( 0 );
        }
    }
}

void v3dView::onMousePressEvent(QMouseEvent *event)
{
    if(event->button() == Qt::RightButton) {
        d->menu->popup (event->globalPos());
    }
}

void v3dView::onZSliderValueChanged (int value)
{
    if (!d->currentView)
        return;
    
    if (d->dimensionBox->currentText()==tr("Space")) {
        if( vtkImageView2D *view = vtkImageView2D::SafeDownCast(d->currentView) ) {
            d->observer->lock();
            view->SetSlice (value);
            //view->GetInteractorStyle()->InvokeEvent(vtkImageView2DCommand::SliceMoveEvent);
            d->observer->unlock();
            
            double *pos = view->GetCurrentPoint();
            QVector3D position (pos[0], pos[1], pos[2]);
            emit positionChanged(position);
        }
    }
    else if (d->dimensionBox->currentText()==tr("Time")) {
        if( d->currentView ) {
            d->currentView->SetTimeIndex (value);
            d->currentView->GetInteractorStyle()->InvokeEvent(vtkImageView2DCommand::TimeChangeEvent);	
        }
    }
    
    //qApp->processEvents();
    d->currentView->Render();
}

void v3dView::onDaddyPropertySet (const QString &value)
{
    d->anchorButton->blockSignals(true);
	d->registerButton->blockSignals(true);
    
    if (value=="true") {
        d->anchorButton->setChecked (true);        
        d->registerButton->setChecked (false);
        d->registerButton->setEnabled(false);
        d->anchorButton->blockSignals(false);
    }
    
    if (value=="false") {
        d->anchorButton->setChecked (false);        
        d->registerButton->setEnabled(true);
    }
    
    d->anchorButton->blockSignals(false);
    d->registerButton->blockSignals(false);
}

void v3dView::onPositionLinkedPropertySet (const QString &value)
{
    if (value=="true") {
        d->linkButton->setChecked (true);
    }
    
    if (value=="false") {
        d->linkButton->setChecked (false);
    }
}

void v3dView::onWindowingLinkedPropertySet (const QString &value)
{
    if (value=="true") {
        d->linkWLButton->setChecked (true);
    }
    
    if (value=="false") {
        d->linkWLButton->setChecked (false);
    }
}

void v3dView::onDimensionBoxChanged (const QString &value)
{
    if (d->imageData) {
        
        d->slider->blockSignals (true);
        if (value=="Space") {
            d->observer->unlock();
            if( d->orientation=="Axial") {
                d->slider->setRange(0, d->imageData->zDimension()-1);
            }
            else if( d->orientation=="Sagittal") {
                d->slider->setRange(0, d->imageData->xDimension()-1);
            }
            else if( d->orientation=="Coronal") {
                d->slider->setRange(0, d->imageData->yDimension()-1);
            }
            if (vtkImageView2D *view2d = vtkImageView2D::SafeDownCast (d->currentView)) {
                unsigned int zslice = view2d->GetSlice();
                d->slider->setValue (zslice);
            }
        }
        else if (value=="Time") {
            d->observer->lock();
            d->slider->setRange(0, d->imageData->tDimension()-1);
            if (d->currentView) {
                unsigned int timeIndex = d->currentView->GetTimeIndex();
                d->slider->setValue (timeIndex);
            }
        }
        d->slider->blockSignals (false);
        d->timeline->setFrameRange(d->slider->minimum(), d->slider->maximum() );
    }
}

void v3dView::onMetaDataSet(const QString &key, const QString &value)
{
    // if (key == "VRQuality")        
    //     d->view3d->SetVRQuality((float)(value.toInt())/100.0);
    
    // if (key == "LOD")        
    //     d->view3d->SetVRQuality((float)(value.toInt())/100.0);
}

void v3dView::onMenuAxialTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(0);
    
    this->setProperty("Orientation", "Axial");
    d->view2d->Render();
}


void v3dView::onMenuCoronalTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(0);
    
    this->setProperty("Orientation", "Coronal");
    d->view2d->Render();
}


void v3dView::onMenuSagittalTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(0);
    
    this->setProperty("Orientation", "Sagittal");
    d->view2d->Render();
}

void v3dView::onMenu3DVRTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(1);
    
    this->setProperty ("3DMode", "VR");
    this->setProperty ("Orientation", "3D");
    d->view3d->Render();
}

void v3dView::onMenu3DMPRTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(1);
    
    this->setProperty("3DMode",      "MPR");
    this->setProperty("Orientation", "3D");
    d->view3d->Render();
}

void v3dView::onMenu3DMaxIPTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(1);
    
    this->setProperty("3DMode", "MIP - Maximum");
    this->setProperty("Orientation", "3D");
    d->view3d->Render();
}

void v3dView::onMenu3DMinIPTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(1);
    
    this->setProperty("3DMode", "MIP - Minimum");
    this->setProperty("Orientation", "3D");
    d->view3d->Render();
}

void v3dView::onMenu3DOffTriggered (void)
{
    if(qApp->arguments().contains("--stereo"))
        d->vtkWidget->GetRenderWindow()->SetStereoRender(1);
	
    this->setProperty("3DMode", "Off");
    d->view3d->Render();
}

void v3dView::onMenuVRGPUTriggered (void)
{
    this->setProperty("Renderer", "GPU");
    d->view3d->Render();
}

void v3dView::onMenuVRRayCastAndTextureTriggered (void)
{
    this->setProperty("Renderer", "Ray Cast / Texture");
    d->view3d->Render();
}

void v3dView::onMenuVRRayCastTriggered (void)
{
    this->setProperty("Renderer", "Ray Cast");
    d->view3d->Render();
}

void v3dView::onMenuVRDefaultTriggered (void)
{
    this->setProperty("Renderer", "Default");
    d->view3d->Render();
}

void v3dView::onMenu3DLODTriggered (void)
{
    if ( this->property( "UseLOD" ) == "On" )
        this->setProperty ("UseLOD", "Off");
    else
        this->setProperty ("UseLOD", "On");
    d->view3d->Render();
}

void v3dView::onMenuZoomTriggered (void)
{
    this->setProperty ("MouseInteraction", "Zooming");
}

void v3dView::onMenuWindowLevelTriggered (void)
{
    this->setProperty ("MouseInteraction", "Windowing");
}

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractView *createV3dView(void)
{
    return new v3dView;
}

QStringList v3dView::getAvailableTransferFunctionPresets()
{
    QStringList lut;
    typedef std::vector< std::string > StdStrVec;
    StdStrVec presets = vtkTransferFunctionPresets::GetAvailablePresets();
    for ( StdStrVec::iterator it( presets.begin() ), end( presets.end() );
         it != end; ++it )
        lut << QString::fromStdString( * it );
    
    return lut;
}

void v3dView::getTransferFunctions( QList<double> & scalars,
                                    QList<QColor> & colors )
{
    vtkColorTransferFunction * color   =
    d->currentView->GetColorTransferFunction();
    vtkPiecewiseFunction     * opacity = 
    d->currentView->GetOpacityTransferFunction();
    
    if ( color == NULL || opacity == NULL )
        return;
    
    if ( color->GetSize() != opacity->GetSize() )
        qDebug() << Q_FUNC_INFO << " sizes of color and opacity transfer "
	    "functions don't match!";
    int size = qMin( color->GetSize(), opacity->GetSize() );
    
    scalars.clear();
    colors.clear();
    
    bool ok = true;
    for ( int i = 0; i < size; i++ )
     {
        double xrgb[6], xalpha[4];
        color->GetNodeValue( i, xrgb );
        opacity->GetNodeValue( i, xalpha );
        if ( xrgb[0] != xalpha[0] )
            ok = false;
        
        scalars << xrgb[0];
        QColor c;
        c.setRgbF( xrgb[1], xrgb[2], xrgb[3], xalpha[1] );
        colors << c;
     }
    
    if ( !ok )
        qDebug() << Q_FUNC_INFO << " x values of color and opacity transfer "
	    "functions don't match!";
}

void v3dView::setTransferFunctions( QList< double > scalars,
                                    QList< QColor > colors )
{
    int size = qMin( scalars.count(), colors.count() );
    vtkColorTransferFunction * color   = vtkColorTransferFunction::New();
    vtkPiecewiseFunction     * opacity = vtkPiecewiseFunction::New();
    
    for ( int i = 0; i < size; i++ )
     {
        color->AddRGBPoint( scalars.at( i ),
                           colors.at( i ).redF(),
                           colors.at( i ).greenF(),
                           colors.at( i ).blueF() );
        opacity->AddPoint( scalars.at( i ), colors.at( i ).alphaF() );
     }
    
    // color->ClampingOff();
    // opacity->ClampingOff();
    
    double * range = color->GetRange();
    d->collection->SyncSetColorRange( range );
    
    d->collection->SyncSetColorTransferFunction( color );
    d->collection->SyncSetOpacityTransferFunction( opacity );
    
    color->Delete();
    opacity->Delete();
}

void v3dView::setColorLookupTable(QList<double> scalars, QList<QColor> colors)
{
    int size= qMin(scalars.count(),colors.count());
    vtkColorTransferFunction * ctf = vtkColorTransferFunction::New();
    vtkPiecewiseFunction * pf = vtkPiecewiseFunction::New();
    for (int i=0;i<size;i++)
     {
        ctf->AddRGBPoint(scalars.at(i),
                         colors.at(i).redF(),
                         colors.at(i).greenF(),
                         colors.at(i).blueF());
        pf->AddPoint(scalars.at(i),colors.at(i).alphaF());
     }
    
    double min = scalars.first();
    double max = scalars.last();
    int n = static_cast< int >( max - min ) + 1;
    double * table = new double[3*n];
    double * alphaTable = new double[n];
    ctf->GetTable( min, max, n, table );
    ctf->Delete();
    pf->GetTable(min,max,n,alphaTable);
    pf->Delete();
    
    vtkLookupTable * lut = vtkLookupTable::New();
    lut->SetNumberOfTableValues(n + 2);
    lut->SetTableRange( min - 1.0, max + 1.0 );
    // lut->Build();
    
    lut->SetTableValue( 0, 0.0, 0.0, 0.0, 0.0 );
    for ( int i = 0, j = 0; i < n; ++i, j += 3 )
        lut->SetTableValue(i+1, table[j], table[j+1], table[j+2], alphaTable[i] );
    lut->SetTableValue( n + 1, 0.0, 0.0, 0.0, 0.0 );
    
    d->currentView->SetLookupTable(lut);
    d->currentView->Render();
    lut->Delete();
    delete [] table;
    delete [] alphaTable;
}

// -- head tracking support

void v3dView::enableInteraction(void)
{
    if(this->property("Orientation") != "3D")
        return;
    
    d->widget->setAttribute(Qt::WA_TransparentForMouseEvents, false);
}

void v3dView::disableInteraction(void)
{
    if(this->property("Orientation") != "3D")
        return;
    
    // d->window->GetInteractor()->Disable();
    
    d->widget->setAttribute(Qt::WA_TransparentForMouseEvents, true);
}

void v3dView::bounds(float& xmin, float& xmax, float& ymin, float& ymax, float& zmin, float& zmax)
{
    if(this->property("Orientation") == "Axial") {
        
        double bounds[6]; d->renderer2d->ComputeVisiblePropBounds(bounds);
        
        xmin = bounds[0];
        xmax = bounds[1];
        ymin = bounds[2];
        ymax = bounds[3];
        zmin = bounds[4];
        zmax = bounds[5];
    }
    
    if(this->property("Orientation") == "Sagittal") {
        
        double bounds[6]; d->renderer2d->ComputeVisiblePropBounds(bounds);
        
        xmin = bounds[0];
        xmax = bounds[1];
        ymin = bounds[2];
        ymax = bounds[3];
        zmin = bounds[4];
        zmax = bounds[5];
    }
    
    if(this->property("Orientation") == "Coronal") {
        
        double bounds[6]; d->renderer2d->ComputeVisiblePropBounds(bounds);
        
        xmin = bounds[0];
        xmax = bounds[1];
        ymin = bounds[2];
        ymax = bounds[3];
        zmin = bounds[4];
        zmax = bounds[5];
    }
    
    if(this->property("Orientation") == "3D") {
        
        double bounds[6]; d->renderer3d->ComputeVisiblePropBounds(bounds);
        
        xmin = bounds[0];
        xmax = bounds[1];
        ymin = bounds[2];
        ymax = bounds[3];
        zmin = bounds[4];
        zmax = bounds[5];
    }
}

void v3dView::cameraUp(double *coordinates)
{
    if(this->property("Orientation") == "Axial") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetViewUp(coordinates);
    }
    
    if(this->property("Orientation") == "Sagittal") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetViewUp(coordinates);
    }
    
    if(this->property("Orientation") == "Coronal") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetViewUp(coordinates);
    }
    
    if(this->property("Orientation") == "3D") {
        
        vtkCamera *camera = d->renderer3d->GetActiveCamera();   
        camera->GetViewUp(coordinates);
    }
}

void v3dView::cameraPosition(double *coordinates)
{
    if(this->property("Orientation") == "Axial") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetPosition(coordinates);
    }
    
    if(this->property("Orientation") == "Sagittal") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetPosition(coordinates);
    }
    
    if(this->property("Orientation") == "Coronal") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetPosition(coordinates);
    }
    
    if(this->property("Orientation") == "3D") {
        vtkCamera *camera = d->renderer3d->GetActiveCamera();   
        camera->GetPosition(coordinates);
    }
}

void v3dView::cameraFocalPoint(double *coordinates)
{
    if(this->property("Orientation") == "Axial") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetFocalPoint(coordinates);
    }
    
    if(this->property("Orientation") == "Coronal") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetFocalPoint(coordinates);
    }
    
    if(this->property("Orientation") == "Sagittal") {
        
        vtkCamera *camera = d->renderer2d->GetActiveCamera();   
        camera->GetFocalPoint(coordinates);
    }
    
    if(this->property("Orientation") == "3D") {
        vtkCamera *camera = d->renderer3d->GetActiveCamera();   
        camera->GetFocalPoint(coordinates);
    }
}

void v3dView::setCameraPosition(double x, double y, double z)
{
    if(this->property("Orientation") != "3D")
        return;
    
    vtkCamera *camera = d->renderer3d->GetActiveCamera();
    
    camera->SetPosition(x, y, z);
    
    d->renderer3d->ResetCameraClippingRange();
}

// Avoid using the variable names 'near' and 'far' as windows #defines them out of existence.

void v3dView::setCameraClippingRange(double nearRange, double farRange)
{
    if(this->property("Orientation") != "3D")
        return;
    
    vtkCamera *camera = d->renderer3d->GetActiveCamera();
    
    camera->SetClippingRange(nearRange, farRange);
}

QString v3dView::cameraProjectionMode(void)
{
    vtkCamera *camera = NULL;
    
    if(this->property("Orientation") == "Axial")
        camera = d->renderer2d->GetActiveCamera();
    
    if(this->property("Orientation") == "Coronal")
        camera = d->renderer2d->GetActiveCamera();   
    
    if(this->property("Orientation") == "Sagittal")
        camera = d->renderer2d->GetActiveCamera();   
    
    if(this->property("Orientation") == "3D")
        camera = d->renderer3d->GetActiveCamera();   
    
    if(!camera)
        return QString("None");
    
    if(camera->GetParallelProjection())
        return QString("Parallel");
    else
        return QString("Perspective");
}

double v3dView::cameraViewAngle(void)
{
    vtkCamera *camera = NULL;
    
    if(this->property("Orientation") == "Axial")
        camera = d->renderer2d->GetActiveCamera();
    
    if(this->property("Orientation") == "Coronal")
        camera = d->renderer2d->GetActiveCamera();   
    
    if(this->property("Orientation") == "Sagittal")
        camera = d->renderer2d->GetActiveCamera();   
    
    if(this->property("Orientation") == "3D")
        camera = d->renderer3d->GetActiveCamera();   
    
    if(!camera)
        return 0.0;
    else
        return camera->GetViewAngle();
}

double v3dView::cameraZoom(void)
{
    vtkImageView *view = NULL;
    
    if(this->property("Orientation") == "Axial")
        view = d->view2d;
    
    if(this->property("Orientation") == "Coronal")
        view = d->view2d;
    
    if(this->property("Orientation") == "Sagittal")
        view = d->view2d;
    
    if(this->property("Orientation") == "3D")
        view = d->view3d;
    
    if(!view)
        return 1.0;
    else
        return view->GetZoom();
}

void v3dView::close(void)
{
    d->widget->close();
    medAbstractView::close();
}

void v3dView::onPositionChanged(const QVector3D &position)
{
    double pos[3];
    pos[0] = position.x();
    pos[1] = position.y();
    pos[2] = position.z();
    d->currentView->SetCurrentPoint(pos);
    
    // update slider, if currentView is 2D view
    if (vtkImageView2D *view2d = vtkImageView2D::SafeDownCast(d->currentView)) {
        unsigned int zslice = view2d->GetSlice();
        d->slider->blockSignals (true);
        d->slider->setValue (zslice);
        d->slider->blockSignals (false);
    }
}

void v3dView::onZoomChanged(double zoom)
{
    d->view2d->SetZoom(zoom);
}

void v3dView::onPanChanged (const QVector2D &pan)
{
    double ppan[2];
    ppan[0] = pan.x();
    ppan[1] = pan.y();
    
    d->view2d->SetPan(ppan);
}

void v3dView::onWindowingChanged (double level, double window)
{
    d->currentView->SetColorWindow(window);
    d->currentView->SetColorLevel(level);
}

void v3dView::onCameraChanged (const QVector3D &position, const QVector3D &viewup, const QVector3D &focal, double parallelScale)
{
    double pos[3], vup[3], foc[3];
    pos[0] = position.x();
    pos[1] = position.y();
    pos[2] = position.z();

    vup[0] = viewup.x();
    vup[1] = viewup.y();
    vup[2] = viewup.z();

    foc[0] = focal.x();
    foc[1] = focal.y();
    foc[2] = focal.z();
    
    d->renderer3d->GetActiveCamera()->SetPosition(pos);
    d->renderer3d->GetActiveCamera()->SetViewUp(vup);
    d->renderer3d->GetActiveCamera()->SetFocalPoint(foc);
    d->renderer3d->GetActiveCamera()->SetParallelScale(parallelScale);
    
    d->renderer3d->ResetCameraClippingRange();

    d->view3d->Modified();
}
