// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaLesionsSegmentation.h"

#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>

#include <medMetaDataKeys.h>

#include <itkImageFileWriter.h>
#include <animaNonLocalMeansImageFilter.h>
#include <animaNonLocalMeansTemporalImageFilter.h>

#include <itkCastImageFilter.h>
#include <itkImageFileWriter.h>
#include "animaSegmentationFilter.h"
#include "itkRescaleIntensityImageFilter.h"
#include "time.h"

class animaLesionsSegmentationPrivate
{
public:

    dtkSmartPointer <medAbstractImageData> output;

    dtkSmartPointer <medAbstractImageData> mask;
    dtkSmartPointer <medAbstractImageData> DP;
    dtkSmartPointer <medAbstractImageData> T2;
    dtkSmartPointer <medAbstractImageData> T1;
    dtkSmartPointer <medAbstractImageData> FLAIR;
    dtkSmartPointer <medAbstractImageData> T1Gd;

    dtkSmartPointer <medAbstractImageData> AtlasCSF;
    dtkSmartPointer <medAbstractImageData> AtlasGM;
    dtkSmartPointer <medAbstractImageData> AtlasWM;

    dtkSmartPointer <medAbstractImageData> SourcesMask;
    dtkSmartPointer <medAbstractImageData> SinksMask;


    animaLesionsSegmentation *parent;

    bool segAutoEnable;
    bool segManuEnable;
    unsigned int numberOfThreads;
    unsigned int initMethod;
    double rejRatioHierar;
    unsigned int emAlgo;
    int emIter;
    double minDistance;
    double rejRatio;
    int emIter_concentration;
    bool em_before_concentration;
    bool useStrem;
    double maha;
    double fuzzyRuleMin;
    double fuzzyRuleMax;
    QString readSolutionFile;
    QString writeSolutionFile;
    bool useT2;
    bool useDP;
    bool useFLAIR;
    bool useSpecGrad;
    int TLinkMode;
    float multiVarSources;
    float multiVarSinks;
    float sigma;
    float alpha;
    QString matrixGrad;
    float minLesionSize;
    float minGMSize;
    bool removeBorder;
    bool intensityRule;
    double intensityT2;
    double intensityDP;
    double intensityFLAIR;
    QString filenameLoad;
    float lesionLoad;
    std::vector<float> lesionLoadVector;

};

// /////////////////////////////////////////////////////////////////
// animaLesionSegmentation
// /////////////////////////////////////////////////////////////////


animaLesionsSegmentation::animaLesionsSegmentation(): dtkAbstractProcess(), d(new animaLesionsSegmentationPrivate)
{
    d->parent = this;

    d->segAutoEnable = true;
    d->segManuEnable = false;
    d->numberOfThreads = 2;
    d->initMethod = 2;
    d->rejRatioHierar = 0.01;
    d->emAlgo = 2;
    d->emIter = 100;
    d->minDistance = 0.0001;
    d->rejRatio = 0.2;
    d->emIter_concentration = 100;
    d->em_before_concentration = false;
    d->useStrem = false;
    d->maha = 0.4;
    d->fuzzyRuleMin = 2;
    d->fuzzyRuleMax = 3;
    d->useT2 = false;
    d->useDP = false;
    d->useFLAIR = false;
    d->useSpecGrad = true;
    d->TLinkMode = 0;
    d->multiVarSources = 1;
    d->multiVarSinks = 1;
    d->sigma = 0.6;
    d->alpha = 10;
    d->minLesionSize = 0;
    d->minGMSize = 0;
    d->removeBorder = false;
    d->intensityRule = false;
    d->intensityT2 = 0;
    d->intensityDP = 0;
    d->intensityFLAIR = 0;


}

animaLesionsSegmentation::~animaLesionsSegmentation(void)
{
}

bool animaLesionsSegmentation::registered()
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaLesionsSegmentation", createanimaLesionsSegmentation);
}

QString animaLesionsSegmentation::description() const
{
    return "animaLesionsSegmentation";
}


void animaLesionsSegmentation::setSegAutoEnable(bool segAutoEnable)
{
    d->segAutoEnable = segAutoEnable;
}
void animaLesionsSegmentation::setSeganuEnable(bool segManuEnable)
{
    d->segManuEnable = segManuEnable;
}
void animaLesionsSegmentation::setNumberOfThreads(unsigned int numberOfThreads)
{
    d->numberOfThreads = numberOfThreads;
}
void animaLesionsSegmentation::setInitMethod(unsigned int initMethod)
{
    d->initMethod = initMethod;
}
void animaLesionsSegmentation::setRejRatioHierar(double rejRatioHierar)
{
    d->rejRatioHierar = rejRatioHierar;
}
void animaLesionsSegmentation::setEmAlgo(unsigned int emAlgo)
{
    d->emAlgo = emAlgo;
}
void animaLesionsSegmentation::setEmIter(int emIter)
{
    d->emIter = emIter;
}
void animaLesionsSegmentation::setMinDistance(double minDistance)
{
    d->minDistance = minDistance;
}
void animaLesionsSegmentation::setRejRatio(double rejRatio)
{
    d->rejRatio = rejRatio;
}
void animaLesionsSegmentation::setEmIter_concentration(int emIter_concentration)
{
    d->emIter_concentration = emIter_concentration;
}
void animaLesionsSegmentation::setEm_before_concentration(bool em_before_concentration)
{
    d->em_before_concentration = em_before_concentration;
}
void animaLesionsSegmentation::setUseStrem(bool useStrem)
{
    d->useStrem = useStrem;
}
void animaLesionsSegmentation::setMaha(double maha)
{
    d->maha = maha;
}
void animaLesionsSegmentation::setFuzzyRuleMin(double fuzzyRuleMin)
{
    d->fuzzyRuleMin = fuzzyRuleMin;
}
void animaLesionsSegmentation::setFuzzyRuleMax(double fuzzyRuleMax)
{
    d->fuzzyRuleMax = fuzzyRuleMax;
}
void animaLesionsSegmentation::setUseT2(bool useT2)
{
    d->useT2 = useT2;
}
void animaLesionsSegmentation::setUseDP(bool useDP)
{
    d->useDP = useDP;
}
void animaLesionsSegmentation::setUseFLAIR(bool useFLAIR)
{
    d->useFLAIR = useFLAIR;
}
void animaLesionsSegmentation::setUseSpecGrad(bool useSpecGrad)
{
    d->useSpecGrad = useSpecGrad;
}
void animaLesionsSegmentation::setTLinkMode(int TLinkMode)
{
    d->TLinkMode = TLinkMode;
}
void animaLesionsSegmentation::setMultiVarSources(float multiVarSources)
{
    d->multiVarSources = multiVarSources;
}
void animaLesionsSegmentation::setMultiVarSinks(float multiVarSinks)
{
    d->multiVarSinks = multiVarSinks;
}
void animaLesionsSegmentation::setSigma(float sigma)
{
    d->sigma = sigma;
}
void animaLesionsSegmentation::setAlpha(float alpha)
{
    d->alpha = alpha;
}
void animaLesionsSegmentation::setMinLesionSize(float minLesionSize)
{
    d->minLesionSize = minLesionSize;
}
void animaLesionsSegmentation::setMinGMSize(float minGMSize)
{
    d->minGMSize = minGMSize;
}
void animaLesionsSegmentation::setRemoveBorder(bool removeBorder)
{
    d->removeBorder = removeBorder;
}
void animaLesionsSegmentation::setIntensityRule(bool intensityRule)
{
    d->intensityRule = intensityRule;
}
void animaLesionsSegmentation::setIntensityT2(double intensityT2)
{
    d->intensityT2 = intensityT2;
}
void animaLesionsSegmentation::setIntensityDP(double intensityDP)
{
    d->intensityDP = intensityDP;
}
void animaLesionsSegmentation::setIntensityFLAIR(double intensityFLAIR)
{
    d->intensityFLAIR = intensityFLAIR;
}
void animaLesionsSegmentation::setMatrixGrad(QString matrixGrad)
{
    d->matrixGrad = matrixGrad;
}
void animaLesionsSegmentation::setReadSolutionFile(QString readSolutionFile)
{
    d->readSolutionFile = readSolutionFile;
}


void animaLesionsSegmentation::setMaskInput(medAbstractData *data)
{
    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
    if (!medData)
        return;

    QString identifier = data->identifier();

    d->output = dynamic_cast <medAbstractImageData *> (medAbstractDataFactory::instance()->create (identifier));

    d->mask = medData;
}

void animaLesionsSegmentation::setT1Input(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->T1 = medData;
}
void animaLesionsSegmentation::setT2Input(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->T2 = medData;
}
void animaLesionsSegmentation::setDPInput(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->DP = medData;
}

void animaLesionsSegmentation::setFLAIRInput(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->FLAIR = medData;
}

void animaLesionsSegmentation::setT1GdInput(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->T1Gd = medData;
}

void animaLesionsSegmentation::setAtlasCSF(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->AtlasCSF = medData;
}
void animaLesionsSegmentation::setAtlasGM(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->AtlasGM = medData;
}
void animaLesionsSegmentation::setAtlasWM(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->AtlasWM = medData;
}

void animaLesionsSegmentation::setSourcesMask(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->SourcesMask = medData;
}

void animaLesionsSegmentation::setSinksMask(medAbstractData *data)
{    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);
     if (!medData)
         return;

    d->SinksMask = medData;
}


itk::Image <unsigned char,3>::Pointer animaLesionsSegmentation::createInputMasks(medAbstractImageData *medInput)
{
    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (medInput->identifier());
    unsigned int nbDimension =(*(type.end() - 1)).digitValue();
    if(nbDimension!=3)
    {
        qDebug() << "input dimension != 3";
        return NULL;
    }

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;


    // Rescale image
    itk::Image <unsigned char ,3>::Pointer inputUC = itk::Image <unsigned char ,3>::New();

    unsigned char valMinInput = std::numeric_limits<unsigned char >::min();
    unsigned char valMaxInput = std::numeric_limits<unsigned char >::max();
    std::cout << "valMinInput UC: " << valMinInput << std::endl;
    std::cout << "valMaxInput UC: " << valMaxInput << std::endl;

    type.truncate(type.size() - 1);

    if ( type == "itkDataImageChar" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageUChar" )
    {
        inputUC = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "itkDataImageShort" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageUShort" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageInt" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageUInt" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageLong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageFloat" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeF,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeF::Pointer input = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();

    }
    else if ( type == "itkDataImageDouble" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }

    return inputUC;

}

itk::Image <float,3>::Pointer animaLesionsSegmentation::createInputImages(medAbstractImageData *medInput)
{
    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (medInput->identifier());
    unsigned int nbDimension =(*(type.end() - 1)).digitValue();
    if(nbDimension!=3)
    {
        qDebug() << "input dimension != 3";
        return NULL;
    }

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;


    // Rescale image
    itk::Image <float,3>::Pointer inputF = itk::Image <float,3>::New();

    float valMinInput = std::numeric_limits<float>::min();
    float valMaxInput = std::numeric_limits<float>::max();
    std::cout << "valMinInput F: " << valMinInput << std::endl;
    std::cout << "valMaxInput F: " << valMaxInput << std::endl;

    type.truncate(type.size() - 1);

    if ( type == "itkDataImageChar" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageUChar" )
    {

        typedef itk::RescaleIntensityImageFilter<InputImageTypeUC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUC::Pointer input = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageShort" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageUShort" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageInt" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageUInt" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageLong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageFloat" )
    {
        inputF = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "itkDataImageDouble" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }

    return inputF;

}

int animaLesionsSegmentation::update()
{

    typedef itk::Image <float,3> InputImageTypeF;
    typedef InputImageTypeF::Pointer InputImagePointerF;

    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef InputImageTypeUC::Pointer InputImagePointerUC;

    // Create instance of segmentation filter
    typedef anima::SegmentationFilter<InputImageTypeF,InputImageTypeF>  FilterTypeSeg;
    FilterTypeSeg::Pointer segFilter = FilterTypeSeg::New();

    InputImagePointerF inputT1 = NULL;
    InputImagePointerF inputT2 = NULL;
    InputImagePointerF inputDP = NULL;
    InputImagePointerF inputFLAIR = NULL;
    InputImagePointerF inputT1Gd = NULL;

    InputImagePointerUC brainMask = NULL;

    InputImagePointerF inputAtlasCSF = NULL;
    InputImagePointerF inputAtlasGM = NULL;
    InputImagePointerF inputAtlasWM = NULL;

    InputImagePointerUC inputSourcesMask = NULL;
    InputImagePointerUC inputSinksMask = NULL;

    if(!(d->T1.isNull()))
    {
        inputT1 = this->createInputImages(d->T1);
        segFilter->SetInputImageT1( inputT1 );
    }
    if(!(d->T2.isNull()))
    {
        inputT2 = this->createInputImages(d->T2);
        segFilter->SetInputImageT2( inputT2 );
    }
    if(!(d->DP.isNull()))
    {
        inputDP = this->createInputImages(d->DP);
        segFilter->SetInputImageDP( inputDP );
    }
    if(!(d->FLAIR.isNull()))
    {
        inputFLAIR = this->createInputImages(d->FLAIR);
        segFilter->SetInputImageFLAIR( inputFLAIR );
    }
    if(!(d->T1Gd.isNull()))
    {
        inputT1Gd = this->createInputImages(d->T1Gd);
        segFilter->SetInputImageT1Gd( inputT1Gd );
    }
    if(!(d->mask.isNull()))
    {
        brainMask = this->createInputMasks(d->mask);
        segFilter->SetMask( brainMask );
    }

    if(!(d->AtlasCSF.isNull()))
    {
        inputAtlasCSF = this->createInputImages(d->AtlasCSF);
        segFilter->SetInputCSFAtlas( inputAtlasCSF );
    }
    if(!(d->AtlasGM.isNull()))
    {
        inputAtlasGM = this->createInputImages(d->AtlasGM);
        segFilter->SetInputGMAtlas( inputAtlasGM );
    }
    if(!(d->AtlasWM.isNull()))
    {
        inputAtlasWM = this->createInputImages(d->AtlasWM);
        segFilter->SetInputWMAtlas( inputAtlasWM );
    }

    if(!(d->SourcesMask.isNull()))
    {
        inputSourcesMask = this->createInputMasks(d->SourcesMask);
        segFilter->SetSourcesMask( inputSourcesMask );
    }
    if(!(d->SinksMask.isNull()))
    {
        inputSinksMask = this->createInputMasks(d->SinksMask);
        segFilter->SetSinksMask( inputSinksMask );
    }


    // Set parameters
    segFilter->SetSegAutoEnable( d->segAutoEnable );
    segFilter->SetSegManuEnable( d->segManuEnable );
    segFilter->SetVerbose(false);
    segFilter->SetNumberOfThreads( d->numberOfThreads );

    segFilter->SetUseT2( d->useT2 );
    segFilter->SetUseFLAIR( d->useDP );
    segFilter->SetUseDP( d->useFLAIR );

    segFilter->SetInitMethodType( d->initMethod );
    segFilter->SetRejRatioHierar( d->rejRatioHierar );

    segFilter->SetAlgoEMType( d->emAlgo );
    segFilter->SetEmIter( d->emIter );
    segFilter->SetMinDistance( d->minDistance );

    segFilter->SetRejRatio( d->rejRatio );
    segFilter->SetEmIter_concentration( d->emIter_concentration );
    segFilter->SetEM_before_concentration( d->em_before_concentration );


    segFilter->SetMahalanobisTh( d->maha );
    segFilter->SetFuzzy( !d->useStrem );
    segFilter->SetFuzzyRuleMin( d->fuzzyRuleMin );
    segFilter->SetFuzzyRuleMax( d->fuzzyRuleMax );

    segFilter->SetUseSpecGrad( d->useSpecGrad );
    //segFilter->SetTLinkMode( d->TLinkMode );
    segFilter->SetMultiVarSources( d->multiVarSources );
    segFilter->SetMultiVarSinks( d->multiVarSinks );
    segFilter->SetAlpha( d->alpha );
    segFilter->SetSigma( d->sigma );
    //segFilter->SetMatrixGradFilename( matrixGradArg.getValue() );

    segFilter->SetIntensityRule( d->intensityRule );
    segFilter->SetIntensityT2( d->intensityT2 );
    segFilter->SetIntensityDP( d->intensityDP );
    segFilter->SetIntensityFLAIR( d->intensityFLAIR );
    segFilter->SetRemoveBorder( d->removeBorder );
    segFilter->SetMinGMSize( d->minGMSize );
    segFilter->SetMinLesionSize( d->minLesionSize );

    std::string readSolutionFile = "/home/lcatanes/trash/writeSolution";
    segFilter->SetSolutionReadFilename( readSolutionFile );

    //segFilter->SetSolutionReadFilename( readSolutionFileArg.getValue() );
    //segFilter->SetSolutionWriteFilename( writeSolutionFileArg.getValue() );


    // Run the segmentation
    time_t t1 = clock();
    try
    {
        segFilter->Update();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (Update Segmentation)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;

    d->lesionLoad = segFilter->GetLesionLoad();
    d->lesionLoadVector = segFilter->GetLesionLoadVector();

    //d->output->setData(segFilter->GetOutputWholeSeg());
    //d->output->setData(brainMask);

    return(0);
}

medAbstractData * animaLesionsSegmentation::output()
{
    return d->output;
}

/*void animaLesionsSegmentation::emitProgressed(int progression)
{
    emit progressed(progression);
}*/

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaLesionsSegmentation(void)
{
    return new animaLesionsSegmentation;
}


