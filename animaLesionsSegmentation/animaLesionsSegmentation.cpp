// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaLesionsSegmentation.h"
#include "animaLesionsSegmentationToolBox.h"

#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>

#include <medMetaDataKeys.h>

#include <itkImageFileWriter.h>
#include <animaNonLocalMeansImageFilter.h>
#include <animaNonLocalMeansTemporalImageFilter.h>
#include <medViewContainer.h>

#include <itkCastImageFilter.h>
#include <itkImageFileWriter.h>
#include "animaSegmentationFilter.h"
#include "itkRescaleIntensityImageFilter.h"
#include "animaFiniteModel.h"
#include "time.h"

#include <medBoolParameter.h>
#include <medBoolGroupParameter.h>
#include <medTriggerParameter.h>
#include <medDoubleParameter.h>
#include <medStringListParameter.h>
#include <medIntParameter.h>
#include <medDataIndexParameter.h>

#include <medToolBoxFactory.h>
#include <medSegmentationSelectorToolBox.h>
#include <medProgressionStack.h>
#include <medPluginManager.h>
#include <medToolBoxTab.h>
#include <medDropSite.h>
#include <medDataIndex.h>
#include <medDataManager.h>



class animaLesionsSegmentationPrivate
{
public:

    animaLesionsSegmentationToolBox *toolbox;

    dtkSmartPointer <medAbstractImageData> output;

    dtkSmartPointer <medAbstractImageData> mask;
    dtkSmartPointer <medAbstractImageData> DP;
    dtkSmartPointer <medAbstractImageData> T2;
    dtkSmartPointer <medAbstractImageData> T1;
    dtkSmartPointer <medAbstractImageData> FLAIR;
    dtkSmartPointer <medAbstractImageData> T1Gd;

    dtkSmartPointer <medAbstractImageData> AtlasCSF;
    dtkSmartPointer <medAbstractImageData> AtlasGM;
    dtkSmartPointer <medAbstractImageData> AtlasWM;

    dtkSmartPointer <medAbstractImageData> SourcesMask;
    dtkSmartPointer <medAbstractImageData> SinksMask;

    medAbstractData* maskData;


    animaLesionsSegmentation *parent;

    bool segAutoEnable;
    bool segManuEnable;
    unsigned int numberOfThreads;
    unsigned int initMethod;
    double rejRatioHierar;
    unsigned int emAlgo;
    int emIter;
    double minDistance;
    double rejRatio;
    int emIter_concentration;
    bool em_before_concentration;
    bool useStrem;
    double maha;
    double fuzzyRuleMin;
    double fuzzyRuleMax;
    QString readSolutionFile;
    QString writeSolutionFile;
    bool useT2;
    bool useDP;
    bool useFLAIR;
    bool useSpecGrad;
    int TLinkMode;
    float multiVarSources;
    float multiVarSinks;
    float sigma;
    float alpha;
    QString matrixGrad;
    float minLesionSize;
    float minGMSize;
    bool removeBorder;
    bool intensityRule;
    double intensityT2;
    double intensityDP;
    double intensityFLAIR;
    QString filenameLoad;
    float lesionLoad;
    std::vector<float> lesionLoadVector;

    anima::FiniteModel FiniteModelSolution;
    bool useFormerSegModel;

    medDataIndexParameter *T1Parameter;
    medDataIndexParameter *T2Parameter;
    medDataIndexParameter *DPParameter;
    medDataIndexParameter *FLAIRParameter;
    medDataIndexParameter *T1GdParameter;
    medDataIndexParameter *MaskParameter;

    QList <medAbstractParameter*> parameters;
    QPointer<QWidget> parameterWidget;

};

// /////////////////////////////////////////////////////////////////
// animaLesionSegmentation
// /////////////////////////////////////////////////////////////////


animaLesionsSegmentation::animaLesionsSegmentation(): medAbstractSegmentationProcess(), d(new animaLesionsSegmentationPrivate)
{
    d->parent = this;

    d->segAutoEnable = true;
    d->segManuEnable = false;
    d->numberOfThreads = 8;
    d->initMethod = 1;
    d->rejRatioHierar = 0.01;
    d->emAlgo = 2;
    d->emIter = 100;
    d->minDistance = 0.0001;
    d->rejRatio = 0.2;
    d->emIter_concentration = 100;
    d->em_before_concentration = false;
    d->useStrem = false;
    d->maha = 0.4;
    d->fuzzyRuleMin = 2;
    d->fuzzyRuleMax = 3;
    d->useT2 = true;
    d->useDP = true;
    d->useFLAIR = false;
    d->useSpecGrad = true;
    d->TLinkMode = 0;
    d->multiVarSources = 1;
    d->multiVarSinks = 1;
    d->sigma = 0.6;
    d->alpha = 10;
    d->minLesionSize = 0;
    d->minGMSize = 0;
    d->removeBorder = false;
    d->intensityRule = false;
    d->intensityT2 = 0;
    d->intensityDP = 0;
    d->intensityFLAIR = 0;
    d->useFormerSegModel = false;

    /*d->T1Parameter = new medDataIndexParameter("T1", this);
    d->T1Parameter->setToolTip(tr("Drag-and-drop A T1 from the database or click here."));
    d->T1Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1."));

    d->T2Parameter = new medDataIndexParameter("T2", this);
    d->T2Parameter->setToolTip(tr("Drag-and-drop A T2 from the database or click here."));
    d->T2Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T2."));

    d->DPParameter = new medDataIndexParameter("DP", this);
    d->DPParameter->setToolTip(tr("Drag-and-drop A DP from the database or click here."));
    d->DPParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a DP."));

    d->FLAIRParameter = new medDataIndexParameter("FLAIR", this);
    d->FLAIRParameter->setToolTip(tr("Drag-and-drop A FLAIR from the database or click here."));
    d->FLAIRParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a FLAIR."));

    d->T1GdParameter = new medDataIndexParameter("T1Gd", this);
    d->T1GdParameter->setToolTip(tr("Drag-and-drop A T1Gd from the database or click here."));
    d->T1GdParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1Gd."));

    d->MaskParameter = new medDataIndexParameter("Mask", this);
    d->MaskParameter->setToolTip(tr("Drag-and-drop A Mask from the database or click here."));
    d->MaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a Mask."));*/

    /*d->parameters << d->T1Parameter;
    d->parameters << d->T2Parameter;
    d->parameters << d->DPParameter;
    d->parameters << d->MaskParameter;*/

    /*medInputDataPort *input = new medInputDataPort("Image MRI", false);
    if(input)
    {
        medInputDataPort *data = dynamic_cast<medInputDataPort*> (input);
        medViewContainer* cont2 = this->container(data);
        cont2->setMultiLayered(true);
        cont2->splitVertically();
    }*/

    /*medInputDataPort *input = new medInputDataPort("Image DP", false);
    input->setInput(NULL);

    this->appendInput(input);

    medInputDataPort *input2 = new medInputDataPort("Image T2", false);
    input2->setInput(NULL);

    this->appendInput(input2);


    medInputDataPort *input3 = new medInputDataPort("Mask", false);
    input3->setInput(NULL);

    this->appendInput(input3);

    connect(d->MaskParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onMaskDropped(const medDataIndex &)));*/

}

void animaLesionsSegmentation::onMaskDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->maskData = medDataManager::instance()->retrieveData(index);
}

// permettre le multilayer sur les containers
/*medViewContainerSplitter* animaLesionsSegmentation::viewContainerSplitter()
{
    medViewContainerSplitter* split = medAbstractProcess::viewContainerSplitter();

    typedef medProcessInput<medAbstractData> medInputDataPort;
    medProcessIOPort *inputPort = this->inputs()[0];
    if(inputPort)
    {
        medInputDataPort *dataPort = dynamic_cast<medInputDataPort*> (inputPort);
        medViewContainer* cont = this->container(dataPort);
        cont->setMultiLayered(true);
    }


   // medViewContainer *container = inputContainer->splitHorizontally();
    //input->setInput(NULL);

    //this->appendInput(input);


    return split;
}*/

animaLesionsSegmentation::~animaLesionsSegmentation(void)
{
    /*delete d->toolbox;
    d->toolbox = NULL;
    delete d;*/
}





QWidget* animaLesionsSegmentation::parameterWidget()
{
    if(d->parameterWidget.isNull())
    {
        d->parameterWidget = new QWidget;
        //QFormLayout *layout = new QFormLayout(d->parameterWidget);

        QHBoxLayout *layoutH = new QHBoxLayout(d->parameterWidget);
        //layoutH->addWidget(d->T1Parameter->getWidget());
        //layoutH->addWidget(d->T2Parameter->getWidget());

        //this->setTitle("Lesion Segmentation");
        medToolBoxTab *widget = new medToolBoxTab(d->parameterWidget);



        // Set Tabs
        /*QWidget *header = new QWidget;
        QVBoxLayout *layoutheader = new QVBoxLayout(header);
        layoutheader->addWidget(runButton);
        layoutheader->addWidget(d->SaveLesionLoadButton);
        layoutheader->addWidget(d->progression_stack);*/

        d->T1Parameter = new medDataIndexParameter("T1", this);
        d->T1Parameter->setToolTip(tr("Drag-and-drop A T1 from the database or click here."));
        d->T1Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1."));

        d->T2Parameter = new medDataIndexParameter("T2", this);
        d->T2Parameter->setToolTip(tr("Drag-and-drop A T2 from the database or click here."));
        d->T2Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T2."));

        d->DPParameter = new medDataIndexParameter("DP", this);
        d->DPParameter->setToolTip(tr("Drag-and-drop A DP from the database or click here."));
        d->DPParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a DP."));

        d->FLAIRParameter = new medDataIndexParameter("FLAIR", this);
        d->FLAIRParameter->setToolTip(tr("Drag-and-drop A FLAIR from the database or click here."));
        d->FLAIRParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a FLAIR."));

        d->T1GdParameter = new medDataIndexParameter("T1Gd", this);
        d->T1GdParameter->setToolTip(tr("Drag-and-drop A T1Gd from the database or click here."));
        d->T1GdParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1Gd."));

        d->MaskParameter = new medDataIndexParameter("Mask", this);
        d->MaskParameter->setToolTip(tr("Drag-and-drop A Mask from the database or click here."));
        d->MaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a Mask."));

        QHBoxLayout *MRIBox1Layout = new QHBoxLayout();
        MRIBox1Layout->addWidget(d->T1Parameter->getWidget(), 0, Qt::AlignCenter);
        MRIBox1Layout->addWidget(d->T2Parameter->getWidget(), 0, Qt::AlignCenter);

        QHBoxLayout *MRIBox2Layout = new QHBoxLayout();
        MRIBox2Layout->addWidget(d->DPParameter->getWidget(), 0, Qt::AlignCenter);
        MRIBox2Layout->addWidget(d->FLAIRParameter->getWidget(), 0, Qt::AlignCenter);

        QHBoxLayout *MRIBox3Layout = new QHBoxLayout();
        MRIBox3Layout->addWidget(d->T1GdParameter->getWidget(), 0, Qt::AlignCenter);
        MRIBox3Layout->addWidget(d->MaskParameter->getWidget(), 0, Qt::AlignCenter);

        QPushButton *clearImagesButton = new QPushButton(tr("Remove whole images"));

        QVBoxLayout *box1Layout = new QVBoxLayout();
        box1Layout->addLayout(MRIBox1Layout);
        box1Layout->addLayout(MRIBox2Layout);
        box1Layout->addLayout(MRIBox3Layout);
        box1Layout->addWidget(clearImagesButton);

        QGroupBox *ImagesGroupBox = new QGroupBox(tr("Select MRI Images"));
        ImagesGroupBox->setLayout(box1Layout);

        QWidget *page1 = new QWidget;
        QVBoxLayout *layout1 = new QVBoxLayout(page1);
        layout1->addWidget(ImagesGroupBox);
        /*layout1->addWidget(heuristicGroupBox);
        layout1->addWidget(OutputTypeGroupBox);*/

        QWidget *page2 = new QWidget;
        /*QVBoxLayout *layout2 = new QVBoxLayout(page2);
        layout2->addWidget(AutoGroupBox);
        layout2->addWidget(d->NABTGroupBox);
        layout2->addWidget(d->DetectionGroupBox);
        //layout2->addWidget(d->SeedsGroupBox);
        layout2->addWidget(d->gcGroupBox);
        layout2->addWidget(d->globalParametersGroupBox);*/

        widget->addTab(page1, "Main");
        widget->addTab(page2, "Segmentation Parameters");

        layoutH->addWidget(widget);

        //this->addWidget( header );
        //d->parameterWidget->addWidget( widget );
    }
    return d->parameterWidget;
}

bool animaLesionsSegmentation::registered()
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaLesionsSegmentation", createanimaLesionsSegmentation, "SemiAutomaticSeg");
}

QString animaLesionsSegmentation::description() const
{
    return "animaLesionsSegmentation";
}



/// TODO mettre la liste des parameters et au lieu de surcharger la method toolbox() (run button...)
QList<medAbstractParameter*> animaLesionsSegmentation::parameters()
{
    //return QList<medAbstractParameter*>();
    return d->parameters;
}

bool animaLesionsSegmentation::isInteractive()
{
    return false;
}

/*medToolBox* animaLesionsSegmentation::toolbox()
{
    d->toolbox = new animaLesionsSegmentationToolBox;
    connect(d->toolbox, SIGNAL(runRequest()), this, SLOT(run()));
    return d->toolbox;
}*/

void animaLesionsSegmentation::run()
{
    medRunnableProcess *runable = new medRunnableProcess(this, this->name());
    runable->start();
}

int animaLesionsSegmentation::update()
{

    qDebug() << "in process update";
    //set manual masks: from database + segmented from paint segmentation
    //todo: AND





    typedef itk::Image <float,3> InputImageTypeF;
    typedef InputImageTypeF::Pointer InputImagePointerF;

    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef InputImageTypeUC::Pointer InputImagePointerUC;

    // Create instance of segmentation filter
    typedef anima::SegmentationFilter<InputImageTypeF,InputImageTypeF>  FilterTypeSeg;
    FilterTypeSeg::Pointer segFilter = FilterTypeSeg::New();

    InputImagePointerF inputT1 = NULL;
    InputImagePointerF inputT2 = NULL;
    InputImagePointerF inputDP = NULL;
    InputImagePointerF inputFLAIR = NULL;
    InputImagePointerF inputT1Gd = NULL;

    InputImagePointerUC brainMask = NULL;

    InputImagePointerF inputAtlasCSF = NULL;
    InputImagePointerF inputAtlasGM = NULL;
    InputImagePointerF inputAtlasWM = NULL;

    InputImagePointerUC inputSourcesMask = NULL;
    InputImagePointerUC inputSinksMask = NULL;


    d->T1 = dynamic_cast <medAbstractImageData *> (d->parent->input<medAbstractData>(0));
    d->T2 = dynamic_cast <medAbstractImageData *> (d->parent->input<medAbstractData>(2));
    d->DP = dynamic_cast <medAbstractImageData *> (d->parent->input<medAbstractData>(1));
    d->mask = dynamic_cast <medAbstractImageData *> (d->parent->input<medAbstractData>(3));
    //d->T1 = dynamic_cast <medAbstractImageData *> (d->toolbox->getT1());
    //d->T2 = dynamic_cast <medAbstractImageData *> (d->toolbox->getT2());
    //d->DP = dynamic_cast <medAbstractImageData *> (d->toolbox->getDP());

    /*d->FLAIR = dynamic_cast <medAbstractImageData *> (d->toolbox->getFLAIR());
    d->T1Gd = dynamic_cast <medAbstractImageData *> (d->toolbox->getT1Gd());*/
    //d->mask = dynamic_cast <medAbstractImageData *> (d->maskData);


    if(!(d->T1.isNull()))
    {
        inputT1 = this->createInputImages(d->T1);
        segFilter->SetInputImageT1( inputT1 );
        qDebug()<<"T1 set";
    }
    if(!(d->T2.isNull()))
    {
        inputT2 = this->createInputImages(d->T2);
        segFilter->SetInputImageT2( inputT2 );
        qDebug()<<"t2 set";
    }
    if(!(d->DP.isNull()))
    {
        inputDP = this->createInputImages(d->DP);
        segFilter->SetInputImageDP( inputDP );
        qDebug()<<"dp set";
    }
    if(!(d->FLAIR.isNull()))
    {
        inputFLAIR = this->createInputImages(d->FLAIR);
        segFilter->SetInputImageFLAIR( inputFLAIR );
    }
    if(!(d->T1Gd.isNull()))
    {
        inputT1Gd = this->createInputImages(d->T1Gd);
        segFilter->SetInputImageT1Gd( inputT1Gd );
    }
    if(!(d->mask.isNull()))
    {
        //brainMask = this->createInputMasks(d->mask);
        brainMask = this->createInputMasks(d->mask);
        segFilter->SetMask( brainMask );
        qDebug()<<"mask set";
    }

    if(!(d->AtlasCSF.isNull()))
    {
        inputAtlasCSF = this->createInputImages(d->AtlasCSF);
        segFilter->SetInputCSFAtlas( inputAtlasCSF );
    }
    if(!(d->AtlasGM.isNull()))
    {
        inputAtlasGM = this->createInputImages(d->AtlasGM);
        segFilter->SetInputGMAtlas( inputAtlasGM );
    }
    if(!(d->AtlasWM.isNull()))
    {
        inputAtlasWM = this->createInputImages(d->AtlasWM);
        segFilter->SetInputWMAtlas( inputAtlasWM );
    }

    if(!(d->SourcesMask.isNull()))
    {
        inputSourcesMask = this->createInputMasks(d->SourcesMask);
        segFilter->SetSourcesMask( inputSourcesMask );
    }
    if(!(d->SinksMask.isNull()))
    {
        inputSinksMask = this->createInputMasks(d->SinksMask);
        segFilter->SetSinksMask( inputSinksMask );
    }



    medAbstractData *in = medAbstractDataFactory::instance()->create("medItkFloat3ImageData");
    //in->setData ( inputT1 );
    //QString newSeriesDescription = d->toolbox->getMask()->metadata ( medMetaDataKeys::SeriesDescription.key() );
    //QString newSeriesDescription = d->parent->input<medAbstractData>(0)->metadata ( medMetaDataKeys::SeriesDescription.key() );
    //output->addMetaData ( medMetaDataKeys::SeriesDescription.key(), newSeriesDescription );
    d->parent->setOutput<medAbstractData>(d->T1, 0);

    //return (0);

    /*d->segAutoEnable = d->toolbox->getEnableAuto();
    d->segManuEnable = d->toolbox->getEnableManu();
    d->numberOfThreads = d->toolbox->getNumberOfThreads();
    d->initMethod = d->toolbox->getInitMethod();
    //d->rejRatioHierar = d->toolbox->getRejRatioHierar();
    d->emAlgo = d->toolbox->getEmAlgo();
    d->emIter = d->toolbox->getEmIter();
    d->minDistance = d->toolbox->getMinDistance();
    d->rejRatio = d->toolbox->getRejRatio();
    d->emIter_concentration = d->toolbox->getEmIter_concentration();
    d->em_before_concentration = d->toolbox->getEm_before_concentration();*/
    /*d->useStrem = d->toolbox->getUseStrem();
    d->maha = d->toolbox->getMaha();
    d->fuzzyRuleMin = d->toolbox->getFuzzyRuleMin();
    d->fuzzyRuleMax = d->toolbox->getFuzzyRuleMax();
    //void getUseT2();
    //void getUseDP();
    //void getUseFLAIR();
    d->useSpecGrad = d->toolbox->getUseSpecGrad();
    // = d->toolbox->getTLinkMode(int TLinkMode);
    d->multiVarSources = d->toolbox->getMultiVarSources();
    d->multiVarSinks = d->toolbox->getMultiVarSinks();
    d->sigma = d->toolbox->getSigma();
    d->alpha = d->toolbox->getAlpha();
    d->minLesionSize = d->toolbox->getMinLesionSize();
    d->minGMSize = d->toolbox->getMinGMSize();
    d->removeBorder = d->toolbox->getRemoveBorder();
    d->intensityRule  = d->toolbox->getIntensityRule();
    d->intensityT2 = d->toolbox->getIntensityT2();
    d->intensityDP = d->toolbox->getIntensityDP();
    d->intensityFLAIR = d->toolbox->getIntensityFLAIR();
    d->useFormerSegModel = d->toolbox->getUseFormerSegModel();*/

    // Set parameters
    segFilter->SetSegAutoEnable( d->segAutoEnable );
    segFilter->SetSegManuEnable( d->segManuEnable );
    segFilter->SetVerbose(true);
    segFilter->SetNumberOfThreads( d->numberOfThreads );

    segFilter->SetUseT2( d->useT2 );
    segFilter->SetUseDP( d->useDP );
    segFilter->SetUseFLAIR( d->useFLAIR );

    segFilter->SetInitMethodType( d->initMethod );
    segFilter->SetRejRatioHierar( d->rejRatioHierar );

    segFilter->SetAlgoEMType( d->emAlgo );
    segFilter->SetEmIter( d->emIter );
    segFilter->SetMinDistance( d->minDistance );

    segFilter->SetRejRatio( d->rejRatio );
    segFilter->SetEmIter_concentration( d->emIter_concentration );
    segFilter->SetEM_before_concentration( d->em_before_concentration );


    segFilter->SetMahalanobisTh( d->maha );
    segFilter->SetFuzzy( !d->useStrem );
    segFilter->SetFuzzyRuleMin( d->fuzzyRuleMin );
    segFilter->SetFuzzyRuleMax( d->fuzzyRuleMax );

    segFilter->SetUseSpecGrad( d->useSpecGrad );
    //segFilter->SetTLinkMode( d->TLinkMode );
    segFilter->SetMultiVarSources( d->multiVarSources );
    segFilter->SetMultiVarSinks( d->multiVarSinks );
    segFilter->SetAlpha( d->alpha );
    segFilter->SetSigma( d->sigma );
    //segFilter->SetMatrixGradFilename( matrixGradArg.getValue() );

    segFilter->SetIntensityRule( d->intensityRule );
    segFilter->SetIntensityT2( d->intensityT2 );
    segFilter->SetIntensityDP( d->intensityDP );
    segFilter->SetIntensityFLAIR( d->intensityFLAIR );
    segFilter->SetRemoveBorder( d->removeBorder );
    segFilter->SetMinGMSize( d->minGMSize );
    segFilter->SetMinLesionSize( d->minLesionSize );

    if(d->FiniteModelSolution.size()==3 && d->useFormerSegModel)
    {
        segFilter->SetSolution(d->FiniteModelSolution);
    }

    /*std::string outputGCFile="/home/lcatanes/outGC.nii";
     segFilter->SetOutputGCFilename(outputGCFile);

     std::string outputSourcesFile="/home/lcatanes/outSources.nii";
     segFilter->SetOutputSourcesFilename(outputSourcesFile);

      std::string outputFile="/home/lcatanes/outlesions.nii";
      segFilter-> SetOutputLesionFilename(outputFile);*/

    // Run the segmentation
    time_t t1 = clock();
    try
    {
        segFilter->Update();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (Update Segmentation)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;

    // save solution of automatic segmenation in case we need to relaunch the seg with additional seed
    // FiniteModelSolution cointains the estimation of the NABT model (mean and covar matrix)
    // this allow to save computation time (EM is not performed) and avoid diiferences due to random intialisation
    d->FiniteModelSolution = segFilter->GetSolution();

    // save number lesion load to print it
    d->lesionLoad = segFilter->GetLesionLoad();
    d->lesionLoadVector = segFilter->GetLesionLoadVector();


    medAbstractData *output = medAbstractDataFactory::instance()->create("medItkFloat3ImageData");
    output->setData ( segFilter->GetOutputWholeSeg() );
    //QString newSeriesDescription = d->toolbox->getMask()->metadata ( medMetaDataKeys::SeriesDescription.key() );
    QString newSeriesDescription = d->parent->input<medAbstractData>(0)->metadata ( medMetaDataKeys::SeriesDescription.key() );
    output->addMetaData ( medMetaDataKeys::SeriesDescription.key(), newSeriesDescription );
    d->parent->setOutput<medAbstractData>(output, 0);




     /*medAbstractData *in = medAbstractDataFactory::instance()->create("medItkFloat3ImageData");
     in->setData ( segFilter->GetOutputWholeSeg() );
     QString newSeriesDescription = d->toolbox->getMask()->metadata ( medMetaDataKeys::SeriesDescription.key() );
     QString newSeriesDescription = d->parent->input<medAbstractData>(0)->metadata ( medMetaDataKeys::SeriesDescription.key() );
     output->addMetaData ( medMetaDataKeys::SeriesDescription.key(), newSeriesDescription );
     d->parent->setInput<medAbstractData>(d->maskData, 0);*/


    return(0);
}

/*medAbstractData * animaLesionsSegmentation::output()
{
    return d->output;
}*/

/*void animaLesionsSegmentation::emitProgressed(int progression)
{
    emit progressed(progression);
}*/

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaLesionsSegmentation(void)
{
    return new animaLesionsSegmentation;
}

itk::Image <unsigned char,3>::Pointer animaLesionsSegmentation::createInputMasks(medAbstractImageData *medInput)
{
    QString type = QString (medInput->identifier());

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;

    // Rescale image
    itk::Image <unsigned char ,3>::Pointer inputUC = itk::Image <unsigned char ,3>::New();

    unsigned char valMinInput = std::numeric_limits<unsigned char >::min();
    unsigned char valMaxInput = std::numeric_limits<unsigned char >::max();

    if ( type == "medItkChar3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUChar3ImageData" )
    {
        inputUC = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "medItkShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageLong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkFloat3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeF,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeF::Pointer input = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();

    }
    else if ( type == "medItkDouble3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else
    {
        qDebug() << "invalid data";
        return NULL;
    }

    return inputUC;
}

itk::Image <float,3>::Pointer animaLesionsSegmentation::createInputImages(medAbstractImageData *medInput)
{
    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (medInput->identifier());

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;


    // Rescale image
    itk::Image <float,3>::Pointer inputF = itk::Image <float,3>::New();

    float valMinInput = std::numeric_limits<float>::min();
    float valMaxInput = std::numeric_limits<float>::max();

    if ( type == "medItkChar3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUChar3ImageData" )
    {

        typedef itk::RescaleIntensityImageFilter<InputImageTypeUC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUC::Pointer input = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkFloat3ImageData" )
    {
        inputF = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "medItkDouble3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else
    {
        qDebug() << "invalid data";
        return NULL;
    }

    return inputF;

}

