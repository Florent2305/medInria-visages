// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include <QMessageBox>
#include "time.h"

#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkAbstractProcessFactory.h>

#include <medBoolParameter.h>
#include <medBoolGroupParameter.h>
#include <medTriggerParameter.h>
#include <medDoubleParameter.h>
#include <medStringListParameter.h>
#include <medIntParameter.h>
#include <medDataIndexParameter.h>
#include <medCompositeParameter.h>
#include <medStringParameter.h>

#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>
#include <medMetaDataKeys.h>
#include <medViewContainer.h>
#include <medToolBoxFactory.h>
#include <medSegmentationSelectorToolBox.h>
#include <medProgressionStack.h>
#include <medToolBoxTab.h>
#include <medDropSite.h>
#include <medDataIndex.h>
#include <medDataManager.h>
#include <medPluginManager.h>
#include <medAbstractView.h>
#include <medAbstractImageView.h>
#include <medViewContainerSplitter.h>

#include <itkRescaleIntensityImageFilter.h>
#include <itkBinaryThresholdImageFilter.h>
#include <itkMaximumImageFilter.h>

#include "animaLesionsSegmentation.h"
#include "animaSegmentationFilter.h"
#include "animaFiniteModel.h"
#include <medImageMaskAnnotationData.h>


class animaLesionsSegmentationPrivate
{
public:

    animaLesionsSegmentation *parent;

    medViewContainer* containerImage1;
    medViewContainer* containerImage2;
    medViewContainer* containerImage3;

    QList <medAbstractParameter*> parameters;
    QPointer<QWidget> parameterWidget;

    dtkSmartPointer <medAbstractImageData> maskImageData;
    dtkSmartPointer <medAbstractImageData> DPImageData;
    dtkSmartPointer <medAbstractImageData> T2ImageData;
    dtkSmartPointer <medAbstractImageData> T1ImageData;
    dtkSmartPointer <medAbstractImageData> FLAIRImageData;
    dtkSmartPointer <medAbstractImageData> T1GdImageData;

    dtkSmartPointer <medAbstractImageData> AtlasCSF;
    dtkSmartPointer <medAbstractImageData> AtlasGM;
    dtkSmartPointer <medAbstractImageData> AtlasWM;

    dtkSmartPointer <medAbstractImageData> ManuSegMask;
    dtkSmartPointer <medAbstractImageData> ExternalMask;

    dtkSmartPointer <medAbstractData> maskData;
    dtkSmartPointer <medAbstractData> DPData;
    dtkSmartPointer <medAbstractData> T2Data;
    dtkSmartPointer <medAbstractData> T1Data;
    dtkSmartPointer <medAbstractData> FLAIRData;
    dtkSmartPointer <medAbstractData> T1GdData;

    dtkSmartPointer <medAbstractData> ManuSegMaskData;
    dtkSmartPointer <medAbstractData> ExternalMaskData;

    dtkSmartPointer <medAbstractData> outputLesions;
    dtkSmartPointer <medAbstractData> outputCSF;
    dtkSmartPointer <medAbstractData> outputGM;
    dtkSmartPointer <medAbstractData> outputWM;

    dtkSmartPointer <medImageMaskAnnotationData> outputCSFAnnot;

    QString filenameLoad;
    float lesionLoad;
    std::vector<float> lesionLoadVector;
    anima::FiniteModel FiniteModelSolution;

    medDataIndexParameter *T1Parameter;
    medDataIndexParameter *T2Parameter;
    medDataIndexParameter *DPParameter;
    medDataIndexParameter *FLAIRParameter;
    medDataIndexParameter *T1GdParameter;
    medDataIndexParameter *MaskParameter;

    medDataIndexParameter *AtlasCSFParameter;
    medDataIndexParameter *AtlasGMParameter;
    medDataIndexParameter *AtlasWMParameter;

    medDataIndexParameter *ManuSegMaskParameter;
    medDataIndexParameter *ExternalMaskParameter;

    medBoolParameter *chooseT1;
    medBoolParameter *chooseT2;
    medBoolParameter *chooseDP;
    medBoolParameter *chooseFLAIR;
    medBoolParameter *chooseT1Gd;

    medBoolParameter *removeBorderLesions;
    medDoubleParameter *wmRatio;
    medDoubleParameter *minLesionsSize;
    medDoubleParameter *minGMSize;
    medBoolParameter *useIntensityRule;
    medDoubleParameter *T2intensityFactor;
    medDoubleParameter *DPintensityFactor;
    medDoubleParameter *FLAIRintensityFactor;

    medBoolParameter *enableAuto;
    medBoolParameter *enableManu;
    medBoolParameter *useFormerSegModel;

    medStringListParameter *algoEM;
    medStringListParameter *init;

    medIntParameter *emIter;
    medDoubleParameter *minDistance;
    medDoubleParameter *rejRatio;
    medIntParameter *emIterConcentration;
    medBoolParameter *emBeforeConcentration;

    medBoolGroupParameter *detectionButtonGroup;
    medBoolParameter *strem;
    medDoubleParameter *mahaDist;
    medBoolParameter *fuzzy;
    medDoubleParameter *fuzzyMin;
    medDoubleParameter *fuzzyMax;

    medDoubleParameter *multiVarSources;
    medDoubleParameter *multiVarSinks;
    medDoubleParameter *alpha;
    medDoubleParameter *sigma;
    medBoolParameter *useSpectralGrad;
    medIntParameter *NbItGc;

    medIntParameter *threads;
    //medProgressionStack * progression_stack;

    QGroupBox *ImagesGroupBox;
    QGroupBox *ChooseSeqGroupBox;
    QGroupBox *heuristicGroupBox;

    QGroupBox *AutoGroupBox;
    QGroupBox *NABTGroupBox;
    QGroupBox *DetectionGroupBox;
    QGroupBox *gcGroupBox;
    QGroupBox *globalParametersGroupBox;

    QWidget *page1;
    QWidget *page2;
    medToolBoxTab *widgetTab;

    bool T1isSet,T2isSet,DPisSet,FLAIRisSet,T1GdisSet,MaskisSet,ManuSegMaskisSet,ExternalMaskisSet;
    bool cont1isFree, cont2isFree, cont3isFree;
    int posT1, posT2, posDP, posFLAIR, posT1Gd;
    QString cont1mod, cont2mod, cont3mod;
    int nb_seq, nb_seq_checked;
    int tour;

    itk::Image<unsigned char,3> *LesionsSeg;

    ~animaLesionsSegmentationPrivate()
    {
        delete ImagesGroupBox;
        delete ChooseSeqGroupBox;
        delete heuristicGroupBox;
        delete AutoGroupBox;
        delete NABTGroupBox;
        delete DetectionGroupBox;
        delete gcGroupBox;
        delete globalParametersGroupBox;
        delete page1;
        delete page2;
        delete widgetTab;
    }

};

// /////////////////////////////////////////////////////////////////
// animaLesionSegmentation
// /////////////////////////////////////////////////////////////////
animaLesionsSegmentation::animaLesionsSegmentation(): medAbstractSegmentationProcess(), d(new animaLesionsSegmentationPrivate)
{
    d->parent = this;

    d->LesionsSeg = NULL;

    d->T1isSet=false;
    d->T2isSet=false;
    d->DPisSet=false;
    d->FLAIRisSet=false;
    d->T1GdisSet=false;
    d->MaskisSet=false;
    d->ManuSegMaskisSet=false;
    d->ExternalMaskisSet=false;

    d->cont1isFree=true;
    d->cont2isFree=true;
    d->cont3isFree=true;

    d->posT1=0, d->posT2=0, d->posDP=0, d->posFLAIR=0, d->posT1Gd=0;

    d->tour=0;
    d->nb_seq=0;
    d->nb_seq_checked=3;

    d->outputLesions = medAbstractDataFactory::instance()->create("medItkUChar3ImageData");
    d->outputCSF = medAbstractDataFactory::instance()->create("medItkUChar3ImageData");
    d->outputGM = medAbstractDataFactory::instance()->create("medItkUChar3ImageData");
    d->outputWM = medAbstractDataFactory::instance()->create("medItkUChar3ImageData");


    /* ---------------------------------------------- Main Page ---------------------------------------------- */

    d->T1Parameter = new medDataIndexParameter("T1", this);
    d->T1Parameter->setToolTip(tr("Drag-and-drop A T1 from the database or click here."));
    d->T1Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1."));

    d->T2Parameter = new medDataIndexParameter("T2", this);
    d->T2Parameter->setToolTip(tr("Drag-and-drop A T2 from the database or click here."));
    d->T2Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T2."));

    d->DPParameter = new medDataIndexParameter("DP", this);
    d->DPParameter->setToolTip(tr("Drag-and-drop A DP from the database or click here."));
    d->DPParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a DP."));

    d->FLAIRParameter = new medDataIndexParameter("FLAIR", this);
    d->FLAIRParameter->setToolTip(tr("Drag-and-drop A FLAIR from the database or click here."));
    d->FLAIRParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a FLAIR."));

    d->T1GdParameter = new medDataIndexParameter("T1Gd", this);
    d->T1GdParameter->setToolTip(tr("Drag-and-drop A T1Gd from the database or click here."));
    d->T1GdParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1Gd."));

    d->MaskParameter = new medDataIndexParameter("Mask", this);
    d->MaskParameter->setToolTip(tr("Drag-and-drop A Mask from the database or click here."));
    d->MaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a Mask."));

    QHBoxLayout *MRIBox1Layout = new QHBoxLayout();
    MRIBox1Layout->addWidget(d->T1Parameter->getWidget(), 0, Qt::AlignCenter);
    MRIBox1Layout->addWidget(d->T2Parameter->getWidget(), 0, Qt::AlignCenter);

    QHBoxLayout *MRIBox2Layout = new QHBoxLayout();
    MRIBox2Layout->addWidget(d->DPParameter->getWidget(), 0, Qt::AlignCenter);
    MRIBox2Layout->addWidget(d->FLAIRParameter->getWidget(), 0, Qt::AlignCenter);

    QHBoxLayout *MRIBox3Layout = new QHBoxLayout();
    MRIBox3Layout->addWidget(d->T1GdParameter->getWidget(), 0, Qt::AlignCenter);
    MRIBox3Layout->addWidget(d->MaskParameter->getWidget(), 0, Qt::AlignCenter);

    medTriggerParameter *clearImagesButton = new medTriggerParameter("Clear Images", this);
    clearImagesButton->setButtonText("Remove whole images");

    QVBoxLayout *box1Layout = new QVBoxLayout();
    box1Layout->addLayout(MRIBox1Layout);
    box1Layout->addLayout(MRIBox2Layout);
    box1Layout->addLayout(MRIBox3Layout);
    box1Layout->addWidget(clearImagesButton->getPushButton());

    d->ImagesGroupBox = new QGroupBox(tr("Select MRI Images"));
    d->ImagesGroupBox->setLayout(box1Layout);

    d->chooseT1 = new medBoolParameter("Choose T1", this);
    d->chooseT1->setToolTip("use T1 during automatic segmentation");
    d->chooseT1->getCheckBox()->setCheckState(Qt::Checked);

    d->chooseT2 = new medBoolParameter("Choose T2", this);
    d->chooseT2->setToolTip("use T2 during automatic segmentation");
    d->chooseT2->getCheckBox()->setCheckState(Qt::Checked);

    d->chooseDP = new medBoolParameter("Choose DP", this);
    d->chooseDP->setToolTip("use DP during automatic segmentation");
    d->chooseDP->getCheckBox()->setCheckState(Qt::Checked);

    d->chooseFLAIR = new medBoolParameter("Choose FLAIR", this);
    d->chooseFLAIR->setToolTip("use FLAIR during automatic segmentation");
    d->chooseFLAIR->getCheckBox()->setCheckState(Qt::Unchecked);
    d->chooseFLAIR->getCheckBox()->setCheckable(false);

    d->chooseT1Gd = new medBoolParameter("Choose T1Gd", this);
    d->chooseT1Gd->setToolTip("use t1 Gd during automatic segmentation");
    d->chooseT1Gd->getCheckBox()->setCheckState(Qt::Unchecked);
    d->chooseT1Gd->getCheckBox()->setCheckable(false);

    medStringParameter *useT1Text = new medStringParameter("use T1",this);
    medStringParameter *useT2Text = new medStringParameter("use T2",this);
    medStringParameter *useDPText = new medStringParameter("use DP",this);
    medStringParameter *useFLAIRText = new medStringParameter("use FLAIR",this);
    medStringParameter *useT1GdText = new medStringParameter("use T1Gd",this);

    QFormLayout *ChooseSeqLayout = new QFormLayout();
    ChooseSeqLayout->addRow(useT1Text->getLabel() , d->chooseT1->getWidget() );
    ChooseSeqLayout->addRow(useT2Text->getLabel(), d->chooseT2->getWidget() );
    ChooseSeqLayout->addRow(useDPText->getLabel(), d->chooseDP->getWidget() );
    ChooseSeqLayout->addRow(useFLAIRText->getLabel(), d->chooseFLAIR->getWidget() );
    ChooseSeqLayout->addRow(useT1GdText->getLabel(), d->chooseT1Gd->getWidget() );

    d->ChooseSeqGroupBox = new QGroupBox(tr("Choose 3 MRI for auto seg"));
    d->ChooseSeqGroupBox->setLayout(ChooseSeqLayout);


    // Heuristic Rules Parameters
    d->removeBorderLesions = new medBoolParameter("Remove Border", this);
    d->removeBorderLesions->setToolTip("Remove lesions that are not touching the brain mask");
    d->removeBorderLesions->getCheckBox()->setChecked(Qt::Unchecked);

    d->minGMSize = new medDoubleParameter("GMSize", this);
    d->minGMSize->getSpinBox()->setToolTip("Minimum gey matter region size");
    d->minGMSize->setRange(0,1000);
    d->minGMSize->setValue(0);
    d->minGMSize->getSpinBox()->setDecimals(1);
    d->minGMSize->getSpinBox()->setSingleStep(1);
    d->minGMSize->getSpinBox()->setSuffix(" mm3");

    d->minLesionsSize = new medDoubleParameter("LesionSize", this);
    d->minLesionsSize->setToolTip("Minimum lesion size");
    d->minLesionsSize->setRange(0,1000);
    d->minLesionsSize->setValue(0);
    d->minLesionsSize->setSingleStep(1);
    d->minLesionsSize->getSpinBox()->setDecimals(1);
    d->minLesionsSize->getSpinBox()->setSuffix(" mm3");

    d->useIntensityRule = new medBoolParameter("Intensity Rule", this);
    d->useIntensityRule->setToolTip("In T2 image, lesions will have to ...");
    d->useIntensityRule->getCheckBox()->setCheckState(Qt::Unchecked);

    d->T2intensityFactor = new medDoubleParameter("T2intensity", this);
    d->T2intensityFactor->setToolTip("T2 intensiy factor");
    d->T2intensityFactor->setRange(0,10);
    d->T2intensityFactor->setValue(2);
    d->T2intensityFactor->setSingleStep(0.1);
    d->T2intensityFactor->getSpinBox()->setDecimals(2);
    d->T2intensityFactor->getSpinBox()->setDisabled(true);

    d->DPintensityFactor = new medDoubleParameter("DPintensity", this);
    d->DPintensityFactor->setToolTip("DP intensiy factor");
    d->DPintensityFactor->setRange(0,10);
    d->DPintensityFactor->setValue(2);
    d->DPintensityFactor->setSingleStep(0.1);
    d->DPintensityFactor->getSpinBox()->setDecimals(2);
    d->DPintensityFactor->getSpinBox()->setDisabled(true);

    d->FLAIRintensityFactor = new medDoubleParameter("FLAIRintensity", this);
    d->FLAIRintensityFactor->setToolTip("FLAIR intensiy factor");
    d->FLAIRintensityFactor->setRange(0,10);
    d->FLAIRintensityFactor->setValue(2);
    d->FLAIRintensityFactor->setSingleStep(0.1);
    d->FLAIRintensityFactor->getSpinBox()->setDecimals(2);
    d->FLAIRintensityFactor->getSpinBox()->setDisabled(true);

    medStringParameter *RemoveBorderText = new medStringParameter("Remove border lesions",this);
    medStringParameter *MinLesionText = new medStringParameter("Min lesion size",this);
    medStringParameter *MinGMText = new medStringParameter("Min GM region size",this);
    medStringParameter *IntensityRuleText = new medStringParameter("Intensity rule",this);
    medStringParameter *T2multiText = new medStringParameter("T2 multi",this);
    medStringParameter *DPmultiText = new medStringParameter("DP multi",this);
    medStringParameter *FLAIRmultiText = new medStringParameter("FLAIR multi",this);

    QFormLayout *heuristicLayout = new QFormLayout();
    heuristicLayout->addRow(RemoveBorderText->getLabel(), d->removeBorderLesions->getWidget() );
    heuristicLayout->addRow(MinLesionText->getLabel(), d->minLesionsSize->getWidget() );
    heuristicLayout->addRow(MinGMText->getLabel(), d->minGMSize->getWidget() );
    heuristicLayout->addRow(IntensityRuleText->getLabel(), d->useIntensityRule->getWidget() );
    heuristicLayout->addRow(T2multiText->getLabel(), d->T2intensityFactor->getWidget() );
    heuristicLayout->addRow(DPmultiText->getLabel(), d->DPintensityFactor->getWidget() );
    heuristicLayout->addRow(FLAIRmultiText->getLabel(), d->FLAIRintensityFactor->getWidget() );

    d->heuristicGroupBox = new QGroupBox(tr("Heuristic Parameters"));
    d->heuristicGroupBox->setLayout(heuristicLayout);


    /* ---------------------------------------------- Segmentations Parameters ---------------------------------------------- */

    d->enableAuto = new medBoolParameter("auto", this);
    d->enableAuto->setToolTip("Enable automatic segmentation");
    d->enableAuto->getCheckBox()->setCheckState(Qt::Checked);

    d->useFormerSegModel = new medBoolParameter("useFormer", this);
    d->useFormerSegModel->setToolTip("Keep former NABT estination");
    d->useFormerSegModel->getCheckBox()->setCheckState(Qt::Unchecked);

    medStringParameter *AutoText = new medStringParameter("Enable automatic computation",this);
    medStringParameter *KeepSegText = new medStringParameter("Keep former NABT estimation",this);

    QFormLayout *enableAutoLayout = new QFormLayout();
    enableAutoLayout->addRow(AutoText->getLabel(),d->enableAuto->getWidget());
    enableAutoLayout->addRow(KeepSegText->getLabel(),d->useFormerSegModel->getWidget());


    d->AutoGroupBox = new QGroupBox(tr("Use automatic seg"));
    d->AutoGroupBox->setLayout(enableAutoLayout);

    d->init = new medStringListParameter("init", this);
    d->init->setToolTip("Type of initialisation");
    QStringList initList;
    initList << "Atlas" << "Hierar DP" << "Hierar FLAIR";
    d->init->addItems ( initList );
    d->init->getComboBox()->setCurrentIndex(1);

    QVBoxLayout *initLayout = new QVBoxLayout();
    initLayout->addWidget(d->init->getWidget());

    d->algoEM = new medStringListParameter("algoEM",this);
    d->algoEM->setToolTip("Type of EM algorithm");
    QStringList algoEMList;
    algoEMList << "EM" << "Celeux REM" << "REM";
    d->algoEM->addItems(algoEMList);
    d->algoEM->getComboBox()->setCurrentIndex(2);

    d->emIter = new medIntParameter("emIter",this);
    d->emIter->setToolTip("xx");
    d->emIter->setRange(0,1000);
    d->emIter->setValue(100);
    d->emIter->getSpinBox()->setSingleStep(1);

    d->minDistance = new medDoubleParameter("minDist", this);
    d->minDistance->setToolTip("xx");
    d->minDistance->setRange(0,10);
    d->minDistance->getSpinBox()->setDecimals(4);
    d->minDistance->setValue(0.0001);
    d->minDistance->setSingleStep(0.0001);

    d->rejRatio = new medDoubleParameter("rejRatio", this);
    d->rejRatio->setToolTip("xx");
    d->rejRatio->setRange(0.01,0.49);
    d->rejRatio->getSpinBox()->setDecimals(2);
    d->rejRatio->setValue(0.2);
    d->rejRatio->setSingleStep(0.01);

    d->emIterConcentration = new medIntParameter("emIterC",this);
    d->emIterConcentration->setToolTip("xx");
    d->emIterConcentration->setRange(0,1000);
    d->emIterConcentration->setValue(100);
    d->emIterConcentration->getSpinBox()->setSingleStep(1);

    d->emBeforeConcentration = new medBoolParameter("emBefore",this);
    d->emBeforeConcentration->setToolTip("xx");
    d->emBeforeConcentration->getCheckBox()->setCheckState(Qt::Unchecked);

    medStringParameter *EMText = new medStringParameter("EM algorithm type",this);
    medStringParameter *InitText = new medStringParameter("Initialisation",this);
    medStringParameter *MaxItText = new medStringParameter("Max iterations",this);
    medStringParameter *MinDistText = new medStringParameter("Minimum distance",this);
    medStringParameter *RejRatioText = new medStringParameter("Rejection ratio",this);
    medStringParameter *MaxItCText = new medStringParameter("Max iterations between \n concentration steps",this);
    medStringParameter *EMBText = new medStringParameter("EM before first concentration",this);

    QFormLayout *NABTLayout = new QFormLayout();
    NABTLayout->addRow(EMText->getLabel(),d->algoEM->getWidget());
    NABTLayout->addRow(InitText->getLabel(),initLayout);
    NABTLayout->addRow(MaxItText->getLabel(),d->emIter->getWidget());
    NABTLayout->addRow(MinDistText->getLabel(),d->minDistance->getWidget());
    NABTLayout->addRow(RejRatioText->getLabel(),d->rejRatio->getWidget());
    NABTLayout->addRow(MaxItCText->getLabel(),d->emIterConcentration->getWidget());
    NABTLayout->addRow(EMBText->getLabel(),d->emBeforeConcentration->getWidget());

    d->NABTGroupBox = new QGroupBox(tr("Normal appearing brain tissues estimation"));
    d->NABTGroupBox->setLayout(NABTLayout);



    d->strem = new medBoolParameter("strem",this);
    d->strem->setToolTip("Use strem option. Graph Cut will NOT be used.");
    d->strem->getRadioButton()->setChecked(false);

    d->mahaDist = new medDoubleParameter("maha", this);
    d->mahaDist->setToolTip("xxxxx");
    d->mahaDist->setRange(0,10);
    d->mahaDist->setValue(0.4);
    d->mahaDist->getSpinBox()->setDecimals(2);
    d->mahaDist->setSingleStep(0.01);
    d->mahaDist->getSpinBox()->setDisabled(true);

    d->fuzzy = new medBoolParameter("fuzzy",this);
    d->fuzzy->setToolTip("Use fuzzy option. Graph Cut will be used.");
    d->fuzzy->getRadioButton()->setChecked(true);

    d->fuzzyMin = new medDoubleParameter("fuzzyMin", this);
    d->fuzzyMin->setToolTip("xxxxx");
    d->fuzzyMin->setRange(0,1000);
    d->fuzzyMin->setValue(2.0);
    d->fuzzyMin->getSpinBox()->setDecimals(2);
    d->fuzzyMin->setSingleStep(0.01);

    d->fuzzyMax = new medDoubleParameter("fuzzyMax", this);
    d->fuzzyMax->setToolTip("xxxx");
    d->fuzzyMax->setRange(0,1000);
    d->fuzzyMax->setValue(3.0);
    d->fuzzyMax->getSpinBox()->setDecimals(2);
    d->fuzzyMax->setSingleStep(0.01);

    medStringParameter *UseStremText = new medStringParameter("Use Strem",this);
    medStringParameter *MahaText = new medStringParameter("Mahalanobis distance",this);
    medStringParameter *UseFuzzyText = new medStringParameter("Use Fuzzy rules (graph cut)",this);
    medStringParameter *MinFuzzyText = new medStringParameter("Min fuzzy rule",this);
    medStringParameter *MaxFuzzyText = new medStringParameter("Max fuzzy rule",this);

    QFormLayout *DetectionLayout = new QFormLayout();
    DetectionLayout->addRow(UseStremText->getLabel(),d->strem->getRadioButton());
    DetectionLayout->addRow(MahaText->getLabel(),d->mahaDist->getWidget());
    DetectionLayout->addRow(UseFuzzyText->getLabel(),d->fuzzy->getRadioButton());
    DetectionLayout->addRow(MinFuzzyText->getLabel(),d->fuzzyMin->getWidget());
    DetectionLayout->addRow(MaxFuzzyText->getLabel(),d->fuzzyMax->getWidget());

    d->DetectionGroupBox = new QGroupBox(tr("Detection of candidate lesions"));
    d->DetectionGroupBox->setLayout(DetectionLayout);


    // Graph cut
    d->alpha = new medDoubleParameter("alpha", this);
    d->alpha->setRange(0, 1000);
    d->alpha->setValue(10);

    d->sigma = new medDoubleParameter("sigma", this);
    d->sigma->setRange(0, 1000);
    d->sigma->setValue(0.6);
    d->sigma->setSingleStep(0.1);

    d->NbItGc = new medIntParameter("NbItGc", this);
    d->NbItGc->setToolTip("xx");
    d->NbItGc->setRange(0,10);
    d->NbItGc->setValue(1);

    d->useSpectralGrad = new medBoolParameter("useSepc",this);
    d->useSpectralGrad->getCheckBox()->setChecked(true);

    d->enableManu = new medBoolParameter("manu",this);
    d->enableManu->setToolTip("Enable manual masks as entries");
    d->enableManu->getCheckBox()->setCheckState(Qt::Unchecked);

    d->multiVarSources = new medDoubleParameter("varSources", this);
    d->multiVarSources->setToolTip("xx");
    d->multiVarSources->setRange(0,20);
    d->multiVarSources->getSpinBox()->setDecimals(2);
    d->multiVarSources->setValue(1);
    d->multiVarSources->setSingleStep(0.1);

    d->multiVarSinks = new medDoubleParameter("varSinks", this);
    d->multiVarSinks->setToolTip("xx");
    d->multiVarSinks->setRange(0,20);
    d->multiVarSinks->getSpinBox()->setDecimals(2);
    d->multiVarSinks->setValue(1);
    d->multiVarSinks->setSingleStep(0.1);

    d->multiVarSources->getSpinBox()->setDisabled(true);
    d->multiVarSinks->getSpinBox()->setDisabled(true);


    medStringParameter *alphaText = new medStringParameter("Alpha",this);
    medStringParameter *sigmaText = new medStringParameter("Sigma",this);
    medStringParameter *specText = new medStringParameter("Use Spectral Gradient",this);
    medStringParameter *manuText = new medStringParameter("Enable manual masks",this);
    medStringParameter *multiSourcesText = new medStringParameter("Multiply source variance factor",this);
    medStringParameter *multiSinksText = new medStringParameter("Multiply sink variance factor",this);
    medStringParameter *NbItGcText = new medStringParameter("Number iterations GC",this);

    QFormLayout *gcParamBoxLayout = new QFormLayout();
    gcParamBoxLayout->addRow(alphaText->getLabel(),d->alpha->getWidget());
    gcParamBoxLayout->addRow(sigmaText->getLabel(),d->sigma->getWidget());
    gcParamBoxLayout->addRow(NbItGcText->getLabel(),d->NbItGc->getWidget());
    gcParamBoxLayout->addRow(specText->getLabel(),d->useSpectralGrad->getWidget());
    gcParamBoxLayout->addRow(manuText->getLabel(),d->enableManu->getWidget());
    gcParamBoxLayout->addRow(multiSourcesText->getLabel(),d->multiVarSources->getWidget());
    gcParamBoxLayout->addRow(multiSinksText->getLabel(),d->multiVarSinks->getWidget());

    d->ManuSegMaskParameter = new medDataIndexParameter("Manu", this);
    d->ManuSegMaskParameter->setToolTip(tr("Drag-and-drop a seed mask for the graph cut from the database or click here (1=sources, 2=sinks)."));
    d->ManuSegMaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here to open \n a seed mask."));
    d->ManuSegMaskParameter->getDropSite()->setDisabled(true);

    d->ExternalMaskParameter = new medDataIndexParameter("External", this);
    d->ExternalMaskParameter->setToolTip(tr("Drag-and-drop a seed mask for the graph cut from the database or click here (1=sources, 2=sinks)."));
    d->ExternalMaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here to open \n a seed mask."));
    d->ExternalMaskParameter->getDropSite()->setDisabled(true);

    medTriggerParameter *clearManuButton = new medTriggerParameter("Remove Mask Manu", this);
    clearManuButton->setButtonText("Remove Mask");

    medTriggerParameter *clearExtButton = new medTriggerParameter("Remove Mask Ext", this);
    clearExtButton->setButtonText("Remove Mask");

    QVBoxLayout *ManuMaskLayout = new QVBoxLayout;
    ManuMaskLayout->addWidget(d->ManuSegMaskParameter->getWidget(), 0, Qt::AlignCenter);
    ManuMaskLayout->addWidget(clearManuButton->getPushButton(), 0, Qt::AlignCenter);

    QVBoxLayout *ExtMaskLayout = new QVBoxLayout;
    ExtMaskLayout->addWidget(d->ExternalMaskParameter->getWidget(), 0, Qt::AlignCenter);
    ExtMaskLayout->addWidget(clearExtButton->getPushButton(), 0, Qt::AlignCenter);

    QHBoxLayout *seedMasksLayout = new QHBoxLayout;
    seedMasksLayout->addLayout(ManuMaskLayout);
    seedMasksLayout->addLayout(ExtMaskLayout);

    QVBoxLayout *gcBoxLayout = new QVBoxLayout();
    gcBoxLayout->addLayout(gcParamBoxLayout);
    gcBoxLayout->addLayout(seedMasksLayout);

    d->gcGroupBox = new QGroupBox(tr("Graph Cut Parameters"));
    d->gcGroupBox->setLayout(gcBoxLayout);

    d->threads = new medIntParameter("Threads", this);
    d->threads->setToolTip("xx");
    d->threads->setValue(8);
    d->threads->setRange(1,8);

    medStringParameter *ThreadsText = new medStringParameter("Threads",this);

    QFormLayout *globalParamBoxLayout = new QFormLayout();
    globalParamBoxLayout->addRow(ThreadsText->getLabel(),d->threads->getWidget());
    d->globalParametersGroupBox = new QGroupBox(tr("Global Parameters"));
    d->globalParametersGroupBox->setLayout(globalParamBoxLayout);


    /* ---------------------------------------------- main stuff ---------------------------------------------- */

    d->page1 = new QWidget;
    QVBoxLayout *layout1 = new QVBoxLayout(d->page1);
    layout1->addWidget(d->ImagesGroupBox);
    layout1->addWidget(d->ChooseSeqGroupBox);
    layout1->addWidget(d->heuristicGroupBox);

    d->page2 = new QWidget;
    QVBoxLayout *layout2 = new QVBoxLayout(d->page2);
    layout2->addWidget(d->AutoGroupBox);
    layout2->addWidget(d->NABTGroupBox);
    layout2->addWidget(d->DetectionGroupBox);
    layout2->addWidget(d->gcGroupBox);
    layout2->addWidget(d->globalParametersGroupBox);

    d->widgetTab = new medToolBoxTab;
    d->widgetTab->addTab(d->page1, "Main");
    d->widgetTab->addTab(d->page2, "Segmentation Parameters");

    /* ---------------------------------------------- connect ---------------------------------------------- */
    connect(d->MaskParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onMaskDropped(const medDataIndex &)));
    connect(d->T1Parameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onT1Dropped(const medDataIndex &)));
    connect(d->T2Parameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onT2Dropped(const medDataIndex &)));

    connect(d->DPParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onDPDropped(const medDataIndex &)));
    connect(d->FLAIRParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onFLAIRDropped(const medDataIndex &)));
    connect(d->T1GdParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onT1GdDropped(const medDataIndex &)));

    connect(d->ManuSegMaskParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onManuSegMaskDropped(const medDataIndex &)));
    connect(d->ExternalMaskParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onExternalMaskDropped(const medDataIndex &)));

    connect(clearImagesButton,SIGNAL(triggered()),this,SLOT(onClearImagesClicked()));
    connect(clearManuButton,SIGNAL(triggered()),this,SLOT(onClearManuSegMaskClicked()));
    connect(clearExtButton,SIGNAL(triggered()),this,SLOT(onClearExternalMaskClicked()));

    connect(d->chooseT1, SIGNAL(valueChanged(bool)),this, SLOT(chooseT1changed(bool)));
    connect(d->chooseT2, SIGNAL(valueChanged(bool)),this, SLOT(chooseT2changed(bool)));
    connect(d->chooseDP, SIGNAL(valueChanged(bool)),this, SLOT(chooseDPchanged(bool)));
    connect(d->chooseFLAIR, SIGNAL(valueChanged(bool)),this, SLOT(chooseFLAIRchanged(bool)));
    connect(d->chooseT1Gd, SIGNAL(valueChanged(bool)),this, SLOT(chooseT1Gdchanged(bool)));

    connect(d->enableAuto, SIGNAL(valueChanged(bool)),this,SLOT(ChangeAutomaticState(bool)));
    connect(d->enableManu, SIGNAL(valueChanged(bool)),this,SLOT(ChangeManuState(bool)));
    connect(d->strem, SIGNAL(valueChanged(bool)),this,SLOT(CheckedStrem(bool)));
    connect(d->fuzzy, SIGNAL(valueChanged(bool)),this,SLOT(CheckedFuzzy(bool)));
    connect(d->algoEM->getComboBox(), SIGNAL(currentIndexChanged(int)), this, SLOT(updateRejectionFeatures(int)));
    connect(d->useIntensityRule, SIGNAL(valueChanged(bool)), this, SLOT(ChangedIntensityState(bool)));

    connect(this, SIGNAL(success()), this, SLOT(displayOutputs()));
    connect(this, SIGNAL(failure()), this, SLOT(displayWarnings()));
}

QWidget* animaLesionsSegmentation::parameterWidget()
{
    if(d->parameterWidget.isNull())
    {
        d->parameterWidget = new QWidget;
        QHBoxLayout *layoutH = new QHBoxLayout(d->parameterWidget);
        layoutH->addWidget(d->widgetTab);
    }
    return d->parameterWidget;
}

animaLesionsSegmentation::~animaLesionsSegmentation(void)
{
    delete d;
}

medViewContainerSplitter* animaLesionsSegmentation::viewContainerSplitter()
{
    medViewContainerSplitter* split = medAbstractProcess::viewContainerSplitter();


    /*QPointer<medViewContainerSplitter> viewContainerSplitter;
    if(viewContainerSplitter.isNull())
    {
        viewContainerSplitter = new medViewContainerSplitter;
        QList<medInputDataPort*> inputDataPortList;
        QList<medOutputDataPort*> outputDataPortList;

        foreach(medProcessIOPort *port, this->inputs())
        {
            medInputDataPort* input = reinterpret_cast< medInputDataPort*>(port);
            if(input)
                inputDataPortList << input;
        }
        foreach(medProcessIOPort *port, this->outputs())
        {
            medOutputDataPort *output = reinterpret_cast<medOutputDataPort*>(port);
            if(output)
                outputDataPortList << output;
        }

        medViewContainer* inputContainer;
        medViewContainer* outputContainer;

        if(!inputDataPortList.isEmpty())
        {
            inputContainer = new medViewContainer;
            medInputDataPort* i = inputDataPortList.takeFirst();
            inputContainer->addData(i->input());
            viewContainerSplitter->addViewContainer(inputContainer);
            //containerForInputPort[i] = inputContainer;
            inputContainer->setClosingMode(medViewContainer::CLOSE_VIEW_ONLY);
            inputContainer->setDefaultWidget(new QLabel(i->name()));
            inputContainer->setUserSplittable(false);
            inputContainer->setMultiLayered(false);

            connect(inputContainer, SIGNAL(viewContentChanged()), this, SLOT(handleInput()));
            connect(inputContainer, SIGNAL(viewRemoved()), this, SLOT(handleInput()));

            foreach(medInputDataPort* i, inputDataPortList)
            {
                medViewContainer *container = inputContainer->splitHorizontally();
                container->addData(i->input());
                //containerForInputPort[i] = container;
                container->setClosingMode(medViewContainer::CLOSE_VIEW_ONLY);
                container->setDefaultWidget(new QLabel(i->name()));
                container->setUserSplittable(false);
                container->setMultiLayered(false);

                connect(container, SIGNAL(viewContentChanged()), this, SLOT(handleInput()));
                connect(container, SIGNAL(viewRemoved()), this, SLOT(handleInput()));
            }
        }

       /* if(!outputDataPortList.isEmpty())
        {
            outputContainer = new medViewContainer;
            medOutputDataPort* o = outputDataPortList.takeFirst();
            viewContainerSplitter->addViewContainer(outputContainer);
            containerForOutputPort[o] = outputContainer;
            outputContainer->setClosingMode(medViewContainer::CLOSE_VIEW_ONLY);
            outputContainer->setDefaultWidget(new QLabel(o->name()));
            outputContainer->setUserOpenable(false);
            outputContainer->setUserSplittable(false);
            outputContainer->setMultiLayered(false);

            foreach(medOutputDataPort* o, outputDataPortList)
            {
                medViewContainer *container = outputContainer->splitHorizontally();
                container->addData(o->output());
                d->containerForOutputPort[o] = container;
                container->setClosingMode(medViewContainer::CLOSE_VIEW_ONLY);
                container->setDefaultWidget(new QLabel(o->name()));
                container->setUserOpenable(false);
                container->setUserSplittable(false);
                container->setMultiLayered(false);
            }
        }

        viewContainerSplitter->adjustContainersSize();
    }*/
   // return viewContainerSplitter;




    typedef medProcessInput<medAbstractData> medInputDataPort;

    medProcessIOPort *inputPort1 = this->inputs()[0];
    if(inputPort1)
    {
        medInputDataPort *dataPort1 = dynamic_cast<medInputDataPort*> (inputPort1);
        d->containerImage1 = this->container(dataPort1);
        d->containerImage1->setMultiLayered(true);
        d->containerImage1->setUserOpenable(false);
        d->containerImage1->setClosingMode(medViewContainer::CLOSE_BUTTON_HIDDEN);
    }

    medProcessIOPort *inputPort2 = this->inputs()[1];
    if(inputPort2)
    {
        medInputDataPort *dataPort2 = dynamic_cast<medInputDataPort*> (inputPort2);
        d->containerImage2 = this->container(dataPort2);
        d->containerImage2->setMultiLayered(true);
        d->containerImage2->setUserOpenable(false);
        d->containerImage2->setClosingMode(medViewContainer::CLOSE_BUTTON_HIDDEN);
    }

    medProcessIOPort *inputPort3 = this->inputs()[2];
    if(inputPort3)
    {
        medInputDataPort *dataPort3 = dynamic_cast<medInputDataPort*> (inputPort3);
        d->containerImage3 = this->container(dataPort3);
        d->containerImage3->setMultiLayered(true);
        d->containerImage3->setUserOpenable(false);
        d->containerImage3->setClosingMode(medViewContainer::CLOSE_BUTTON_HIDDEN);
    }

    //connect(d->containerImage1, SIGNAL(viewContentChanged()),this,SLOT(viewContentChangedSlotView1()));
  //  connect(d->containerImage2, SIGNAL(viewContentChanged()),this,SLOT(viewContentChangedSlotView2()));
  //  connect(d->containerImage3, SIGNAL(viewContentChanged()),this,SLOT(viewContentChangedSlotView3()));

    return split;
}

void animaLesionsSegmentation::viewContentChangedSlotView1()
{

    medAbstractView *view1 = d->containerImage1->view();
    medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
    if(!imageView1)
        return;

    medImageMaskAnnotationData * existingMaskAnnData1 = dynamic_cast<medImageMaskAnnotationData *>(imageView1->layerData(1));
    if(!existingMaskAnnData1)
    {
        std::cout << "non mask in change view1" << std::endl;
        return;
    }

    medAbstractView *view3 = d->containerImage3->view();
    medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
    if(imageView3)
    {
        imageView3->addLayer(existingMaskAnnData1);

        medAbstractData * referenceData3 = imageView3->layerData(0);
        if(referenceData3)
          referenceData3->addAttachedData(existingMaskAnnData1);
    }

    medAbstractView *view2 = d->containerImage2->view();
    medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
    if(imageView2)
    {
        imageView2->addLayer(existingMaskAnnData1);
        medAbstractData * referenceData2 = imageView2->layerData(0);
        if(referenceData2)
          referenceData2->addAttachedData(existingMaskAnnData1);
    }


        /*medAbstractData *data2 =  dynamic_cast <medAbstractData *> ( data );

        dtkSmartPointer <medAbstractImageData> imageData = dynamic_cast <medAbstractImageData *> ( data2 );
        if(!imageData)
        {
             qDebug() << "Image Data null";
             return;
        }

        typedef itk::Image <unsigned char,3> InputImageTypeUC;
        typedef InputImageTypeUC::Pointer InputImagePointerUC;

        InputImagePointerUC input = NULL;
        input= this->createInputMasks(imageData);*/
}

void animaLesionsSegmentation::viewContentChangedSlotView2()
{
    medAbstractView *view2 = d->containerImage2->view();
    medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
    if(!imageView2)
        return;

    medAbstractData *data = imageView2->layerData(imageView2->layersCount()-1);
    if(!data)
    {
         return;
    }

    medAbstractView *view3 = d->containerImage3->view();
    medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
    if(!imageView3)
        return;

    imageView3->addLayer(data);



    medAbstractView *view1 = d->containerImage1->view();
    medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
    if(!imageView1)
        return;

    imageView1->addLayer(data);

}

void animaLesionsSegmentation::viewContentChangedSlotView3()
{
    medAbstractView *view3 = d->containerImage3->view();
    medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
    if(!imageView3)
        return;

    medAbstractData *data = imageView3->layerData(imageView3->layersCount()-1);
    if(!data)
    {
         return;
    }

    medAbstractView *view1 = d->containerImage1->view();
    medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
    if(!imageView1)
        return;

    imageView1->addLayer(data);


    medAbstractView *view2 = d->containerImage2->view();
    medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
    if(!imageView2)
        return;

    imageView2->addLayer(data);
}

void animaLesionsSegmentation::displayWarnings()
{
    if(!d->MaskisSet)
    {
        QMessageBox::warning(d->parameterWidget,tr("Missing inputs"), tr("A brain mask is mandatory to perform the segmentation"));
        return;
    }

    if(d->enableAuto->getCheckBox()->isChecked() && d->nb_seq<3)
    {
        QMessageBox::warning(d->parameterWidget,tr("Missing inputs"), tr("Automatic segmentation requires 3 sequences"));
        return;
    }

    if(d->useSpectralGrad->getCheckBox()->isChecked() && d->nb_seq<3)
    {
        QMessageBox::warning(d->parameterWidget,tr("Missing inputs"), tr("Spectral gradient option requires at least 3 sequences."));
        return;
    }

    if((d->enableAuto->getCheckBox()->isChecked()) && (!d->T1isSet))
    {
        QMessageBox::warning(d->parameterWidget, "Missing inputs", "T1 sequence is required for automatic process");
        return;
    }

    if((d->enableAuto->getCheckBox()->isChecked()) && (d->init->getComboBox()->currentIndex()==1) && (!d->DPisSet))
    {
        QMessageBox::warning(d->parameterWidget, "Missing inputs", "Hierarchical DP Init requires DP sequence.");
        return;
    }

    if((d->enableAuto->getCheckBox()->isChecked()) && (d->init->getComboBox()->currentIndex()==2) && (!d->FLAIRisSet))
    {
        QMessageBox::warning(d->parameterWidget, "Missing inputs", "Hierarchical FLAIR Init requires FLAIR sequence.");
        return;
    }

    if(  d->enableManu->getCheckBox()->isChecked() && ( !d->ExternalMaskisSet && !d->ManuSegMaskisSet ) )
    {
        QMessageBox::warning(d->parameterWidget, "Missing inputs", "There is no seed mask input. \n Add at least one manual sources and sink mask or choose automatic seed computation only.");
        return;
    }
}

void animaLesionsSegmentation::checkNbSequences()
{
    if(d->nb_seq_checked==3)
    {
        if(!d->chooseT1->getCheckBox()->isChecked())
            d->chooseT1->getCheckBox()->setCheckable(false);

        if(!d->chooseT2->getCheckBox()->isChecked())
            d->chooseT2->getCheckBox()->setCheckable(false);

        if(!d->chooseDP->getCheckBox()->isChecked())
            d->chooseDP->getCheckBox()->setCheckable(false);

        if(!d->chooseFLAIR->getCheckBox()->isChecked())
            d->chooseFLAIR->getCheckBox()->setCheckable(false);

        if(!d->chooseT1Gd->getCheckBox()->isChecked())
            d->chooseT1Gd->getCheckBox()->setCheckable(false);
    }

    if(d->nb_seq_checked<3)
    {
        d->chooseT1->getCheckBox()->setCheckable(true);
        d->chooseT2->getCheckBox()->setCheckable(true);
        d->chooseDP->getCheckBox()->setCheckable(true);
        d->chooseFLAIR->getCheckBox()->setCheckable(true);
        d->chooseT1Gd->getCheckBox()->setCheckable(true);
    }
}

void animaLesionsSegmentation::chooseT1changed(bool state)
{
    if(state==true)
    {
        d->nb_seq_checked++;
        checkNbSequences();
        if(!d->T1Data.isNull())
        {
            this->setDataInContainer(d->T1Data,d->posT1,"T1");
        }
    }

    if(state==false)
    {
        removeSeq(d->posT1);
        d->T1isSet=false;
    }
}

void animaLesionsSegmentation::chooseT2changed(bool state)
{
    if(state==true)
    {
        d->nb_seq_checked++;
        checkNbSequences();
        if(!d->T2Data.isNull())
        {
            this->setDataInContainer(d->T2Data,d->posT2,"T2");
        }
    }

    if(state==false)
    {
        removeSeq(d->posT2);
        d->T2isSet=false;
    }
}

void animaLesionsSegmentation::chooseDPchanged(bool state)
{

    if(state==true)
    {
        d->nb_seq_checked++;
        checkNbSequences();
        if(!d->DPData.isNull())
        {
            this->setDataInContainer(d->DPData,d->posDP,"DP");
        }
    }
    if(state==false)
    {
        removeSeq(d->posDP);
        d->DPisSet=false;
    }
}

void animaLesionsSegmentation::chooseFLAIRchanged(bool state)
{
    if(state==true)
    {
        d->nb_seq_checked++;
        checkNbSequences();
        if(!d->FLAIRData.isNull())
        {
            this->setDataInContainer(d->FLAIRData,d->posFLAIR,"FLAIR");
        }
    }

    if(state==false)
    {
        removeSeq(d->posFLAIR);
        d->FLAIRisSet=false;
    }
}

void animaLesionsSegmentation::chooseT1Gdchanged(bool state)
{
    if(state==true)
    {
        d->nb_seq_checked++;
        checkNbSequences();
        if(!d->T1GdData.isNull())
        {
            this->setDataInContainer(d->T1GdData,d->posT1Gd,"T1Gd");
        }
    }
    if(state==false)
    {
        removeSeq(d->posT1Gd);
        d->T1GdisSet=false;
    }
}

void animaLesionsSegmentation::removeSeq(int &pos)
{
    switch (pos)
    {
        case 1:
        {
            d->containerImage1->removeView();
            d->cont1isFree = true;
            d->nb_seq--;
            break;
         }
        case 2:
        {
            d->containerImage2->removeView();
            d->cont2isFree = true;
            d->nb_seq--;
            break;
        }
        case 3:
        {
            d->containerImage3->removeView();
            d->cont3isFree = true;
            d->nb_seq--;
            break;
        }
    }

    pos=0;
    d->nb_seq_checked--;
    checkNbSequences();
}

void animaLesionsSegmentation::onClearManuSegMaskClicked()
{
    if(d->ManuSegMaskisSet) // first remove form the view if already set before
    {
        medAbstractView *view1 = d->containerImage1->view();
        medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
        if(!imageView1)
            return;

        imageView1->removeData(d->ManuSegMaskData);

        medAbstractView *view2 = d->containerImage2->view();
        medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
        if(!imageView2)
            return;

        imageView2->removeData(d->ManuSegMaskData);

        medAbstractView *view3 = d->containerImage3->view();
        medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
        if(!imageView3)
            return;

        imageView3->removeData(d->ManuSegMaskData);
    }

    d->ManuSegMaskParameter->clear();
    d->ManuSegMaskParameter->setToolTip(tr("Drag-and-drop a seed mask for the graph cut from the database or click here (1=sources, 2=sinks)."));
    d->ManuSegMaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here to open \n a seed mask."));
    d->ManuSegMaskisSet=false;
}

void animaLesionsSegmentation::onClearExternalMaskClicked()
{
    if(d->ExternalMaskisSet) // first remove form the view if already set before
    {
        medAbstractView *view1 = d->containerImage1->view();
        medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
        if(!imageView1)
            return;

        imageView1->removeData(d->ExternalMaskData);

        medAbstractView *view2 = d->containerImage2->view();
        medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
        if(!imageView2)
            return;

        imageView2->removeData(d->ExternalMaskData);

        medAbstractView *view3 = d->containerImage3->view();
        medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
        if(!imageView3)
            return;

        imageView3->removeData(d->ExternalMaskData);

    }

    d->ExternalMaskParameter->clear();
    d->ExternalMaskParameter->setToolTip(tr("Drag-and-drop a seed mask for the graph cut from the database or click here (1=sources, 2=sinks)."));
    d->ExternalMaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here to open \n a seed mask."));
    d->ExternalMaskisSet=false;
}

void animaLesionsSegmentation::onClearImagesClicked()
{
    // clear medDropSite and put text again
    d->T1Parameter->clear();
    d->T1Parameter->setToolTip(tr("Drag-and-drop A T1 from the database or click here."));
    d->T1Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1."));

    d->T2Parameter->clear();
    d->T2Parameter->setToolTip(tr("Drag-and-drop A T2 from the database or click here."));
    d->T2Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T2."));

    d->DPParameter->clear();
    d->DPParameter->setToolTip(tr("Drag-and-drop A DP from the database or click here."));
    d->DPParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a DP."));

    d->FLAIRParameter->clear();
    d->FLAIRParameter->setToolTip(tr("Drag-and-drop A FLAIR from the database or click here."));
    d->FLAIRParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a FLAIR."));

    d->T1GdParameter->clear();
    d->T1GdParameter->setToolTip(tr("Drag-and-drop A T1Gd from the database or click here."));
    d->T1GdParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1Gd."));

    d->MaskParameter->clear();
    d->MaskParameter->setToolTip(tr("Drag-and-drop A Mask from the database or click here."));
    d->MaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a Mask."));

    d->containerImage1->removeView();
    d->containerImage2->removeView();
    d->containerImage3->removeView();

    d->T1isSet=false;
    d->T2isSet=false;
    d->DPisSet=false;
    d->FLAIRisSet=false;
    d->T1GdisSet=false;
    d->MaskisSet=false;

    d->cont1isFree=true;
    d->cont2isFree=true;
    d->cont3isFree=true;

    d->posT1=0, d->posT2=0, d->posDP=0, d->posFLAIR=0, d->posT1Gd=0;
    d->nb_seq=0;
}

void animaLesionsSegmentation::displayOutputs()
{

    medAbstractView *view1 = d->containerImage1->view();
    medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
    if(!imageView1)
        return;


    medImageMaskAnnotationData *existingMaskAnnData1 = new medImageMaskAnnotationData;
    if(!existingMaskAnnData1)
    {
        std::cout << "no data 1" << std::endl;
        return;
    }


    medAbstractData *data = d->outputLesions;
    if(!data)
    {
         std::cout << "no data 2" << std::endl;
        return;
    }
    medAbstractImageData *dataImage = dynamic_cast <medAbstractImageData *> ( data );
    if(!dataImage)
    {
        std::cout << "no data 3" << std::endl;
        return;
    }
    existingMaskAnnData1->setMaskData(dataImage);
    //existingMaskAnnData1->setData(dataImage);

    if(imageView1)
    {
        std::cout << "add layer" << std::endl;
       // imageView1->addLayer(data);
        d->containerImage1->addData(existingMaskAnnData1);

        medAbstractData * referenceData1 = imageView1->layerData(0);
        if(referenceData1)
          referenceData1->addAttachedData(existingMaskAnnData1);
    }



    // ------------------------------------------------------------
    /*medAbstractView *view1 = d->containerImage1->view();
    medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
    if(!imageView1)
        return;

    if(imageView1->contains(d->outputCSF))
    {
        imageView1->removeData(d->outputCSF);
    }
    if(imageView1->contains(d->outputGM))
    {
        imageView1->removeData(d->outputGM);
    }
    if(imageView1->contains(d->outputWM))
    {
        imageView1->removeData(d->outputWM);
    }
    if(imageView1->contains(d->outputLesions))
    {
        imageView1->removeData(d->outputLesions);
    }*/


    // mettre les CSF, GM et WM en image normal, mettre les lesions en annotation

    //d->containerImage1->addData(d->outputLesions);


   /*// dtkSmartPointer <medAbstractData> outputLesions;
    medAbstractData *outputLesions = d->outputLesions;

    medImageMaskAnnotationData * existingMaskAnnData1 = dynamic_cast<medImageMaskAnnotationData *>(d->outputLesions);
    if(!existingMaskAnnData1){
        std::cout << "non annott data" << std::endl;
        return;
    }

    imageView1->addLayer(existingMaskAnnData1);*/


    /*if(d->enableAuto->getCheckBox()->isChecked())
    {
        d->containerImage1->addData(d->outputCSF);
        d->containerImage1->addData(d->outputGM);
        d->containerImage1->addData(d->outputWM);
    }*/



/*
    medAbstractView *view2 = d->containerImage2->view();
    medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
    if(!imageView2)
        return;

    if(imageView2->contains(d->outputCSF))
    {
        imageView2->removeData(d->outputCSF);
    }
    if(imageView2->contains(d->outputGM))
    {
        imageView2->removeData(d->outputGM);
    }
    if(imageView2->contains(d->outputWM))
    {
        imageView2->removeData(d->outputWM);
    }
    if(imageView2->contains(d->outputLesions))
    {
        imageView2->removeData(d->outputLesions);
    }


    d->containerImage2->addData(d->outputLesions);
    if(d->enableAuto->getCheckBox()->isChecked())
    {
        d->containerImage2->addData(d->outputCSF);
        d->containerImage2->addData(d->outputGM);
        d->containerImage2->addData(d->outputWM);
    }


    medAbstractView *view3 = d->containerImage3->view();
    medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
    if(!imageView3)
        return;

    if(imageView3->contains(d->outputCSF))
    {
        imageView3->removeData(d->outputCSF);
    }
    if(imageView3->contains(d->outputGM))
    {
        imageView3->removeData(d->outputGM);
    }
    if(imageView3->contains(d->outputWM))
    {
        imageView3->removeData(d->outputWM);
    }
    if(imageView3->contains(d->outputLesions))
    {
        imageView3->removeData(d->outputLesions);
    }

    d->containerImage3->addData(d->outputLesions);
    if(d->enableAuto->getCheckBox()->isChecked())
    {
        d->containerImage3->addData(d->outputCSF);
        d->containerImage3->addData(d->outputGM);
        d->containerImage3->addData(d->outputWM);
    }*/
}

bool animaLesionsSegmentation::registered()
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaLesionsSegmentation", createanimaLesionsSegmentation, "SemiAutomaticSeg");
}

QString animaLesionsSegmentation::description() const
{
    return "animaLesionsSegmentation";
}

void animaLesionsSegmentation::setDataInContainer(medAbstractData *data, int &pos, QString mod)
{
    if(d->cont1isFree)
    {
        d->containerImage1->addData(data);
        pos = 1;
        d->cont1isFree = false;
        d->cont1mod=mod;
        d->nb_seq++;
        checkNbSequences();
        return;
    }
    if(d->cont1mod==mod)
    {
        d->containerImage1->removeView();
        d->containerImage1->addData(data);
        pos = 1;
        d->cont1isFree = false;
        d->cont1mod=mod;
        return;
    }
    if(d->cont3isFree)
    {
        d->containerImage3->addData(data);
        pos = 3;
        d->cont3isFree = false;
        d->cont3mod=mod;
        d->nb_seq++;
        checkNbSequences();
        return;
    }
    if(d->cont3mod==mod)
    {
        d->containerImage3->removeView();
        d->containerImage3->addData(data);
        pos = 3;
        d->cont3isFree = false;
        d->cont3mod=mod;
        return;
    }
    if(d->cont2isFree)
    {
        d->containerImage2->addData(data);
        pos = 2;
        d->cont2isFree = false;
        d->cont2mod=mod;
        d->nb_seq++;
        checkNbSequences();
    }
    if(d->cont2mod==mod)
    {
        d->containerImage2->removeView();
        d->containerImage2->addData(data);
        pos = 2;
        d->cont2isFree = false;
        d->cont2mod=mod;
    }
}

void animaLesionsSegmentation::onT1Dropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }

    d->T1Data = medDataManager::instance()->retrieveData(index);
    d->T1ImageData = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->T1isSet=true;

    if(d->chooseT1->getCheckBox()->isChecked())
    {
        this->setDataInContainer(d->T1Data,d->posT1,"T1");
    }
}

void animaLesionsSegmentation::onT2Dropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->T2Data = medDataManager::instance()->retrieveData(index);
    d->T2ImageData = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->T2isSet=true;

    if(d->chooseT2->getCheckBox()->isChecked())
    {
        this->setDataInContainer(d->T2Data,d->posT2,"T2");
    }
}

void animaLesionsSegmentation::onDPDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }

    d->DPData = medDataManager::instance()->retrieveData(index);
    d->DPImageData = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->DPisSet=true;

    if(d->chooseDP->getCheckBox()->isChecked())
    {
        this->setDataInContainer(d->DPData,d->posDP,"DP");
    }
}

void animaLesionsSegmentation::onFLAIRDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->FLAIRData = medDataManager::instance()->retrieveData(index);
    d->FLAIRImageData = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->FLAIRisSet=true;

    if(d->chooseFLAIR->getCheckBox()->isChecked())
    {
        this->setDataInContainer(d->FLAIRData,d->posFLAIR,"FLAIR");
    }

}

void animaLesionsSegmentation::onT1GdDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->T1GdData = medDataManager::instance()->retrieveData(index);
    d->T1GdImageData = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index) );
    d->T1GdisSet=true;
    if(d->chooseT1Gd->getCheckBox()->isChecked())
    {
        this->setDataInContainer(d->T1GdData,d->posT1Gd,"T1Gd");
    }

}

void animaLesionsSegmentation::onMaskDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }   
    d->maskImageData = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->MaskisSet=true;
}

void animaLesionsSegmentation::onManuSegMaskDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }

    if(d->ManuSegMaskisSet) // first remove form the view if already set before
    {
        medAbstractView *view1 = d->containerImage1->view();
        medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
        if(!imageView1)
            return;

        imageView1->removeData(d->ManuSegMaskData);

        medAbstractView *view2 = d->containerImage2->view();
        medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
        if(!imageView2)
            return;

        imageView2->removeData(d->ManuSegMaskData);

        medAbstractView *view3 = d->containerImage3->view();
        medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
        if(!imageView3)
            return;

        imageView3->removeData(d->ManuSegMaskData);

    }

    d->ManuSegMask = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->ManuSegMaskisSet=true;

    d->containerImage1->addData(medDataManager::instance()->retrieveData(index));
    d->containerImage2->addData(medDataManager::instance()->retrieveData(index));
    d->containerImage3->addData(medDataManager::instance()->retrieveData(index));

    d->ManuSegMaskData = medDataManager::instance()->retrieveData(index);
}

void animaLesionsSegmentation::onExternalMaskDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }

    if(d->ExternalMaskisSet) // first remove form the view if already set before
    {
        medAbstractView *view1 = d->containerImage1->view();
        medAbstractImageView * imageView1 = dynamic_cast<medAbstractImageView *>(view1);
        if(!imageView1)
            return;

        imageView1->removeData(d->ExternalMaskData);

        medAbstractView *view2 = d->containerImage2->view();
        medAbstractImageView * imageView2 = dynamic_cast<medAbstractImageView *>(view2);
        if(!imageView2)
            return;

        imageView2->removeData(d->ExternalMaskData);

        medAbstractView *view3 = d->containerImage3->view();
        medAbstractImageView * imageView3 = dynamic_cast<medAbstractImageView *>(view3);
        if(!imageView3)
            return;

        imageView3->removeData(d->ExternalMaskData);
    }

    d->ExternalMask = dynamic_cast <medAbstractImageData *> ( medDataManager::instance()->retrieveData(index));
    d->ExternalMaskisSet=true;

    d->containerImage1->addData(medDataManager::instance()->retrieveData(index));
    d->containerImage2->addData(medDataManager::instance()->retrieveData(index));
    d->containerImage3->addData(medDataManager::instance()->retrieveData(index));

    d->ExternalMaskData = medDataManager::instance()->retrieveData(index);
}

QList<medAbstractParameter*> animaLesionsSegmentation::parameters()
{
    return d->parameters;
}

bool animaLesionsSegmentation::isInteractive()
{
    return false;
}

void animaLesionsSegmentation::run()
{
    medRunnableProcess *runable = new medRunnableProcess(this, this->name());
    runable->start();
}

int animaLesionsSegmentation::update()
{
    std::cout << "tour: " << d->tour << std::endl;
    d->tour++;

    typedef itk::Image <float,3> InputImageTypeF;
    typedef InputImageTypeF::Pointer InputImagePointerF;

    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef InputImageTypeUC::Pointer InputImagePointerUC;

    unsigned char sourcesLabel = 255;
    unsigned char sinksLabel = 2;
    typedef itk::BinaryThresholdImageFilter<InputImageTypeUC, InputImageTypeUC > BinaryFilterType;
    typedef itk::MaximumImageFilter<InputImageTypeUC, InputImageTypeUC, InputImageTypeUC> MaximumFilterType;

    // Create instance of segmentation filter
    typedef anima::SegmentationFilter<InputImageTypeF,InputImageTypeUC>  FilterTypeSeg;
    FilterTypeSeg::Pointer segFilter = FilterTypeSeg::New();

    InputImagePointerF inputT1 = NULL;
    InputImagePointerF inputT2 = NULL;
    InputImagePointerF inputDP = NULL;
    InputImagePointerF inputFLAIR = NULL;
    InputImagePointerF inputT1Gd = NULL;

    InputImagePointerUC brainMask = NULL;

    InputImagePointerUC ManuSegMask = NULL;
    InputImagePointerUC ExternalMask = NULL;


    if(!d->MaskisSet)
    {
        return(1);
    }

    if((d->enableAuto->getCheckBox()->isChecked()) && d->nb_seq<3)
    {
        return(1);
    }

    if(d->useSpectralGrad->getCheckBox()->isChecked() && d->nb_seq<3)
    {
        return(1);
    }

    if( (d->enableAuto->getCheckBox()->isChecked()) && (!d->T1isSet))
    {
        return(1);
    }

    if((d->enableAuto->getCheckBox()->isChecked()) && (d->init->getComboBox()->currentIndex()==1) && (!d->DPisSet))
    {
        return(1);
    }

    if((d->enableAuto->getCheckBox()->isChecked()) && (d->init->getComboBox()->currentIndex()==2) && (!d->FLAIRisSet))
    {
        return(1);
    }

   /* if(  d->enableManu->getCheckBox()->isChecked() && ( !d->ExternalMaskisSet && !d->ManuSegMaskisSet ) )
    {
        return(1);
    }*/


    brainMask = this->createInputMasks(d->maskImageData);
    segFilter->SetMask( brainMask );

    if(d->T1isSet)
    {
        inputT1 = this->createInputImages(d->T1ImageData);
        segFilter->SetInputImageT1( inputT1 );
    }
    if(d->T2isSet)
    {
        inputT2 = this->createInputImages(d->T2ImageData);
        segFilter->SetInputImageT2( inputT2 );
    }
    if(d->DPisSet)
    {
        inputDP = this->createInputImages(d->DPImageData);
        segFilter->SetInputImageDP( inputDP );
    }

    if(d->FLAIRisSet)
    {
        inputFLAIR = this->createInputImages(d->FLAIRImageData);
        segFilter->SetInputImageFLAIR( inputFLAIR );
    }

    if(d->T1GdisSet)
    {
        inputT1Gd = this->createInputImages(d->T1GdImageData);
        segFilter->SetInputImageT1Gd( inputT1Gd );
    }

    InputImagePointerUC inputSourcesMaskManu  = InputImageTypeUC::New();
    inputSourcesMaskManu->SetRegions(brainMask->GetLargestPossibleRegion());
    inputSourcesMaskManu->CopyInformation(brainMask);
    inputSourcesMaskManu->Allocate();
    inputSourcesMaskManu->FillBuffer(0);

    InputImagePointerUC inputSinksMaskManu  = InputImageTypeUC::New();
    inputSinksMaskManu->SetRegions(brainMask->GetLargestPossibleRegion());
    inputSinksMaskManu->CopyInformation(brainMask);
    inputSinksMaskManu->Allocate();
    inputSinksMaskManu->FillBuffer(0);

    InputImagePointerUC inputSourcesMaskExt  = InputImageTypeUC::New();
    inputSourcesMaskExt->SetRegions(brainMask->GetLargestPossibleRegion());
    inputSourcesMaskExt->CopyInformation(brainMask);
    inputSourcesMaskExt->Allocate();
    inputSourcesMaskExt->FillBuffer(0);

    InputImagePointerUC inputSinksMaskExt  = InputImageTypeUC::New();
    inputSinksMaskExt->SetRegions(brainMask->GetLargestPossibleRegion());
    inputSinksMaskExt->CopyInformation(brainMask);
    inputSinksMaskExt->Allocate();
    inputSinksMaskExt->FillBuffer(0);

    if(d->ManuSegMaskisSet)
    {
        ManuSegMask = this->createInputMasks(d->ManuSegMask);
        BinaryFilterType::Pointer binaryFilterSources = BinaryFilterType::New();
        binaryFilterSources->SetInput( ManuSegMask );
        binaryFilterSources->SetOutsideValue( 0 );
        binaryFilterSources->SetInsideValue( 1 );
        binaryFilterSources->SetLowerThreshold( sourcesLabel );
        binaryFilterSources->SetUpperThreshold( sourcesLabel );
        binaryFilterSources->Update();
        inputSourcesMaskManu = binaryFilterSources->GetOutput();

        BinaryFilterType::Pointer binaryFilterSinks = BinaryFilterType::New();
        binaryFilterSinks->SetInput( ManuSegMask );
        binaryFilterSinks->SetOutsideValue( 0 );
        binaryFilterSinks->SetInsideValue( 1 );
        binaryFilterSinks->SetLowerThreshold( sinksLabel );
        binaryFilterSinks->SetUpperThreshold( sinksLabel );
        binaryFilterSinks->Update();
        inputSinksMaskManu = binaryFilterSinks->GetOutput();

    }
    if(d->ExternalMaskisSet)
    {
        ExternalMask = this->createInputMasks(d->ExternalMask);
        BinaryFilterType::Pointer binaryFilterSources = BinaryFilterType::New();
        binaryFilterSources->SetInput( ExternalMask );
        binaryFilterSources->SetOutsideValue( 0 );
        binaryFilterSources->SetInsideValue( 1 );
        binaryFilterSources->SetLowerThreshold( sourcesLabel );
        binaryFilterSources->SetUpperThreshold( sourcesLabel );
        binaryFilterSources->Update();
        inputSourcesMaskExt = binaryFilterSources->GetOutput();

        BinaryFilterType::Pointer binaryFilterSinks = BinaryFilterType::New();
        binaryFilterSinks->SetInput( ExternalMask );
        binaryFilterSinks->SetOutsideValue( 0 );
        binaryFilterSinks->SetInsideValue( 1 );
        binaryFilterSinks->SetLowerThreshold( sinksLabel );
        binaryFilterSinks->SetUpperThreshold( sinksLabel );
        binaryFilterSinks->Update();
        inputSinksMaskExt = binaryFilterSinks->GetOutput();

    }

    if(d->ExternalMaskisSet || d->ManuSegMaskisSet) //&& images valid avec au moins 1 et 2 tags
    {
        MaximumFilterType::Pointer maximumFilterSources = MaximumFilterType::New();
        maximumFilterSources->SetInput(0, inputSourcesMaskManu);
        maximumFilterSources->SetInput(1, inputSourcesMaskExt);
        maximumFilterSources->Update();

        // If algo already run, use results of GC as entry for sources
        MaximumFilterType::Pointer maximumFilterSources2 = MaximumFilterType::New();
        if(d->tour>1)
        {
            maximumFilterSources2->SetInput(0, d->LesionsSeg);
            maximumFilterSources2->SetInput(1, maximumFilterSources->GetOutput() );
            maximumFilterSources2->Update();
            segFilter->SetSourcesMask(maximumFilterSources2->GetOutput());
        }
        else
        {
            segFilter->SetSourcesMask(maximumFilterSources->GetOutput());
        }

        MaximumFilterType::Pointer maximumFilterSinks = MaximumFilterType::New();
        maximumFilterSinks->SetInput(0, inputSinksMaskManu);
        maximumFilterSinks->SetInput(1, inputSinksMaskExt);
        maximumFilterSinks->Update();
        segFilter->SetSinksMask(maximumFilterSinks->GetOutput());

        //TODO: check if there is at least one sources pixels and one sinks pixel

    }

    // Set parameters
    segFilter->SetSegAutoEnable( d->enableAuto->getCheckBox()->isChecked() );
    segFilter->SetSegManuEnable( d->enableManu->getCheckBox()->isChecked() );
    segFilter->SetVerbose(true);
    segFilter->SetNumberOfThreads( d->threads->value() );

    segFilter->SetUseT2( d->T2isSet );
    segFilter->SetUseDP( d->DPisSet );
    segFilter->SetUseFLAIR( d->FLAIRisSet );

    segFilter->SetInitMethodType( d->init->getComboBox()->currentIndex() );
    segFilter->SetRejRatioHierar( 0.01 );

    segFilter->SetAlgoEMType( d->algoEM->getComboBox()->currentIndex() );
    segFilter->SetEmIter( d->emIter->value() );
    segFilter->SetMinDistance( d->minDistance->value() );

    segFilter->SetRejRatio( d->rejRatio->value() );
    segFilter->SetEmIter_concentration( d->emIterConcentration->value() );
    segFilter->SetEM_before_concentration( d->emBeforeConcentration->getCheckBox()->isChecked() );

    segFilter->SetMahalanobisTh( d->mahaDist->value() );
    segFilter->SetFuzzy( !d->strem->getRadioButton()->isChecked() );
    segFilter->SetFuzzyRuleMin( d->fuzzyMin->value() );
    segFilter->SetFuzzyRuleMax( d->fuzzyMax->value() );

    segFilter->SetUseSpecGrad( d->useSpectralGrad->getCheckBox()->isChecked() );
    segFilter->SetMultiVarSources( d->multiVarSources->value() );
    segFilter->SetMultiVarSinks( d->multiVarSinks->value() );
    segFilter->SetAlpha( d->alpha->value() );
    segFilter->SetSigma( d->sigma->value() );
    segFilter->SetNbItGc( d->NbItGc->value() );

    segFilter->SetIntensityRule( d->useIntensityRule->getCheckBox()->isChecked() );
    segFilter->SetIntensityT2( d->T2intensityFactor->value() );
    segFilter->SetIntensityDP( d->DPintensityFactor->value() );
    segFilter->SetIntensityFLAIR( d->FLAIRintensityFactor->value() );
    segFilter->SetRemoveBorder( d->removeBorderLesions->getCheckBox()->isChecked() );
    segFilter->SetMinGMSize( d->minGMSize->value() );
    segFilter->SetMinLesionSize( d->minLesionsSize->value() );

    if(d->FiniteModelSolution.size()==3 && d->useFormerSegModel->getCheckBox()->isChecked())
    {
        segFilter->SetSolution(d->FiniteModelSolution);
    }

    double tol = 0.00001;
    segFilter->SetTol(tol);

    // Run segmentation filter
    time_t t1 = clock();
    try
    {
        segFilter->Update();
        //segFilter->WriteOutputs();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (Update Segmentation)" << err.what();
        return(1);
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;

    // save solution of automatic segmenation in case we need to relaunch the seg with additional seed
    // FiniteModelSolution cointains the estimation of the NABT model (mean and covar matrix)
    // this allow to save computation time (EM is not performed) and avoid differences due to random intialisation
    if(d->enableAuto->getCheckBox()->isChecked())
    {
        d->FiniteModelSolution = segFilter->GetSolution();
    }

    // save number lesion load
    d->lesionLoad = segFilter->GetLesionLoad();
    d->lesionLoadVector = segFilter->GetLesionLoadVector();

    QString seriesDescriptionLesions, seriesDescriptionCSF, seriesDescriptionGM, seriesDescriptionWM;
    QString SeriesDescription = d->parent->input<medAbstractData>(0)->metadata ( medMetaDataKeys::SeriesDescription.key() );

    d->LesionsSeg = segFilter->GetOutputLesions();
    d->outputLesions->setData ( segFilter->GetOutputLesions() );
    seriesDescriptionLesions += "Lesions " + SeriesDescription;
    d->outputLesions->addMetaData ( medMetaDataKeys::SeriesDescription.key(), seriesDescriptionLesions );

    if(d->enableAuto->getCheckBox()->isChecked())
    {

        d->outputCSF->setData ( segFilter->GetOutputCSF() );
        seriesDescriptionCSF += "CSF " + SeriesDescription;
        d->outputCSF->addMetaData ( medMetaDataKeys::SeriesDescription.key(), seriesDescriptionCSF );

        d->outputGM->setData ( segFilter->GetOutputGM() );
        seriesDescriptionGM += "GM " + SeriesDescription;
        d->outputGM->addMetaData ( medMetaDataKeys::SeriesDescription.key(), seriesDescriptionGM );

        d->outputWM->setData ( segFilter->GetOutputWM() );
        seriesDescriptionWM += "WM " + SeriesDescription;
        d->outputWM->addMetaData ( medMetaDataKeys::SeriesDescription.key(), seriesDescriptionWM );
    }

    return(0);
}

/*medAbstractData * animaLesionsSegmentation::output()
{
    return d->output; 
}*/

/*void animaLesionsSegmentation::emitProgressed(int progression)
{
    emit progressed(progression);
}*/

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaLesionsSegmentation(void)
{
    return new animaLesionsSegmentation;
}

itk::Image <unsigned char,3>::Pointer animaLesionsSegmentation::createInputMasks(medAbstractImageData *medInput)
{
    QString type = QString (medInput->identifier());

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;

    // Rescale image
    itk::Image <unsigned char ,3>::Pointer inputUC = itk::Image <unsigned char ,3>::New();

    unsigned char valMinInput = std::numeric_limits<unsigned char >::min();
    unsigned char valMaxInput = std::numeric_limits<unsigned char >::max();

    if ( type == "medItkChar3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
        qDebug() << "Mask rescale C" ;
    }
    else if ( type == "medItkUChar3ImageData" )
    {
        inputUC = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
         qDebug() << "Mask rescale UC" ;
    }
    else if ( type == "medItkShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale S" ;
    }
    else if ( type == "medItkUShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale US" ;
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale Int" ;
    }
    else if ( type == "medItkUInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale UInt" ;
    }
    else if ( type == "itkDataImageLong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale Long" ;
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale ULong" ;
    }
    else if ( type == "medItkFloat3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeF,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeF::Pointer input = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale Float" ;

    }
    else if ( type == "medItkDouble3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
         qDebug() << "Mask rescale double" ;
    }
    else
    {
        qDebug() << "invalid data";
        return NULL;
    }

    return inputUC;
}

itk::Image <float,3>::Pointer animaLesionsSegmentation::createInputImages(medAbstractImageData *medInput)
{
    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (medInput->identifier());

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;


    // Rescale image
    itk::Image <float,3>::Pointer inputF = itk::Image <float,3>::New();

    float valMinInput = std::numeric_limits<float>::min();
    float valMaxInput = std::numeric_limits<float>::max();

    if ( type == "medItkChar3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUChar3ImageData" )
    {

        typedef itk::RescaleIntensityImageFilter<InputImageTypeUC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUC::Pointer input = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkFloat3ImageData" )
    {
        inputF = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "medItkDouble3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else
    {
        qDebug() << "invalid data";
        return NULL;
    }

    return inputF;

}


// -------------------------------- active / desactive buttons
void animaLesionsSegmentation::ChangeAutomaticState(bool state)
{
    // auto enable
    if(state==true)
    {
        d->NABTGroupBox->setEnabled(true);
        d->DetectionGroupBox->setEnabled(true);
        if(d->strem->getCheckBox()->isChecked())
        {
            d->gcGroupBox->setDisabled(true);
        }
    }

    // auto disable
    if(state==false)
    {
        d->NABTGroupBox->setEnabled(false);
        d->DetectionGroupBox->setEnabled(false);
        d->enableManu->getCheckBox()->setChecked(true);
        d->gcGroupBox->setEnabled(true);
    }
}

void animaLesionsSegmentation::ChangeManuState(bool state)
{
    // manu enable
    if(state==true)
    {
        d->multiVarSources->getSpinBox()->setDisabled(false);
        d->multiVarSinks->getSpinBox()->setDisabled(false);
        d->ExternalMaskParameter->getDropSite()->setDisabled(false);
        d->ManuSegMaskParameter->getDropSite()->setDisabled(false);
    }

    // manu disable
    if(state==false)
    {
        d->enableAuto->getCheckBox()->setChecked(true);
        d->multiVarSources->getSpinBox()->setDisabled(true);
        d->multiVarSinks->getSpinBox()->setDisabled(true);
        d->ExternalMaskParameter->getDropSite()->setDisabled(true);
        d->ManuSegMaskParameter->getDropSite()->setDisabled(true);
    }
}

void animaLesionsSegmentation::CheckedStrem(bool checked)
{
    if(checked==true)
    {
        d->gcGroupBox->setEnabled(false);
        d->fuzzy->getRadioButton()->setChecked(false);
        d->fuzzyMin->getSpinBox()->setDisabled(true);
        d->fuzzyMax->getSpinBox()->setDisabled(true);
        d->mahaDist->getSpinBox()->setEnabled(true);
    }
}
void animaLesionsSegmentation::CheckedFuzzy(bool checked)
{
    if(checked==true)
    {
        d->gcGroupBox->setEnabled(true);
        d->strem->getRadioButton()->setChecked(false);
        d->fuzzyMin->getSpinBox()->setDisabled(false);
        d->fuzzyMax->getSpinBox()->setDisabled(false);
        d->mahaDist->getSpinBox()->setEnabled(false);
    }
}

void animaLesionsSegmentation::updateRejectionFeatures(int index)
{
    if(index==0)
    {
        d->rejRatio->getSpinBox()->setEnabled(false);
        d->emIterConcentration->getSpinBox()->setEnabled(false);
        d->emBeforeConcentration->getCheckBox()->setEnabled(false);
    }
    else
    {
        d->rejRatio->getSpinBox()->setEnabled(true);
        d->emIterConcentration->getSpinBox()->setEnabled(true);
        d->emBeforeConcentration->getCheckBox()->setEnabled(true);
    }
}

void animaLesionsSegmentation::ChangedIntensityState(bool state)
{
    d->T2intensityFactor->getSpinBox()->setEnabled(state);
    d->DPintensityFactor->getSpinBox()->setEnabled(state);
    d->FLAIRintensityFactor->getSpinBox()->setEnabled(state);
}





