// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaLesionsSegmentation.h"
#include "animaLesionsSegmentationToolBox.h"

#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>

#include <medMetaDataKeys.h>

#include <itkImageFileWriter.h>
#include <animaNonLocalMeansImageFilter.h>
#include <animaNonLocalMeansTemporalImageFilter.h>

#include <itkCastImageFilter.h>
#include <itkImageFileWriter.h>
#include "animaSegmentationFilter.h"
#include "itkRescaleIntensityImageFilter.h"
#include "animaFiniteModel.h"
#include "time.h"

class animaLesionsSegmentationPrivate
{
public:

    animaLesionsSegmentationToolBox *toolbox;

    dtkSmartPointer <medAbstractImageData> output;

    dtkSmartPointer <medAbstractImageData> mask;
    dtkSmartPointer <medAbstractImageData> DP;
    dtkSmartPointer <medAbstractImageData> T2;
    dtkSmartPointer <medAbstractImageData> T1;
    dtkSmartPointer <medAbstractImageData> FLAIR;
    dtkSmartPointer <medAbstractImageData> T1Gd;

    dtkSmartPointer <medAbstractImageData> AtlasCSF;
    dtkSmartPointer <medAbstractImageData> AtlasGM;
    dtkSmartPointer <medAbstractImageData> AtlasWM;

    dtkSmartPointer <medAbstractImageData> SourcesMask;
    dtkSmartPointer <medAbstractImageData> SinksMask;


    animaLesionsSegmentation *parent;

    bool segAutoEnable;
    bool segManuEnable;
    unsigned int numberOfThreads;
    unsigned int initMethod;
    double rejRatioHierar;
    unsigned int emAlgo;
    int emIter;
    double minDistance;
    double rejRatio;
    int emIter_concentration;
    bool em_before_concentration;
    bool useStrem;
    double maha;
    double fuzzyRuleMin;
    double fuzzyRuleMax;
    QString readSolutionFile;
    QString writeSolutionFile;
    bool useT2;
    bool useDP;
    bool useFLAIR;
    bool useSpecGrad;
    int TLinkMode;
    float multiVarSources;
    float multiVarSinks;
    float sigma;
    float alpha;
    QString matrixGrad;
    float minLesionSize;
    float minGMSize;
    bool removeBorder;
    bool intensityRule;
    double intensityT2;
    double intensityDP;
    double intensityFLAIR;
    QString filenameLoad;
    float lesionLoad;
    std::vector<float> lesionLoadVector;

    anima::FiniteModel FiniteModelSolution;
    bool useFormerSegModel;

};

// /////////////////////////////////////////////////////////////////
// animaLesionSegmentation
// /////////////////////////////////////////////////////////////////


animaLesionsSegmentation::animaLesionsSegmentation(): medAbstractSegmentationProcess(), d(new animaLesionsSegmentationPrivate)
{
    d->parent = this;

    d->segAutoEnable = true;
    d->segManuEnable = false;
    d->numberOfThreads = 2;
    d->initMethod = 2;
    d->rejRatioHierar = 0.01;
    d->emAlgo = 2;
    d->emIter = 100;
    d->minDistance = 0.0001;
    d->rejRatio = 0.2;
    d->emIter_concentration = 100;
    d->em_before_concentration = false;
    d->useStrem = false;
    d->maha = 0.4;
    d->fuzzyRuleMin = 2;
    d->fuzzyRuleMax = 3;
    d->useT2 = false;
    d->useDP = false;
    d->useFLAIR = false;
    d->useSpecGrad = true;
    d->TLinkMode = 0;
    d->multiVarSources = 1;
    d->multiVarSinks = 1;
    d->sigma = 0.6;
    d->alpha = 10;
    d->minLesionSize = 0;
    d->minGMSize = 0;
    d->removeBorder = false;
    d->intensityRule = false;
    d->intensityT2 = 0;
    d->intensityDP = 0;
    d->intensityFLAIR = 0;
    d->useFormerSegModel = false;

}

animaLesionsSegmentation::~animaLesionsSegmentation(void)
{
}

bool animaLesionsSegmentation::registered()
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaLesionsSegmentation", createanimaLesionsSegmentation, "SemiAutomaticSeg");
}

QString animaLesionsSegmentation::description() const
{
    return "animaLesionsSegmentation";
}


/// TODO mettre la liste des parameters et au lieu de surcharger la method toolbox()
QList<medAbstractParameter*> animaLesionsSegmentation::parameters()
{
    return QList<medAbstractParameter*>();
}

bool animaLesionsSegmentation::isInteractive()
{
    return false;
}

medToolBox* animaLesionsSegmentation::toolbox()
{
    d->toolbox = new animaLesionsSegmentationToolBox;
    connect(d->toolbox, SIGNAL(runRequest()), this, SLOT(run()));
    return d->toolbox;
}

void animaLesionsSegmentation::run()
{
    medRunnableProcess *runable = new medRunnableProcess(this, this->name());
    runable->start();
}

int animaLesionsSegmentation::update()
{

    //set manual masks: from database + segmented from paint segmentation
    //todo: AND

    typedef itk::Image <float,3> InputImageTypeF;
    typedef InputImageTypeF::Pointer InputImagePointerF;

    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef InputImageTypeUC::Pointer InputImagePointerUC;

    // Create instance of segmentation filter
    typedef anima::SegmentationFilter<InputImageTypeF,InputImageTypeF>  FilterTypeSeg;
    FilterTypeSeg::Pointer segFilter = FilterTypeSeg::New();

    InputImagePointerF inputT1 = NULL;
    InputImagePointerF inputT2 = NULL;
    InputImagePointerF inputDP = NULL;
    InputImagePointerF inputFLAIR = NULL;
    InputImagePointerF inputT1Gd = NULL;

    InputImagePointerUC brainMask = NULL;

    InputImagePointerF inputAtlasCSF = NULL;
    InputImagePointerF inputAtlasGM = NULL;
    InputImagePointerF inputAtlasWM = NULL;

    InputImagePointerUC inputSourcesMask = NULL;
    InputImagePointerUC inputSinksMask = NULL;


    d->T1 = dynamic_cast <medAbstractImageData *> (d->toolbox->getT1());
    d->T2 = dynamic_cast <medAbstractImageData *> (d->toolbox->getT2());
    d->DP = dynamic_cast <medAbstractImageData *> (d->toolbox->getDP());

    d->FLAIR = dynamic_cast <medAbstractImageData *> (d->toolbox->getFLAIR());
    d->T1Gd = dynamic_cast <medAbstractImageData *> (d->toolbox->getT1Gd());
    d->mask = dynamic_cast <medAbstractImageData *> (d->toolbox->getMask());


    if(!(d->T1.isNull()))
    {
        inputT1 = this->createInputImages(d->T1);
        segFilter->SetInputImageT1( inputT1 );
        qDebug()<<"T1 set";
    }
    if(!(d->T2.isNull()))
    {
        inputT2 = this->createInputImages(d->T2);
        segFilter->SetInputImageT2( inputT2 );
        qDebug()<<"t2 set";
    }
    if(!(d->DP.isNull()))
    {
        inputDP = this->createInputImages(d->DP);
        segFilter->SetInputImageDP( inputDP );
        qDebug()<<"dp set";
    }
    if(!(d->FLAIR.isNull()))
    {
        inputFLAIR = this->createInputImages(d->FLAIR);
        segFilter->SetInputImageFLAIR( inputFLAIR );
    }
    if(!(d->T1Gd.isNull()))
    {
        inputT1Gd = this->createInputImages(d->T1Gd);
        segFilter->SetInputImageT1Gd( inputT1Gd );
    }
    if(!(d->mask.isNull()))
    {
        brainMask = this->createInputMasks(d->mask);
        segFilter->SetMask( brainMask );
        qDebug()<<"mask set";
    }

    if(!(d->AtlasCSF.isNull()))
    {
        inputAtlasCSF = this->createInputImages(d->AtlasCSF);
        segFilter->SetInputCSFAtlas( inputAtlasCSF );
    }
    if(!(d->AtlasGM.isNull()))
    {
        inputAtlasGM = this->createInputImages(d->AtlasGM);
        segFilter->SetInputGMAtlas( inputAtlasGM );
    }
    if(!(d->AtlasWM.isNull()))
    {
        inputAtlasWM = this->createInputImages(d->AtlasWM);
        segFilter->SetInputWMAtlas( inputAtlasWM );
    }

    if(!(d->SourcesMask.isNull()))
    {
        inputSourcesMask = this->createInputMasks(d->SourcesMask);
        segFilter->SetSourcesMask( inputSourcesMask );
    }
    if(!(d->SinksMask.isNull()))
    {
        inputSinksMask = this->createInputMasks(d->SinksMask);
        segFilter->SetSinksMask( inputSinksMask );
    }

    d->segAutoEnable = d->toolbox->getEnableAuto();
    d->segManuEnable = d->toolbox->getEnableManu();
    d->numberOfThreads = d->toolbox->getNumberOfThreads();
    d->initMethod = d->toolbox->getInitMethod();
    d->rejRatioHierar = d->toolbox->getRejRatioHierar();
    d->emAlgo = d->toolbox->getEmAlgo();
    d->emIter = d->toolbox->getEmIter();
    d->minDistance = d->toolbox->getMinDistance();
    d->rejRatio = d->toolbox->getRejRatio();
    d->emIter_concentration = d->toolbox->getEmIter_concentration();
    d->em_before_concentration = d->toolbox->getEm_before_concentration();
    d->useStrem = d->toolbox->getUseStrem();
    d->maha = d->toolbox->getMaha();
    d->fuzzyRuleMin = d->toolbox->getFuzzyRuleMin();
    d->fuzzyRuleMax = d->toolbox->getFuzzyRuleMax();
    //void getUseT2();
    //void getUseDP();
    //void getUseFLAIR();
    d->useSpecGrad = d->toolbox->getUseSpecGrad();
    // = d->toolbox->getTLinkMode(int TLinkMode);
    d->multiVarSources = d->toolbox->getMultiVarSources();
    d->multiVarSinks = d->toolbox->getMultiVarSinks();
    d->sigma = d->toolbox->getSigma();
    d->alpha = d->toolbox->getAlpha();
    d->minLesionSize = d->toolbox->getMinLesionSize();
    d->minGMSize = d->toolbox->getMinGMSize();
    d->removeBorder = d->toolbox->getRemoveBorder();
    d->intensityRule  = d->toolbox->getIntensityRule();
    d->intensityT2 = d->toolbox->getIntensityT2();
    d->intensityDP = d->toolbox->getIntensityDP();
    d->intensityFLAIR = d->toolbox->getIntensityFLAIR();
    d->useFormerSegModel = d->toolbox->getUseFormerSegModel();

    // Set parameters
    segFilter->SetSegAutoEnable( d->segAutoEnable );
    segFilter->SetSegManuEnable( d->segManuEnable );
    segFilter->SetVerbose(false);
    segFilter->SetNumberOfThreads( d->numberOfThreads );

    segFilter->SetUseT2( d->useT2 );
    segFilter->SetUseFLAIR( d->useDP );
    segFilter->SetUseDP( d->useFLAIR );

    segFilter->SetInitMethodType( d->initMethod );
    segFilter->SetRejRatioHierar( d->rejRatioHierar );

    segFilter->SetAlgoEMType( d->emAlgo );
    segFilter->SetEmIter( d->emIter );
    segFilter->SetMinDistance( d->minDistance );

    segFilter->SetRejRatio( d->rejRatio );
    segFilter->SetEmIter_concentration( d->emIter_concentration );
    segFilter->SetEM_before_concentration( d->em_before_concentration );


    segFilter->SetMahalanobisTh( d->maha );
    segFilter->SetFuzzy( !d->useStrem );
    segFilter->SetFuzzyRuleMin( d->fuzzyRuleMin );
    segFilter->SetFuzzyRuleMax( d->fuzzyRuleMax );

    segFilter->SetUseSpecGrad( d->useSpecGrad );
    //segFilter->SetTLinkMode( d->TLinkMode );
    segFilter->SetMultiVarSources( d->multiVarSources );
    segFilter->SetMultiVarSinks( d->multiVarSinks );
    segFilter->SetAlpha( d->alpha );
    segFilter->SetSigma( d->sigma );
    //segFilter->SetMatrixGradFilename( matrixGradArg.getValue() );

    segFilter->SetIntensityRule( d->intensityRule );
    segFilter->SetIntensityT2( d->intensityT2 );
    segFilter->SetIntensityDP( d->intensityDP );
    segFilter->SetIntensityFLAIR( d->intensityFLAIR );
    segFilter->SetRemoveBorder( d->removeBorder );
    segFilter->SetMinGMSize( d->minGMSize );
    segFilter->SetMinLesionSize( d->minLesionSize );

    if(d->FiniteModelSolution.size()==3 && d->useFormerSegModel)
    {
        segFilter->SetSolution(d->FiniteModelSolution);
    }

    // Run the segmentation
    time_t t1 = clock();
    try
    {
        segFilter->Update();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (Update Segmentation)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;

    // save solution of automatic segmenation in case we need to relaunch the seg with additional seed
    // FiniteModelSolution cointains the estimation of the NABT model (mean and covar matrix)
    // this allow to save computation time (EM is not performed) and avoid diiferences due to random intialisation
    d->FiniteModelSolution = segFilter->GetSolution();

    // save number lesion load to print it
    d->lesionLoad = segFilter->GetLesionLoad();
    d->lesionLoadVector = segFilter->GetLesionLoadVector();

    QString identifier = d->toolbox->getMask()->identifier();
    d->output = dynamic_cast <medAbstractImageData *> (medAbstractDataFactory::instance()->create (identifier));
    d->output->setData(segFilter->GetOutputWholeSeg());

    return(0);
}

medAbstractData * animaLesionsSegmentation::output()
{
    return d->output;
}

/*void animaLesionsSegmentation::emitProgressed(int progression)
{
    emit progressed(progression);
}*/

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaLesionsSegmentation(void)
{
    return new animaLesionsSegmentation;
}

itk::Image <unsigned char,3>::Pointer animaLesionsSegmentation::createInputMasks(medAbstractImageData *medInput)
{
    QString type = QString (medInput->identifier());

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;

    // Rescale image
    itk::Image <unsigned char ,3>::Pointer inputUC = itk::Image <unsigned char ,3>::New();

    unsigned char valMinInput = std::numeric_limits<unsigned char >::min();
    unsigned char valMaxInput = std::numeric_limits<unsigned char >::max();

    if ( type == "medItkChar3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUChar3ImageData" )
    {
        inputUC = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "medItkShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageLong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkFloat3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeF,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeF::Pointer input = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();

    }
    else if ( type == "medItkDouble3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeUC> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputUC = rescaleFilter->GetOutput();
    }
    else
    {
        qDebug() << "invalid data";
        return NULL;
    }

    return inputUC;
}

itk::Image <float,3>::Pointer animaLesionsSegmentation::createInputImages(medAbstractImageData *medInput)
{
    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (medInput->identifier());

    // typedef
    typedef itk::Image <char,3> InputImageTypeC;
    typedef itk::Image <unsigned char,3> InputImageTypeUC;
    typedef itk::Image <short,3> InputImageTypeS;
    typedef itk::Image <unsigned short,3> InputImageTypeUS;
    typedef itk::Image <int,3> InputImageTypeI;
    typedef itk::Image <unsigned int,3> InputImageTypeUI;
    typedef itk::Image <long,3> InputImageTypeL;
    typedef itk::Image <unsigned long,3> InputImageTypeUL;
    typedef itk::Image <float,3> InputImageTypeF;
    typedef itk::Image <double,3> InputImageTypeD;


    // Rescale image
    itk::Image <float,3>::Pointer inputF = itk::Image <float,3>::New();

    float valMinInput = std::numeric_limits<float>::min();
    float valMaxInput = std::numeric_limits<float>::max();

    if ( type == "medItkChar3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeC::Pointer input = dynamic_cast<InputImageTypeC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUChar3ImageData" )
    {

        typedef itk::RescaleIntensityImageFilter<InputImageTypeUC,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUC::Pointer input = dynamic_cast<InputImageTypeUC *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeS::Pointer input = dynamic_cast<InputImageTypeS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUShort3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUS,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUS::Pointer input = dynamic_cast<InputImageTypeUS *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeI::Pointer input = dynamic_cast<InputImageTypeI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkUInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUI,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUI::Pointer input = dynamic_cast<InputImageTypeUI *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkInt3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeL::Pointer input = dynamic_cast<InputImageTypeL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "itkDataImageULong" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeUL,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeUL::Pointer input = dynamic_cast<InputImageTypeUL *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else if ( type == "medItkFloat3ImageData" )
    {
        inputF = dynamic_cast<InputImageTypeF *>((itk::Object*)( medInput->data() ));
    }
    else if ( type == "medItkDouble3ImageData" )
    {
        typedef itk::RescaleIntensityImageFilter<InputImageTypeD,InputImageTypeF> RescaleFilterType;
        RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
        InputImageTypeD::Pointer input = dynamic_cast<InputImageTypeD *>((itk::Object*)( medInput->data() ));
        rescaleFilter->SetInput( input );
        rescaleFilter->SetOutputMinimum( valMinInput );
        rescaleFilter->SetOutputMaximum( valMaxInput );
        rescaleFilter->UpdateLargestPossibleRegion();
        inputF = rescaleFilter->GetOutput();
    }
    else
    {
        qDebug() << "invalid data";
        return NULL;
    }

    return inputF;

}

