// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////


#include "animaLesionsSegmentation.h"
#include "animaLesionsSegmentationToolBox.h"

#include <QtGui>

#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>
#include <dtkCore/dtkSmartPointer.h>

#include <medAbstractView.h>
#include <medRunnableProcess.h>
#include <medJobManager.h>

#include <medToolBoxFactory.h>
#include <medSegmentationSelectorToolBox.h>
#include <medProgressionStack.h>
#include <medPluginManager.h>
#include <medToolBoxTab.h>
#include <medDropSite.h>
#include <medDataIndex.h>
#include <medDataManager.h>

#include <itkMultiThreader.h>



class animaLesionsSegmentationToolBoxPrivate
{
public:

    dtkSmartPointer <animaLesionsSegmentation> process;

    dtkSmartPointer<medAbstractData> maskData;
    dtkSmartPointer<medAbstractData> T1Data;
    dtkSmartPointer<medAbstractData> T2Data;
    dtkSmartPointer<medAbstractData> DPData;
    dtkSmartPointer<medAbstractData> FLAIRData;
    dtkSmartPointer<medAbstractData> T1GdData;

    dtkSmartPointer<medAbstractData> AtlasCSFData;
    dtkSmartPointer<medAbstractData> AtlasGMData;
    dtkSmartPointer<medAbstractData> AtlasWMData;


    QLabel *dataTypeValue;
    QLabel *dataDimensionValue;

    // Output type
    QRadioButton *WholeSeg;
    QRadioButton *LesionSeg;
    QRadioButton *CSFSeg;
    QRadioButton *GMSeg;
    QRadioButton *WMSeg;
    QButtonGroup *OutputTypeGroup;

    QCheckBox *enableAuto;
    QCheckBox *enableManu;

    // NABT estimation
    QComboBox *algoEM;
    QComboBox *init;
    QPushButton *SelectAtlasButton;

    QDoubleSpinBox *emIter;
    QDoubleSpinBox *minDistance;
    QDoubleSpinBox *rejRatio;
    QDoubleSpinBox *emIterConcentration;
    QCheckBox *emBeforeConcentration;

    QButtonGroup *detectionButtonGroup;
    QRadioButton *strem;
    QDoubleSpinBox *mahaDist;
    QRadioButton *fuzzy;
    QDoubleSpinBox *fuzzyMin;
    QDoubleSpinBox *fuzzyMax;

    // Heuristic Rules
    QCheckBox *removeBorderLesions;
    QDoubleSpinBox *wmRatio;
    QDoubleSpinBox *minLesionsSize;
    QDoubleSpinBox * minGMSize;
    QCheckBox *useIntensityRule;
    QDoubleSpinBox *T2intensityFactor;
    QDoubleSpinBox *DPintensityFactor;
    QDoubleSpinBox *FLAIRintensityFactor;

    //Manual
    QPushButton *SelectSourcesButton;
    QPushButton *SelectSinksButton;
    QDoubleSpinBox *multiVarSources;
    QDoubleSpinBox *multiVarSinks;

    //gc
    QDoubleSpinBox *alpha;
    QDoubleSpinBox *sigma;
    QCheckBox *useSpectralGrad;
    QLineEdit *matrixFileEdit;

    //Global Parameters:
    QSpinBox *threads;
    medProgressionStack * progression_stack;

    medDropSite *T1DropSite;
    medDropSite *T2DropSite;
    medDropSite *DPDropSite;

    medDropSite *FLAIRDropSite;
    medDropSite *T1GdDropSite;
    medDropSite *maskDropSite;

    medDataIndex indexT1;
    medDataIndex indexT2;
    medDataIndex indexDP;
    medDataIndex indexFLAIR;
    medDataIndex indexT1Gd;
    medDataIndex indexMask;

    QGroupBox *NABTGroupBox;
    QGroupBox *DetectionGroupBox;
    QGroupBox *gcGroupBox;
    QGroupBox *SeedsGroupBox;
    QGroupBox *globalParametersGroupBox;

    QPushButton *openMatrixFileButton;
    QPushButton *PreviewMultiVarButton;

    bool T1isSet,T2isSet,DPisSet,FLAIRisSet,T1GdisSet,MaskisSet;
};

animaLesionsSegmentationToolBox::animaLesionsSegmentationToolBox(QWidget *parent) : medSegmentationAbstractToolBox(parent), d(new animaLesionsSegmentationToolBoxPrivate)
{
    //Segmentation
    this->setTitle("Lesion Segmentation");
    medToolBoxTab *widget = new medToolBoxTab(this);
    QPushButton *runButton = new QPushButton(tr("Run"), this);

    // progression stack
    d->progression_stack = new medProgressionStack(widget);
    QHBoxLayout *progressStackLayout = new QHBoxLayout;
    progressStackLayout->addWidget(d->progression_stack);


    // Heuristic Rules Parameters
    d->removeBorderLesions = new QCheckBox;
    d->removeBorderLesions->setToolTip("Remove lesions that are not touching the brain mask");
    d->removeBorderLesions->setCheckState(Qt::Unchecked);

    d->wmRatio = new QDoubleSpinBox;
    d->wmRatio->setToolTip("Percentage of white matter that must suround the lesion");
    d->wmRatio->setDecimals(3);
    d->wmRatio->setValue(0.01);
    d->wmRatio->setSingleStep(0.01);
    d->wmRatio->setRange(0,1);

    d->minGMSize = new QDoubleSpinBox;
    d->minGMSize->setToolTip("Minimum gey matter region size");
    d->minGMSize->setDecimals(0);
    d->minGMSize->setValue(3);
    d->minGMSize->setSingleStep(1);
    d->minGMSize->setSuffix(" mm3");

    d->useIntensityRule = new QCheckBox;
    d->useIntensityRule->setToolTip("In T2 image, lesions will have to ...");
    d->useIntensityRule->setCheckState(Qt::Unchecked);

    d->minLesionsSize = new QDoubleSpinBox;
    d->minLesionsSize->setToolTip("Minimum lesion size");
    d->minLesionsSize->setValue(3);
    d->minLesionsSize->setDecimals(0);
    d->minLesionsSize->setSingleStep(1);
    d->minLesionsSize->setSuffix(" mm3");

    d->T2intensityFactor = new QDoubleSpinBox;
    d->T2intensityFactor->setToolTip("T2 intensiy factor");
    d->T2intensityFactor->setValue(2.5);
    d->T2intensityFactor->setDecimals(2);
    d->T2intensityFactor->setSingleStep(0.1);
    d->T2intensityFactor->setDisabled(true);

    d->DPintensityFactor = new QDoubleSpinBox;
    d->DPintensityFactor->setToolTip("DP intensiy factor");
    d->DPintensityFactor->setValue(2.5);
    d->DPintensityFactor->setDecimals(2);
    d->DPintensityFactor->setSingleStep(0.1);
    d->DPintensityFactor->setDisabled(true);

    d->FLAIRintensityFactor = new QDoubleSpinBox;
    d->FLAIRintensityFactor->setToolTip("FLAIR intensiy factor");
    d->FLAIRintensityFactor->setValue(2.5);
    d->FLAIRintensityFactor->setDecimals(2);
    d->FLAIRintensityFactor->setSingleStep(0.1);
    d->FLAIRintensityFactor->setDisabled(true);

    // Heuristic Parameters Layout
    QFormLayout *heuristicLayout = new QFormLayout();
    heuristicLayout->addRow(new QLabel(tr("Remove border lesions"),this),d->removeBorderLesions);
    //heuristicLayout->addRow(new QLabel(tr("WM border ratio"),this),d->wmRatio);
    heuristicLayout->addRow(new QLabel(tr("Min lesion size"),this),d->minLesionsSize);
    heuristicLayout->addRow(new QLabel(tr("Min GM region size"),this),d->minGMSize);
    heuristicLayout->addRow(new QLabel(tr("Intensity rule"),this),d->useIntensityRule);
    heuristicLayout->addRow(new QLabel(tr("T2 multi"),this),d->T2intensityFactor);
    heuristicLayout->addRow(new QLabel(tr("DP multi"),this),d->DPintensityFactor);
    heuristicLayout->addRow(new QLabel(tr("FLAIR multi"),this),d->FLAIRintensityFactor);

    QGroupBox *heuristicGroupBox = new QGroupBox(tr("Heuristic Parameters"));
    heuristicGroupBox->setLayout(heuristicLayout);



    // Main Page
    QPushButton *inputSelectionButton = new QPushButton(tr("Select MRI images"));
    QLabel *inputSelectionLabel = new QLabel(tr("Select MRI images"));
    QHBoxLayout *imagesBoxLayout = new QHBoxLayout();
    imagesBoxLayout->addWidget(inputSelectionLabel);
    imagesBoxLayout->addWidget(inputSelectionButton);

    d->T1DropSite = new medDropSite();
    d->T1DropSite->setText(tr("Drop here T1"));

    d->T2DropSite = new medDropSite();
    d->T2DropSite->setText(tr("Drop here T2"));

    d->DPDropSite = new medDropSite();
    d->DPDropSite->setText(tr("Drop here DP"));

    d->FLAIRDropSite = new medDropSite();
    d->FLAIRDropSite->setText(tr("Drop here FLAIR"));

    d->T1GdDropSite = new medDropSite();
    d->T1GdDropSite->setText(tr("Drop here T1Gd"));

    d->maskDropSite = new medDropSite();
    d->maskDropSite->setText(tr("Drop here the \n 3D brain mask"));

    QHBoxLayout *MRIBox1Layout = new QHBoxLayout();
    MRIBox1Layout->addWidget(d->T1DropSite);
    MRIBox1Layout->addWidget(d->T2DropSite);

    QHBoxLayout *MRIBox2Layout = new QHBoxLayout();
    MRIBox2Layout->addWidget(d->DPDropSite);
    MRIBox2Layout->addWidget(d->FLAIRDropSite);

    QHBoxLayout *MRIBox3Layout = new QHBoxLayout();
    MRIBox3Layout->addWidget(d->T1GdDropSite);
    MRIBox3Layout->addWidget(d->maskDropSite);

    QPushButton *clearImagesButton = new QPushButton(tr("Remove whole images"));

    QVBoxLayout *box1Layout = new QVBoxLayout();
    box1Layout->addLayout(MRIBox1Layout);
    box1Layout->addLayout(MRIBox2Layout);
    box1Layout->addLayout(MRIBox3Layout);
    box1Layout->addWidget(clearImagesButton);



    QGroupBox *ImagesGroupBox = new QGroupBox(tr("Select MRI Images"));
    ImagesGroupBox->setLayout(box1Layout);

    d->OutputTypeGroup = new QButtonGroup();
    d->WholeSeg = new QRadioButton(tr("Whole segmentation"));
    d->LesionSeg = new QRadioButton(tr("Lesion segmentation"));
    d->CSFSeg = new QRadioButton(tr("CSF segmentation"));
    d->GMSeg = new QRadioButton(tr("Grey matter segmentation"));
    d->WMSeg = new QRadioButton(tr("White matter segmentation"));

    d->OutputTypeGroup->addButton(d->WholeSeg);
    d->OutputTypeGroup->setId(d->WholeSeg, 0);
    d->WholeSeg->setChecked(true);

    d->OutputTypeGroup->addButton(d->LesionSeg);
    d->OutputTypeGroup->setId(d->LesionSeg, 1);

    d->OutputTypeGroup->addButton(d->CSFSeg);
    d->OutputTypeGroup->setId(d->CSFSeg, 2);

    d->OutputTypeGroup->addButton(d->GMSeg);
    d->OutputTypeGroup->setId(d->GMSeg, 3);

    d->OutputTypeGroup->addButton(d->WMSeg);
    d->OutputTypeGroup->setId(d->WMSeg, 4);

    QVBoxLayout *OutputTypeLayout = new QVBoxLayout();
    OutputTypeLayout->addWidget(d->WholeSeg);
    OutputTypeLayout->addWidget(d->LesionSeg);
    OutputTypeLayout->addWidget(d->CSFSeg);
    OutputTypeLayout->addWidget(d->GMSeg);
    OutputTypeLayout->addWidget(d->WMSeg);

    QGroupBox *OutputTypeGroupBox = new QGroupBox(tr("Output type"));
    OutputTypeGroupBox->setLayout(OutputTypeLayout);



    // Algo param

    // Auomatic Computation
    d->enableAuto = new QCheckBox;
    d->enableAuto->setToolTip("Enable automatic segmentation");
    d->enableAuto->setCheckState(Qt::Checked);

    QFormLayout *enableAutoLayout = new QFormLayout();
    enableAutoLayout->addRow(new QLabel(tr("Enable automatic computation"),this),d->enableAuto);

    QGroupBox *AutoGroupBox = new QGroupBox(tr("Use automatic seg"));
    AutoGroupBox->setLayout(enableAutoLayout);

    d->init = new QComboBox;
    d->init->setToolTip("Type of initialisation");
    QStringList initList;
    initList << "Atlas" << "Hierar DP" << "Hierar FLAIR";
    d->init->addItems ( initList );

    d->SelectAtlasButton = new QPushButton(tr("Select Atlas"), this);

    QVBoxLayout *initLayout = new QVBoxLayout();
    initLayout->addWidget(d->init);
    initLayout->addWidget(d->SelectAtlasButton);

    d->algoEM = new QComboBox;
    d->algoEM->setToolTip("Type of EM algorithm");
    QStringList algoEMList;
    algoEMList << "EM" << "Celeux REM" << "REM";
    d->algoEM->addItems(algoEMList);
    d->algoEM->setCurrentIndex(2);

    d->emIter = new QDoubleSpinBox;
    d->emIter->setToolTip("xx");
    d->emIter->setDecimals(0);
    d->emIter->setValue(100);
    d->emIter->setSingleStep(1);
    d->emIter->setRange(0,1000);

    d->minDistance = new QDoubleSpinBox;
    d->minDistance->setToolTip("xx");
    d->minDistance->setDecimals(4);
    d->minDistance->setValue(0.0001);
    d->minDistance->setSingleStep(0.0001);
    d->minDistance->setRange(0,1);

    d->rejRatio = new QDoubleSpinBox;
    d->rejRatio->setToolTip("xx");
    d->rejRatio->setDecimals(3);
    d->rejRatio->setValue(0.2);
    d->rejRatio->setSingleStep(0.01);
    d->rejRatio->setRange(0.01,0.49);

    d->emIterConcentration = new QDoubleSpinBox;
    d->emIterConcentration->setToolTip("xx");
    d->emIterConcentration->setDecimals(0);
    d->emIterConcentration->setValue(100);
    d->emIterConcentration->setSingleStep(1);
    d->emIterConcentration->setRange(0,1000);

    d->emBeforeConcentration = new QCheckBox;
    d->emBeforeConcentration->setToolTip("xx");
    d->emBeforeConcentration->setCheckState(Qt::Checked);


    QFormLayout *NABTLayout = new QFormLayout();
    NABTLayout->addRow(new QLabel(tr("EM algorithm type"),this),d->algoEM);
    NABTLayout->addRow(new QLabel(tr("Initialisation"),this),initLayout);
    NABTLayout->addRow(new QLabel(tr("Max iterations"),this),d->emIter);
    NABTLayout->addRow(new QLabel(tr("Minimum distance"),this),d->minDistance);
    NABTLayout->addRow(new QLabel(tr("Rejection ratio"),this),d->rejRatio);
    NABTLayout->addRow(new QLabel(tr("Max iterations between \n concentration steps"),this),d->emIterConcentration);
    NABTLayout->addRow(new QLabel(tr("EM before first concentration"),this),d->emBeforeConcentration);

    d->NABTGroupBox = new QGroupBox(tr("Normal appearing brain tissues estimation"));
    d->NABTGroupBox->setLayout(NABTLayout);




    d->strem = new QRadioButton;
    d->strem->setToolTip("Use strem option. Graph Cut will NOT be used.");
    d->strem->setChecked(false);

    d->mahaDist = new QDoubleSpinBox;
    d->mahaDist->setToolTip("xxxxx");
    d->mahaDist->setValue(2.5);
    d->mahaDist->setDecimals(2);
    d->mahaDist->setSingleStep(0.01);

    d->fuzzy = new QRadioButton;
    d->fuzzy->setToolTip("Use fuzzy option. Graph Cut will be used.");
    d->fuzzy->setChecked(true);

    d->fuzzyMin = new QDoubleSpinBox;
    d->fuzzyMin->setToolTip("xxxxx");
    d->fuzzyMin->setValue(2.5);
    d->fuzzyMin->setDecimals(2);
    d->fuzzyMin->setSingleStep(0.01);

    d->fuzzyMax = new QDoubleSpinBox;
    d->fuzzyMax->setToolTip("xxxx");
    d->fuzzyMax->setValue(2.5);
    d->fuzzyMax->setDecimals(2);
    d->fuzzyMax->setSingleStep(0.01);

    d->detectionButtonGroup = new QButtonGroup();
    d->detectionButtonGroup->addButton(d->strem);
    d->detectionButtonGroup->setId(d->strem, 0);
    d->detectionButtonGroup->addButton(d->fuzzy);
    d->detectionButtonGroup->setId(d->fuzzy, 1);


    QFormLayout *DetectionLayout = new QFormLayout();
    DetectionLayout->addRow(new QLabel(tr("Use Strem"),this),d->strem);
    DetectionLayout->addRow(new QLabel(tr("Mahalanobis distance"),this),d->mahaDist);
    DetectionLayout->addRow(new QLabel(tr("Use Fuzzy rules (graph cut)"),this),d->fuzzy);
    DetectionLayout->addRow(new QLabel(tr("Min fuzzy rule"),this),d->fuzzyMin);
    DetectionLayout->addRow(new QLabel(tr("Max fuzzy rule"),this),d->fuzzyMax);

    d->DetectionGroupBox = new QGroupBox(tr("Detection of candidate lesions"));
    d->DetectionGroupBox->setLayout(DetectionLayout);




    // Graph cut
    /*d->matrixFileEdit = new QLineEdit;
    d->openMatrixFileButton = new QPushButton(tr("..."), this);
    QHBoxLayout *matrixLayout = new QHBoxLayout;
    matrixLayout->addWidget(d->matrixFileEdit);
    matrixLayout->addWidget(d->openMatrixFileButton);*/

    d->alpha = new QDoubleSpinBox;
    d->alpha->setRange(0, 1000);
    d->alpha->setValue(10);

    d->sigma= new QDoubleSpinBox;
    d->sigma->setRange(0, 1000);
    d->sigma->setValue(0.6);
    d->sigma->setSingleStep(0.1);

    d->useSpectralGrad = new QCheckBox;
    d->useSpectralGrad ->setChecked(true);

    QFormLayout *gcBoxLayout = new QFormLayout();
    gcBoxLayout->addRow(new QLabel(tr("Alpha"),this),d->alpha);
    gcBoxLayout->addRow(new QLabel(tr("Sigma"),this),d->sigma);
    gcBoxLayout->addRow(new QLabel(tr("Use Spectral Gradient"),this),d->useSpectralGrad);
    //gcBoxLayout->addRow(new QLabel(tr("Matrix"),this),matrixLayout);

    d->enableManu = new QCheckBox;
    d->enableManu->setToolTip("Enable manual masks as entries");
    d->enableManu->setCheckState(Qt::Unchecked);
    gcBoxLayout->addRow(new QLabel(tr("Enable manual masks"),this),d->enableManu);

    d->SelectSourcesButton = new QPushButton(tr("sources"));
    d->SelectSinksButton = new QPushButton(tr("sinks"));

    d->multiVarSources = new QDoubleSpinBox();
    d->multiVarSources->setToolTip("xx");
    d->multiVarSources->setDecimals(2);
    d->multiVarSources->setValue(1);
    d->multiVarSources->setSingleStep(0.1);
    d->multiVarSources->setRange(0,20);

    d->multiVarSinks = new QDoubleSpinBox();
    d->multiVarSinks->setToolTip("xx");
    d->multiVarSinks->setDecimals(2);
    d->multiVarSinks->setValue(1);
    d->multiVarSinks->setSingleStep(0.1);
    d->multiVarSinks->setRange(0,20);

    d->PreviewMultiVarButton = new QPushButton(tr("Preview variance"));

    d->SelectSourcesButton->setDisabled(true);
    d->SelectSinksButton->setDisabled(true);
    d->multiVarSources->setDisabled(true);
    d->multiVarSinks->setDisabled(true);
    d->PreviewMultiVarButton->setDisabled(true);

    //QFormLayout *SeedsLayout = new QFormLayout();
    gcBoxLayout->addRow(new QLabel(tr("Select sources masks"),this),d->SelectSourcesButton);
    gcBoxLayout->addRow(new QLabel(tr("Select sinks masks"),this),d->SelectSinksButton);
    gcBoxLayout->addRow(new QLabel(tr("Multiply source variance factor"),this),d->multiVarSources);
    gcBoxLayout->addRow(new QLabel(tr("Multiply source variance factor"),this),d->multiVarSinks);
    gcBoxLayout->addRow(new QLabel(tr("Preview variance"),this),d->PreviewMultiVarButton);

    d->gcGroupBox = new QGroupBox(tr("Graph Cut Parameters"));
    d->gcGroupBox->setLayout(gcBoxLayout);


    d->threads = new QSpinBox();
    d->threads->setToolTip("xx");
    d->threads->setValue(8);
    d->threads->setSingleStep(1);
    d->threads->setRange(1,8);

    QFormLayout *globalParamBoxLayout = new QFormLayout();
    globalParamBoxLayout->addRow(new QLabel(tr("Threads"),this),d->threads);
    d->globalParametersGroupBox = new QGroupBox(tr("Global Parameters"));
    d->globalParametersGroupBox->setLayout(globalParamBoxLayout);



    // Set Tabs
    QWidget *header = new QWidget;
    QVBoxLayout *layoutheader = new QVBoxLayout(header);
    layoutheader->addWidget(runButton);
    layoutheader->addWidget(d->progression_stack);

    QWidget *page1 = new QWidget;
    QVBoxLayout *layout1 = new QVBoxLayout(page1);
    layout1->addWidget(ImagesGroupBox);
    layout1->addWidget(heuristicGroupBox);
    layout1->addWidget(OutputTypeGroupBox);

    QWidget *page2 = new QWidget;
    QVBoxLayout *layout2 = new QVBoxLayout(page2);
    layout2->addWidget(AutoGroupBox);
    layout2->addWidget(d->NABTGroupBox);
    layout2->addWidget(d->DetectionGroupBox);
    layout2->addWidget(d->SeedsGroupBox);
    layout2->addWidget(d->gcGroupBox);
    layout2->addWidget(d->globalParametersGroupBox);

    widget->addTab(page1, "Main");
    widget->addTab(page2, "Segmentation Parameters");

    this->addWidget( header );
    this->addWidget( widget );

    d->T1isSet=false;
    d->T2isSet=false;
    d->DPisSet=false;
    d->FLAIRisSet=false;
    d->T1GdisSet=false;
    d->MaskisSet=false;


    //Connect slots
    connect(d->maskDropSite, SIGNAL(objectDropped(const medDataIndex &)),this,SLOT(onMaskDropped(const medDataIndex &)));
    connect(d->T1DropSite, SIGNAL(objectDropped(const medDataIndex &)),this,SLOT(onT1Dropped(const medDataIndex &)));
    connect(d->T2DropSite, SIGNAL(objectDropped(const medDataIndex &)),this,SLOT(onT2Dropped(const medDataIndex &)));

    connect(d->DPDropSite, SIGNAL(objectDropped(const medDataIndex &)),this,SLOT(onDPDropped(const medDataIndex &)));
    connect(d->FLAIRDropSite, SIGNAL(objectDropped(const medDataIndex &)),this,SLOT(onFLAIRDropped(const medDataIndex &)));
    connect(d->T1GdDropSite, SIGNAL(objectDropped(const medDataIndex &)),this,SLOT(onT1GdDropped(const medDataIndex &)));

    connect(clearImagesButton,SIGNAL(clicked()),this,SLOT(onClearImagesClicked()));

    connect(d->enableAuto, SIGNAL(stateChanged(int)),this,SLOT(ChangeAutomaticState(int)));
    connect(d->enableManu, SIGNAL(stateChanged(int)),this,SLOT(ChangeManuState(int)));
    connect(d->strem, SIGNAL(clicked(bool)),this,SLOT(CheckedStrem(bool)));
    connect(d->fuzzy, SIGNAL(clicked(bool)),this,SLOT(CheckedFuzzy(bool)));

    connect(d->init, SIGNAL(currentIndexChanged(int)), this, SLOT(updateAtlasButton(int)));
    connect(d->algoEM, SIGNAL(currentIndexChanged(int)), this, SLOT(updateRejectionFeatures(int)));

    connect(d->useIntensityRule, SIGNAL(stateChanged(int)), this, SLOT(ChangedIntensityState(int)));
    connect(runButton, SIGNAL(clicked()), this, SLOT(run()));

    // Add about plugin
    medPluginManager* pm = medPluginManager::instance();
    dtkPlugin* plugin = pm->plugin ( "animaLesionsSegmentationPlugin" );
    setAboutPluginButton ( plugin );
    setAboutPluginVisibility( true );
}

animaLesionsSegmentationToolBox::~animaLesionsSegmentationToolBox(void)
{
    delete d;
    d = NULL;
}

bool animaLesionsSegmentationToolBox::registered(void)
{
    return medToolBoxFactory::instance()->registerToolBox<animaLesionsSegmentationToolBox>();
}

medAbstractData* animaLesionsSegmentationToolBox::processOutput(void)
{
    if(!d->process)
        return NULL;

    return d->process->output();
}

dtkPlugin* animaLesionsSegmentationToolBox::plugin()
{
    medPluginManager* pm = medPluginManager::instance();
    dtkPlugin* plugin = pm->plugin ( "animaLesionsSegmentationPlugin" );
    return plugin;
}


void animaLesionsSegmentationToolBox::onMaskDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->indexMask = index;
    d->maskDropSite->setPixmap(medDataManager::instance()->thumbnail(index));
    d->MaskisSet=true;
}

void animaLesionsSegmentationToolBox::onT1Dropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->indexT1 = index;
    d->T1DropSite->setPixmap(medDataManager::instance()->thumbnail(index));
    d->T1isSet=true;
}

void animaLesionsSegmentationToolBox::onT2Dropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->indexT2 = index;
    d->T2DropSite->setPixmap(medDataManager::instance()->thumbnail(index));
    d->T2isSet=true;
}

void animaLesionsSegmentationToolBox::onDPDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->indexDP = index;
    d->DPDropSite->setPixmap(medDataManager::instance()->thumbnail(index));
    d->DPisSet=true;
}

void animaLesionsSegmentationToolBox::onFLAIRDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->indexFLAIR = index;
    d->FLAIRDropSite->setPixmap(medDataManager::instance()->thumbnail(index));
    d->FLAIRisSet=true;
}

void animaLesionsSegmentationToolBox::onT1GdDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->indexT1Gd = index;
    d->T1GdDropSite->setPixmap(medDataManager::instance()->thumbnail(index));
    d->T1GdisSet=true;
}

void animaLesionsSegmentationToolBox::onClearImagesClicked()
{
    d->maskDropSite->clearMask();
    d->maskDropSite->setText(tr("Drop here the \n 3D brain mask"));

    d->T1DropSite->clearMask();
    d->T1DropSite->setText(tr("Drop here T1"));

    d->T2DropSite->clearMask();
    d->T2DropSite->setText(tr("Drop here tT2"));

    d->DPDropSite->clearMask();
    d->DPDropSite->setText(tr("Drop here DP"));

    d->FLAIRDropSite->clearMask();
    d->FLAIRDropSite->setText(tr("Drop here FLAIR"));

    d->T1GdDropSite->clearMask();
    d->T1GdDropSite->setText(tr("Drop here T1Gd"));

    d->T1isSet=false;
    d->T2isSet=false;
    d->DPisSet=false;
    d->FLAIRisSet=false;
    d->T1GdisSet=false;
    d->MaskisSet=false;
}

void animaLesionsSegmentationToolBox::ChangeAutomaticState(int state)
{
    // auto enable
    if(state==2){
        d->NABTGroupBox->setEnabled(true);
        d->DetectionGroupBox->setEnabled(true);
        if(d->strem->isChecked()){
            d->gcGroupBox->setDisabled(true);
        }
    }

    // auto disable
    if(state==0){
        d->NABTGroupBox->setEnabled(false);
        d->DetectionGroupBox->setEnabled(false);
        d->enableManu->setChecked(true);
        d->gcGroupBox->setEnabled(true);
    }
}
void animaLesionsSegmentationToolBox::ChangeManuState(int state)
{
    // manu enable
    if(state==2){
        d->SelectSourcesButton->setDisabled(false);
        d->SelectSinksButton->setDisabled(false);
        d->multiVarSources->setDisabled(false);
        d->multiVarSinks->setDisabled(false);
        d->PreviewMultiVarButton->setDisabled(false);
    }

    // manu disable
    if(state==0){
        d->enableAuto->setChecked(true);
        d->SelectSourcesButton->setDisabled(true);
        d->SelectSinksButton->setDisabled(true);
        d->multiVarSources->setDisabled(true);
        d->multiVarSinks->setDisabled(true);
        d->PreviewMultiVarButton->setDisabled(true);
    }
}

void animaLesionsSegmentationToolBox::CheckedStrem(bool checked)
{
    if(checked==true){
        d->gcGroupBox->setEnabled(false);
    }
}
void animaLesionsSegmentationToolBox::CheckedFuzzy(bool checked)
{
    if(checked==true){
        d->gcGroupBox->setEnabled(true);
    }
}

void animaLesionsSegmentationToolBox::updateAtlasButton(int index)
{
    if(index==0){
        d->SelectAtlasButton->setEnabled(true);
    }
    else{
        d->SelectAtlasButton->setEnabled(false);
    }
}

void animaLesionsSegmentationToolBox::updateRejectionFeatures(int index)
{
    if(index==0){
        d->rejRatio->setEnabled(false);
        d->emIterConcentration->setEnabled(false);
        d->emBeforeConcentration->setEnabled(false);
    }
    else{
        d->rejRatio->setEnabled(true);
        d->emIterConcentration->setEnabled(true);
        d->emBeforeConcentration->setEnabled(true);
    }
}

void animaLesionsSegmentationToolBox::ChangedIntensityState(int state)
{
    if(state==2){
        d->T2intensityFactor->setEnabled(true);
        d->DPintensityFactor->setEnabled(true);
        d->FLAIRintensityFactor->setEnabled(true);
    }
    if(state==0){
        d->T2intensityFactor->setEnabled(false);
        d->DPintensityFactor->setEnabled(false);
        d->FLAIRintensityFactor->setEnabled(false);
    }
}

void animaLesionsSegmentationToolBox::run(void)
{
    if(!this->segmentationToolBox())
        return;

    int a = this->segmentationToolBox()->Getparam();
    std::cout << "number parameter: " << a << std::endl;

    d->process = new animaLesionsSegmentation;

    if(!d->MaskisSet)
    {
        // put warning here, 3D brain mask is mandatory
        return;
    }
    else
    {
        d->maskData = medDataManager::instance()->retrieveData(d->indexMask);
        d->process->setMaskInput(d->maskData);
         qDebug() << "mask set";
    }

    if(d->T1isSet)
    {
        d->T1Data = medDataManager::instance()->retrieveData(d->indexT1);
        d->process->setT1Input(d->T1Data);
        qDebug() << "T1 set";
    }
    if(d->T2isSet)
    {
        d->T2Data = medDataManager::instance()->retrieveData(d->indexT2);
        d->process->setT2Input(d->T2Data);
         qDebug() << "T2 set";
    }
    if(d->DPisSet)
    {
        d->DPData = medDataManager::instance()->retrieveData(d->indexDP);
        d->process->setDPInput(d->DPData);
         qDebug() << "DP set";
    }
    if(d->FLAIRisSet)
    {
        d->FLAIRData = medDataManager::instance()->retrieveData(d->indexFLAIR);
        d->process->setFLAIRInput(d->FLAIRData);
         qDebug() << "FLAIR set";
    }
    if(d->T1GdisSet)
    {
        d->T1GdData = medDataManager::instance()->retrieveData(d->indexT1Gd);
        d->process->setT1GdInput(d->T1GdData);
         qDebug() << "T1 Gd set";
    }

    // Parameters setting
    d->process->setSegAutoEnable(d->enableAuto->isChecked());
    d->process->setSeganuEnable(d->enableManu->isChecked());
    d->process->setNumberOfThreads(d->threads->value());
    d->process->setInitMethod(d->init->currentIndex());
    d->process->setRejRatioHierar(d->rejRatio->value());
    d->process->setEmAlgo(d->algoEM->currentIndex());
    d->process->setEmIter(d->emIter->value());
    d->process->setMinDistance(d->minDistance->value());
    d->process->setRejRatio(d->rejRatio->value());
    d->process->setEmIter_concentration(d->emIterConcentration->value());
    d->process->setEm_before_concentration(d->emBeforeConcentration->isChecked());
    d->process->setUseStrem(d->strem);
    d->process->setMaha(d->mahaDist->value());
    d->process->setFuzzyRuleMin(d->fuzzyMin->value());
    d->process->setFuzzyRuleMax(d->fuzzyMax->value());
    //d->process->setUseT2(bool useT2);
    //d->process->setUseDP(bool useDP);
    //d->process->setUseFLAIR(bool useFLAIR);
    d->process->setUseSpecGrad(d->useSpectralGrad->isChecked());
    //d->process->setTLinkMode(d->TLinkMode);
    d->process->setMultiVarSources((float)d->multiVarSources->value());
    d->process->setMultiVarSinks((float)d->multiVarSinks->value());
    d->process->setSigma(d->sigma->value());
    d->process->setAlpha(d->alpha->value());
    d->process->setMinLesionSize(d->minLesionsSize->value());
    d->process->setMinGMSize(d->minGMSize->value());
    d->process->setRemoveBorder(d->removeBorderLesions->isChecked());
    d->process->setIntensityRule(d->useIntensityRule->isChecked());
    d->process->setIntensityT2(d->T2intensityFactor->value());
    d->process->setIntensityDP(d->DPintensityFactor->value());
    d->process->setIntensityFLAIR(d->FLAIRintensityFactor->value());
    //d->process->setMatrixGrad(d->matrixFileEdit);
    //d->process->setReadSolutionFile(QString readSolutionFile);


    // Set your parameters here
    medRunnableProcess *runProcess = new medRunnableProcess;
    runProcess->setProcess (d->process);

    connect (runProcess, SIGNAL (success  (QObject*)),  this, SIGNAL (success ()));
    connect (runProcess, SIGNAL (failure  (QObject*)),  this, SIGNAL (failure ()));
    connect (runProcess, SIGNAL (cancelled (QObject*)),  this, SIGNAL (failure ()));

    /*d->progression_stack->addJobItem(runProcess, tr("Progress:"));
    d->progression_stack->disableCancel(runProcess);
    //If there is no observer to track the progression,make the progress bar spin:
    d->progression_stack->setActive(runProcess,true);
    //connect (runProcess, SIGNAL(activate(QObject*,bool)),d->progression_stack, SLOT(setActive(QObject*,bool)));*/

    medJobManager::instance()->registerJobItem(runProcess);
    QThreadPool::globalInstance()->start(dynamic_cast<QRunnable*>(runProcess));

}
