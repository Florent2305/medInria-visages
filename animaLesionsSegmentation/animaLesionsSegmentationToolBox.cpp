// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////


#include "animaLesionsSegmentation.h"
#include "animaLesionsSegmentationToolBox.h"

#include <QtGui>

#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>
#include <dtkCore/dtkSmartPointer.h>

#include <medAbstractView.h>
//#include <medRunnableProcess.h>
#include <medJobManager.h>

#include <medToolBoxFactory.h>
#include <medSegmentationSelectorToolBox.h>
#include <medProgressionStack.h>
#include <medPluginManager.h>
#include <medToolBoxTab.h>
#include <medDropSite.h>
#include <medDataIndex.h>
#include <medDataManager.h>

#include <itkMultiThreader.h>
#include <medDataIndexParameter.h>

#include <medMessageController.h>
#include <medDataIndexListParameter.h>


class animaLesionsSegmentationToolBoxPrivate
{
public:

    dtkSmartPointer <animaLesionsSegmentation> process;

    dtkSmartPointer<medAbstractData> maskData;
    dtkSmartPointer<medAbstractData> T1Data;
    dtkSmartPointer<medAbstractData> T2Data;
    dtkSmartPointer<medAbstractData> DPData;
    dtkSmartPointer<medAbstractData> FLAIRData;
    dtkSmartPointer<medAbstractData> T1GdData;

    dtkSmartPointer<medAbstractData> AtlasCSFData;
    dtkSmartPointer<medAbstractData> AtlasGMData;
    dtkSmartPointer<medAbstractData> AtlasWMData;


    QLabel *dataTypeValue;
    QLabel *dataDimensionValue;

    // Output type
    QRadioButton *WholeSeg;
    QRadioButton *LesionSeg;
    QRadioButton *CSFSeg;
    QRadioButton *GMSeg;
    QRadioButton *WMSeg;
    QButtonGroup *OutputTypeGroup;

    QCheckBox *enableAuto;
    QCheckBox *enableManu;

    QCheckBox *useFormerSegModel;

    // NABT estimation
    QComboBox *algoEM;
    QComboBox *init;
    QPushButton *SelectAtlasButton;

    QDoubleSpinBox *emIter;
    QDoubleSpinBox *minDistance;
    QDoubleSpinBox *rejRatio;
    QDoubleSpinBox *emIterConcentration;
    QCheckBox *emBeforeConcentration;

    QButtonGroup *detectionButtonGroup;
    QRadioButton *strem;
    QDoubleSpinBox *mahaDist;
    QRadioButton *fuzzy;
    QDoubleSpinBox *fuzzyMin;
    QDoubleSpinBox *fuzzyMax;

    // Heuristic Rules
    QCheckBox *removeBorderLesions;
    QDoubleSpinBox *wmRatio;
    QDoubleSpinBox *minLesionsSize;
    QDoubleSpinBox * minGMSize;
    QCheckBox *useIntensityRule;
    QDoubleSpinBox *T2intensityFactor;
    QDoubleSpinBox *DPintensityFactor;
    QDoubleSpinBox *FLAIRintensityFactor;

    //Manual
    QPushButton *SelectSourcesButton;
    QPushButton *SelectSinksButton;
    QDoubleSpinBox *multiVarSources;
    QDoubleSpinBox *multiVarSinks;

    //gc
    QDoubleSpinBox *alpha;
    QDoubleSpinBox *sigma;
    QCheckBox *useSpectralGrad;
    QLineEdit *matrixFileEdit;

    //Global Parameters:
    QSpinBox *threads;
    medProgressionStack * progression_stack;

    medDropSite *T1DropSite;
    medDropSite *T2DropSite;
    medDropSite *DPDropSite;

    medDropSite *FLAIRDropSite;
    medDropSite *T1GdDropSite;
    medDropSite *maskDropSite;

    medDataIndexParameter *T1Parameter;
    medDataIndexParameter *T2Parameter;
    medDataIndexParameter *DPParameter;
    medDataIndexParameter *FLAIRParameter;
    medDataIndexParameter *T1GdParameter;
    medDataIndexParameter *MaskParameter;

    medDataIndexListParameter *seedParameter;

    medDataIndex indexT1;
    medDataIndex indexT2;
    medDataIndex indexDP;
    medDataIndex indexFLAIR;
    medDataIndex indexT1Gd;
    medDataIndex indexMask;

    QGroupBox *NABTGroupBox;
    QGroupBox *DetectionGroupBox;
    QGroupBox *gcGroupBox;
    QGroupBox *SeedsGroupBox;
    QGroupBox *globalParametersGroupBox;

    QPushButton *openMatrixFileButton;
    QPushButton *PreviewMultiVarButton;

    QPushButton *SaveLesionLoadButton;

    bool T1isSet,T2isSet,DPisSet,FLAIRisSet,T1GdisSet,MaskisSet;
};

animaLesionsSegmentationToolBox::animaLesionsSegmentationToolBox(QWidget *parent) : medSegmentationAbstractToolBox(parent), d(new animaLesionsSegmentationToolBoxPrivate)
{
    //Segmentation
    this->setTitle("Lesion Segmentation");
    medToolBoxTab *widget = new medToolBoxTab(this);


    ///nb:run button can be set by dtkAbstractProcess (si on utilise pas la surcharge de la methode toolbox)
    QPushButton *runButton = new QPushButton(tr("Run"), this);

    d->SaveLesionLoadButton = new QPushButton(tr("Save lesion load"), this);
    d->SaveLesionLoadButton->setEnabled(false);

    // progression stack
    d->progression_stack = new medProgressionStack(widget);
    QHBoxLayout *progressStackLayout = new QHBoxLayout;
    progressStackLayout->addWidget(d->progression_stack);

    // Heuristic Rules Parameters
    d->removeBorderLesions = new QCheckBox;
    d->removeBorderLesions->setToolTip("Remove lesions that are not touching the brain mask");
    d->removeBorderLesions->setCheckState(Qt::Unchecked);

    d->wmRatio = new QDoubleSpinBox;
    d->wmRatio->setToolTip("Percentage of white matter that must suround the lesion");
    d->wmRatio->setDecimals(3);
    d->wmRatio->setValue(0.01);
    d->wmRatio->setSingleStep(0.01);
    d->wmRatio->setRange(0,1);

    d->minGMSize = new QDoubleSpinBox;
    d->minGMSize->setToolTip("Minimum gey matter region size");
    d->minGMSize->setDecimals(0);
    d->minGMSize->setValue(3);
    d->minGMSize->setSingleStep(1);
    d->minGMSize->setSuffix(" mm3");

    d->useIntensityRule = new QCheckBox;
    d->useIntensityRule->setToolTip("In T2 image, lesions will have to ...");
    d->useIntensityRule->setCheckState(Qt::Unchecked);

    d->minLesionsSize = new QDoubleSpinBox;
    d->minLesionsSize->setToolTip("Minimum lesion size");
    d->minLesionsSize->setValue(3);
    d->minLesionsSize->setDecimals(0);
    d->minLesionsSize->setSingleStep(1);
    d->minLesionsSize->setSuffix(" mm3");

    d->T2intensityFactor = new QDoubleSpinBox;
    d->T2intensityFactor->setToolTip("T2 intensiy factor");
    d->T2intensityFactor->setValue(2.5);
    d->T2intensityFactor->setDecimals(2);
    d->T2intensityFactor->setSingleStep(0.1);
    d->T2intensityFactor->setDisabled(true);

    d->DPintensityFactor = new QDoubleSpinBox;
    d->DPintensityFactor->setToolTip("DP intensiy factor");
    d->DPintensityFactor->setValue(2.5);
    d->DPintensityFactor->setDecimals(2);
    d->DPintensityFactor->setSingleStep(0.1);
    d->DPintensityFactor->setDisabled(true);

    d->FLAIRintensityFactor = new QDoubleSpinBox;
    d->FLAIRintensityFactor->setToolTip("FLAIR intensiy factor");
    d->FLAIRintensityFactor->setValue(2.5);
    d->FLAIRintensityFactor->setDecimals(2);
    d->FLAIRintensityFactor->setSingleStep(0.1);
    d->FLAIRintensityFactor->setDisabled(true);

    // Heuristic Parameters Layout
    QFormLayout *heuristicLayout = new QFormLayout();
    heuristicLayout->addRow(new QLabel(tr("Remove border lesions"),this),d->removeBorderLesions);
    //heuristicLayout->addRow(new QLabel(tr("WM border ratio"),this),d->wmRatio);
    heuristicLayout->addRow(new QLabel(tr("Min lesion size"),this),d->minLesionsSize);
    heuristicLayout->addRow(new QLabel(tr("Min GM region size"),this),d->minGMSize);
    heuristicLayout->addRow(new QLabel(tr("Intensity rule"),this),d->useIntensityRule);
    heuristicLayout->addRow(new QLabel(tr("T2 multi"),this),d->T2intensityFactor);
    heuristicLayout->addRow(new QLabel(tr("DP multi"),this),d->DPintensityFactor);
    heuristicLayout->addRow(new QLabel(tr("FLAIR multi"),this),d->FLAIRintensityFactor);

    QGroupBox *heuristicGroupBox = new QGroupBox(tr("Heuristic Parameters"));
    heuristicGroupBox->setLayout(heuristicLayout);



    // Main Page
    QPushButton *inputSelectionButton = new QPushButton(tr("Select MRI images"));
    QLabel *inputSelectionLabel = new QLabel(tr("Select MRI images"));
    QHBoxLayout *imagesBoxLayout = new QHBoxLayout();
    imagesBoxLayout->addWidget(inputSelectionLabel);
    imagesBoxLayout->addWidget(inputSelectionButton);

    d->T1Parameter = new medDataIndexParameter("T1", this);
    d->T1Parameter->setToolTip(tr("Drag-and-drop A T1 from the database or click here."));
    d->T1Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1."));

    d->T2Parameter = new medDataIndexParameter("T2", this);
    d->T2Parameter->setToolTip(tr("Drag-and-drop A T2 from the database or click here."));
    d->T2Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T2."));

    d->DPParameter = new medDataIndexParameter("DP", this);
    d->DPParameter->setToolTip(tr("Drag-and-drop A DP from the database or click here."));
    d->DPParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a DP."));

    d->FLAIRParameter = new medDataIndexParameter("FLAIR", this);
    d->FLAIRParameter->setToolTip(tr("Drag-and-drop A FLAIR from the database or click here."));
    d->FLAIRParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a FLAIR."));

    d->T1GdParameter = new medDataIndexParameter("T1Gd", this);
    d->T1GdParameter->setToolTip(tr("Drag-and-drop A T1Gd from the database or click here."));
    d->T1GdParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1Gd."));

    d->MaskParameter = new medDataIndexParameter("Mask", this);
    d->MaskParameter->setToolTip(tr("Drag-and-drop A Mask from the database or click here."));
    d->MaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a Mask."));

    QHBoxLayout *MRIBox1Layout = new QHBoxLayout();
    MRIBox1Layout->addWidget(d->T1Parameter->getWidget(), 0, Qt::AlignCenter);
    MRIBox1Layout->addWidget(d->T2Parameter->getWidget(), 0, Qt::AlignCenter);

    QHBoxLayout *MRIBox2Layout = new QHBoxLayout();
    MRIBox2Layout->addWidget(d->DPParameter->getWidget(), 0, Qt::AlignCenter);
    MRIBox2Layout->addWidget(d->FLAIRParameter->getWidget(), 0, Qt::AlignCenter);

    QHBoxLayout *MRIBox3Layout = new QHBoxLayout();
    MRIBox3Layout->addWidget(d->T1GdParameter->getWidget(), 0, Qt::AlignCenter);
    MRIBox3Layout->addWidget(d->MaskParameter->getWidget(), 0, Qt::AlignCenter);

    QPushButton *clearImagesButton = new QPushButton(tr("Remove whole images"));

    QVBoxLayout *box1Layout = new QVBoxLayout();
    box1Layout->addLayout(MRIBox1Layout);
    box1Layout->addLayout(MRIBox2Layout);
    box1Layout->addLayout(MRIBox3Layout);
    box1Layout->addWidget(clearImagesButton);



    QGroupBox *ImagesGroupBox = new QGroupBox(tr("Select MRI Images"));
    ImagesGroupBox->setLayout(box1Layout);

    d->OutputTypeGroup = new QButtonGroup();
    d->WholeSeg = new QRadioButton(tr("Whole segmentation"));
    d->LesionSeg = new QRadioButton(tr("Lesion segmentation"));
    d->CSFSeg = new QRadioButton(tr("CSF segmentation"));
    d->GMSeg = new QRadioButton(tr("Grey matter segmentation"));
    d->WMSeg = new QRadioButton(tr("White matter segmentation"));

    d->OutputTypeGroup->addButton(d->WholeSeg);
    d->OutputTypeGroup->setId(d->WholeSeg, 0);
    d->WholeSeg->setChecked(true);

    d->OutputTypeGroup->addButton(d->LesionSeg);
    d->OutputTypeGroup->setId(d->LesionSeg, 1);

    d->OutputTypeGroup->addButton(d->CSFSeg);
    d->OutputTypeGroup->setId(d->CSFSeg, 2);

    d->OutputTypeGroup->addButton(d->GMSeg);
    d->OutputTypeGroup->setId(d->GMSeg, 3);

    d->OutputTypeGroup->addButton(d->WMSeg);
    d->OutputTypeGroup->setId(d->WMSeg, 4);

    QVBoxLayout *OutputTypeLayout = new QVBoxLayout();
    OutputTypeLayout->addWidget(d->WholeSeg);
    OutputTypeLayout->addWidget(d->LesionSeg);
    OutputTypeLayout->addWidget(d->CSFSeg);
    OutputTypeLayout->addWidget(d->GMSeg);
    OutputTypeLayout->addWidget(d->WMSeg);

    QGroupBox *OutputTypeGroupBox = new QGroupBox(tr("Output type"));
    OutputTypeGroupBox->setLayout(OutputTypeLayout);



    // Algo param

    // Auomatic Computation
    d->enableAuto = new QCheckBox;
    d->enableAuto->setToolTip("Enable automatic segmentation");
    d->enableAuto->setCheckState(Qt::Checked);

    d->useFormerSegModel = new QCheckBox;
    d->useFormerSegModel->setToolTip("Keep former NABT estination");
    d->useFormerSegModel->setCheckState(Qt::Unchecked);

    QFormLayout *enableAutoLayout = new QFormLayout();
    enableAutoLayout->addRow(new QLabel(tr("Enable automatic computation"),this),d->enableAuto);
    enableAutoLayout->addRow(new QLabel(tr("Keep former NABT estimation"),this),d->useFormerSegModel);

    QGroupBox *AutoGroupBox = new QGroupBox(tr("Use automatic seg"));
    AutoGroupBox->setLayout(enableAutoLayout);

    d->init = new QComboBox;
    d->init->setToolTip("Type of initialisation");
    QStringList initList;
    initList << "Atlas" << "Hierar DP" << "Hierar FLAIR";
    d->init->addItems ( initList );
    d->init->setCurrentIndex(1);

    d->SelectAtlasButton = new QPushButton(tr("Select Atlas"), this);
    d->SelectAtlasButton->setEnabled(false);

    QVBoxLayout *initLayout = new QVBoxLayout();
    initLayout->addWidget(d->init);
    initLayout->addWidget(d->SelectAtlasButton);

    d->algoEM = new QComboBox;
    d->algoEM->setToolTip("Type of EM algorithm");
    QStringList algoEMList;
    algoEMList << "EM" << "Celeux REM" << "REM";
    d->algoEM->addItems(algoEMList);
    d->algoEM->setCurrentIndex(2);

    d->emIter = new QDoubleSpinBox;
    d->emIter->setToolTip("xx");
    d->emIter->setDecimals(0);
    d->emIter->setValue(100);
    d->emIter->setSingleStep(1);
    d->emIter->setRange(0,1000);

    d->minDistance = new QDoubleSpinBox;
    d->minDistance->setToolTip("xx");
    d->minDistance->setDecimals(4);
    d->minDistance->setValue(0.0001);
    d->minDistance->setSingleStep(0.0001);
    d->minDistance->setRange(0,1);

    d->rejRatio = new QDoubleSpinBox;
    d->rejRatio->setToolTip("xx");
    d->rejRatio->setDecimals(3);
    d->rejRatio->setValue(0.2);
    d->rejRatio->setSingleStep(0.01);
    d->rejRatio->setRange(0.01,0.49);

    d->emIterConcentration = new QDoubleSpinBox;
    d->emIterConcentration->setToolTip("xx");
    d->emIterConcentration->setDecimals(0);
    d->emIterConcentration->setValue(100);
    d->emIterConcentration->setSingleStep(1);
    d->emIterConcentration->setRange(0,1000);

    d->emBeforeConcentration = new QCheckBox;
    d->emBeforeConcentration->setToolTip("xx");
    d->emBeforeConcentration->setCheckState(Qt::Checked);


    QFormLayout *NABTLayout = new QFormLayout();
    NABTLayout->addRow(new QLabel(tr("EM algorithm type"),this),d->algoEM);
    NABTLayout->addRow(new QLabel(tr("Initialisation"),this),initLayout);
    NABTLayout->addRow(new QLabel(tr("Max iterations"),this),d->emIter);
    NABTLayout->addRow(new QLabel(tr("Minimum distance"),this),d->minDistance);
    NABTLayout->addRow(new QLabel(tr("Rejection ratio"),this),d->rejRatio);
    NABTLayout->addRow(new QLabel(tr("Max iterations between \n concentration steps"),this),d->emIterConcentration);
    NABTLayout->addRow(new QLabel(tr("EM before first concentration"),this),d->emBeforeConcentration);

    d->NABTGroupBox = new QGroupBox(tr("Normal appearing brain tissues estimation"));
    d->NABTGroupBox->setLayout(NABTLayout);




    d->strem = new QRadioButton;
    d->strem->setToolTip("Use strem option. Graph Cut will NOT be used.");
    d->strem->setChecked(false);

    d->mahaDist = new QDoubleSpinBox;
    d->mahaDist->setToolTip("xxxxx");
    d->mahaDist->setValue(2.5);
    d->mahaDist->setDecimals(2);
    d->mahaDist->setSingleStep(0.01);

    d->fuzzy = new QRadioButton;
    d->fuzzy->setToolTip("Use fuzzy option. Graph Cut will be used.");
    d->fuzzy->setChecked(true);

    d->fuzzyMin = new QDoubleSpinBox;
    d->fuzzyMin->setToolTip("xxxxx");
    d->fuzzyMin->setValue(2.5);
    d->fuzzyMin->setDecimals(2);
    d->fuzzyMin->setSingleStep(0.01);

    d->fuzzyMax = new QDoubleSpinBox;
    d->fuzzyMax->setToolTip("xxxx");
    d->fuzzyMax->setValue(2.5);
    d->fuzzyMax->setDecimals(2);
    d->fuzzyMax->setSingleStep(0.01);

    d->detectionButtonGroup = new QButtonGroup();
    d->detectionButtonGroup->addButton(d->strem);
    d->detectionButtonGroup->setId(d->strem, 0);
    d->detectionButtonGroup->addButton(d->fuzzy);
    d->detectionButtonGroup->setId(d->fuzzy, 1);


    QFormLayout *DetectionLayout = new QFormLayout();
    DetectionLayout->addRow(new QLabel(tr("Use Strem"),this),d->strem);
    DetectionLayout->addRow(new QLabel(tr("Mahalanobis distance"),this),d->mahaDist);
    DetectionLayout->addRow(new QLabel(tr("Use Fuzzy rules (graph cut)"),this),d->fuzzy);
    DetectionLayout->addRow(new QLabel(tr("Min fuzzy rule"),this),d->fuzzyMin);
    DetectionLayout->addRow(new QLabel(tr("Max fuzzy rule"),this),d->fuzzyMax);

    d->DetectionGroupBox = new QGroupBox(tr("Detection of candidate lesions"));
    d->DetectionGroupBox->setLayout(DetectionLayout);




    // Graph cut
    /*d->matrixFileEdit = new QLineEdit;
    d->openMatrixFileButton = new QPushButton(tr("..."), this);
    QHBoxLayout *matrixLayout = new QHBoxLayout;
    matrixLayout->addWidget(d->matrixFileEdit);
    matrixLayout->addWidget(d->openMatrixFileButton);*/

    d->alpha = new QDoubleSpinBox;
    d->alpha->setRange(0, 1000);
    d->alpha->setValue(10);

    d->sigma= new QDoubleSpinBox;
    d->sigma->setRange(0, 1000);
    d->sigma->setValue(0.6);
    d->sigma->setSingleStep(0.1);

    d->useSpectralGrad = new QCheckBox;
    d->useSpectralGrad ->setChecked(true);

    QFormLayout *gcBoxLayout = new QFormLayout();
    gcBoxLayout->addRow(new QLabel(tr("Alpha"),this),d->alpha);
    gcBoxLayout->addRow(new QLabel(tr("Sigma"),this),d->sigma);
    gcBoxLayout->addRow(new QLabel(tr("Use Spectral Gradient"),this),d->useSpectralGrad);
    //gcBoxLayout->addRow(new QLabel(tr("Matrix"),this),matrixLayout);

    d->enableManu = new QCheckBox;
    d->enableManu->setToolTip("Enable manual masks as entries");
    d->enableManu->setCheckState(Qt::Unchecked);
    gcBoxLayout->addRow(new QLabel(tr("Enable manual masks"),this),d->enableManu);

    d->SelectSourcesButton = new QPushButton(tr("sources"));
    d->SelectSinksButton = new QPushButton(tr("sinks"));

    d->multiVarSources = new QDoubleSpinBox();
    d->multiVarSources->setToolTip("xx");
    d->multiVarSources->setDecimals(2);
    d->multiVarSources->setValue(1);
    d->multiVarSources->setSingleStep(0.1);
    d->multiVarSources->setRange(0,20);

    d->multiVarSinks = new QDoubleSpinBox();
    d->multiVarSinks->setToolTip("xx");
    d->multiVarSinks->setDecimals(2);
    d->multiVarSinks->setValue(1);
    d->multiVarSinks->setSingleStep(0.1);
    d->multiVarSinks->setRange(0,20);

    d->PreviewMultiVarButton = new QPushButton(tr("Preview variance"));

    d->SelectSourcesButton->setDisabled(true);
    d->SelectSinksButton->setDisabled(true);
    d->multiVarSources->setDisabled(true);
    d->multiVarSinks->setDisabled(true);
    d->PreviewMultiVarButton->setDisabled(true);

    //QFormLayout *SeedsLayout = new QFormLayout();
    gcBoxLayout->addRow(new QLabel(tr("Select sources masks"),this),d->SelectSourcesButton);
    gcBoxLayout->addRow(new QLabel(tr("Select sinks masks"),this),d->SelectSinksButton);
    gcBoxLayout->addRow(new QLabel(tr("Multiply source variance factor"),this),d->multiVarSources);
    gcBoxLayout->addRow(new QLabel(tr("Multiply source variance factor"),this),d->multiVarSinks);
    gcBoxLayout->addRow(new QLabel(tr("Preview variance"),this),d->PreviewMultiVarButton);

    d->gcGroupBox = new QGroupBox(tr("Graph Cut Parameters"));
    d->gcGroupBox->setLayout(gcBoxLayout);


    d->threads = new QSpinBox();
    d->threads->setToolTip("xx");
    d->threads->setValue(8);
    d->threads->setSingleStep(1);
    d->threads->setRange(1,8);

    QFormLayout *globalParamBoxLayout = new QFormLayout();
    globalParamBoxLayout->addRow(new QLabel(tr("Threads"),this),d->threads);
    d->globalParametersGroupBox = new QGroupBox(tr("Global Parameters"));
    d->globalParametersGroupBox->setLayout(globalParamBoxLayout);



    // Set Tabs
    QWidget *header = new QWidget;
    QVBoxLayout *layoutheader = new QVBoxLayout(header);
    layoutheader->addWidget(runButton);
    layoutheader->addWidget(d->SaveLesionLoadButton);
    layoutheader->addWidget(d->progression_stack);

    QWidget *page1 = new QWidget;
    QVBoxLayout *layout1 = new QVBoxLayout(page1);
    layout1->addWidget(ImagesGroupBox);
    layout1->addWidget(heuristicGroupBox);
    layout1->addWidget(OutputTypeGroupBox);

    QWidget *page2 = new QWidget;
    QVBoxLayout *layout2 = new QVBoxLayout(page2);
    layout2->addWidget(AutoGroupBox);
    layout2->addWidget(d->NABTGroupBox);
    layout2->addWidget(d->DetectionGroupBox);
    layout2->addWidget(d->SeedsGroupBox);
    layout2->addWidget(d->gcGroupBox);
    layout2->addWidget(d->globalParametersGroupBox);

    widget->addTab(page1, "Main");
    widget->addTab(page2, "Segmentation Parameters");

    this->addWidget( header );
    this->addWidget( widget );

    d->T1isSet=false;
    d->T2isSet=false;
    d->DPisSet=false;
    d->FLAIRisSet=false;
    d->T1GdisSet=false;
    d->MaskisSet=false;


    //Connect slots
    connect(d->MaskParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onMaskDropped(const medDataIndex &)));
    connect(d->T1Parameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onT1Dropped(const medDataIndex &)));
    connect(d->T2Parameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onT2Dropped(const medDataIndex &)));

    connect(d->DPParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onDPDropped(const medDataIndex &)));
    connect(d->FLAIRParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onFLAIRDropped(const medDataIndex &)));
    connect(d->T1GdParameter, SIGNAL(valueChanged(const medDataIndex &)),this,SLOT(onT1GdDropped(const medDataIndex &)));

    connect(clearImagesButton,SIGNAL(clicked()),this,SLOT(onClearImagesClicked()));

    connect(d->enableAuto, SIGNAL(stateChanged(int)),this,SLOT(ChangeAutomaticState(int)));
    connect(d->enableManu, SIGNAL(stateChanged(int)),this,SLOT(ChangeManuState(int)));
    connect(d->strem, SIGNAL(clicked(bool)),this,SLOT(CheckedStrem(bool)));
    connect(d->fuzzy, SIGNAL(clicked(bool)),this,SLOT(CheckedFuzzy(bool)));

    connect(d->init, SIGNAL(currentIndexChanged(int)), this, SLOT(updateAtlasButton(int)));
    connect(d->algoEM, SIGNAL(currentIndexChanged(int)), this, SLOT(updateRejectionFeatures(int)));

    connect(d->useIntensityRule, SIGNAL(stateChanged(int)), this, SLOT(ChangedIntensityState(int)));
    connect(runButton, SIGNAL(clicked()), this, SIGNAL(runRequest()));

    // Add about plugin
    medPluginManager* pm = medPluginManager::instance();
    dtkPlugin* plugin = pm->plugin ( "animaLesionsSegmentationPlugin" );
    setAboutPluginButton ( plugin );
    setAboutPluginVisibility( true );
}

animaLesionsSegmentationToolBox::~animaLesionsSegmentationToolBox(void)
{
    delete d;
    d = NULL;
}

bool animaLesionsSegmentationToolBox::registered(void)
{
    return medToolBoxFactory::instance()->registerToolBox<animaLesionsSegmentationToolBox>();
}

medAbstractData* animaLesionsSegmentationToolBox::processOutput(void)
{
    if(!d->process)
        return NULL;

    return d->process->output();
}

dtkPlugin* animaLesionsSegmentationToolBox::plugin()
{
    medPluginManager* pm = medPluginManager::instance();
    dtkPlugin* plugin = pm->plugin ( "animaLesionsSegmentationPlugin" );
    return plugin;
}


medAbstractData* animaLesionsSegmentationToolBox::getT1()
{
    return d->T1Data;
}
medAbstractData* animaLesionsSegmentationToolBox::getT2()
{
    return d->T2Data;
}
medAbstractData* animaLesionsSegmentationToolBox::getDP()
{
    return d->DPData;
}
medAbstractData* animaLesionsSegmentationToolBox::getFLAIR()
{
    return d->FLAIRData;
}
medAbstractData* animaLesionsSegmentationToolBox::getT1Gd()
{
    return d->T1GdData;
}
medAbstractData* animaLesionsSegmentationToolBox::getMask()
{
    return d->maskData;
}

void animaLesionsSegmentationToolBox::onT1Dropped(const medDataIndex& index)
{
    if (!index.isValidForSeries()){
        return;
    }
    d->T1Data = medDataManager::instance()->retrieveData(index);
    // we accept only ROIs (medItkUChar3ImageData)
    if (!d->T1Data ||
            (d->T1Data->identifier() != "medItkUChar3ImageData" &&
             d->T1Data->identifier() != "medItkChar3ImageData" &&
             d->T1Data->identifier() != "medItkUShort3ImageData" &&
             d->T1Data->identifier() != "medItkShort3ImageData" &&
             d->T1Data->identifier() != "medItkUInt3ImageData" &&
             d->T1Data->identifier() != "medItkInt3ImageData" &&
             d->T1Data->identifier() != "medItkFloat3ImageData" &&
             d->T1Data->identifier() != "medItkDouble3ImageData"))
    {
        medMessageController::instance()->showError(tr("Unable to load ROI, format not supported yet"), 3000);
        qDebug() << "unable to read T1";
        return;
    }
    d->T1isSet=true;
}

void animaLesionsSegmentationToolBox::onT2Dropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->T2Data = medDataManager::instance()->retrieveData(index);
    d->T2isSet=true;
}

void animaLesionsSegmentationToolBox::onDPDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->DPData = medDataManager::instance()->retrieveData(index);
    d->DPisSet=true;
}

void animaLesionsSegmentationToolBox::onFLAIRDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->FLAIRData = medDataManager::instance()->retrieveData(index);
    d->FLAIRisSet=true;
}

void animaLesionsSegmentationToolBox::onT1GdDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->T1GdData = medDataManager::instance()->retrieveData(index);
    d->T1GdisSet=true;
}
void animaLesionsSegmentationToolBox::onMaskDropped(const medDataIndex& index)
{
    if (!index.isValid()){
        return;
    }
    d->maskData = medDataManager::instance()->retrieveData(index);
    d->MaskisSet=true;
}

void animaLesionsSegmentationToolBox::onClearImagesClicked()
{
    // clear medDropSite and put text again   
    d->T1Parameter->clear();
    d->T1Parameter->setToolTip(tr("Drag-and-drop A T1 from the database or click here."));
    d->T1Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1."));

    d->T2Parameter->clear();
    d->T2Parameter->setToolTip(tr("Drag-and-drop A T2 from the database or click here."));
    d->T2Parameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T2."));

    d->DPParameter->clear();
    d->DPParameter->setToolTip(tr("Drag-and-drop A DP from the database or click here."));
    d->DPParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a DP."));

    d->FLAIRParameter->clear();
    d->FLAIRParameter->setToolTip(tr("Drag-and-drop A FLAIR from the database or click here."));
    d->FLAIRParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a FLAIR."));

    d->T1GdParameter->clear();
    d->T1GdParameter->setToolTip(tr("Drag-and-drop A T1Gd from the database or click here."));
    d->T1GdParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a T1Gd."));

    d->MaskParameter->clear();
    d->MaskParameter->setToolTip(tr("Drag-and-drop A Mask from the database or click here."));
    d->MaskParameter->setText(tr("Drag-and-drop\nfrom the database\nor click here\nto open a Mask."));

    d->T1isSet=false;
    d->T2isSet=false;
    d->DPisSet=false;
    d->FLAIRisSet=false;
    d->T1GdisSet=false;
    d->MaskisSet=false;
}

void animaLesionsSegmentationToolBox::ChangeAutomaticState(int state)
{
    // auto enable
    if(state==2){
        d->NABTGroupBox->setEnabled(true);
        d->DetectionGroupBox->setEnabled(true);
        if(d->strem->isChecked()){
            d->gcGroupBox->setDisabled(true);
        }
    }

    // auto disable
    if(state==0){
        d->NABTGroupBox->setEnabled(false);
        d->DetectionGroupBox->setEnabled(false);
        d->enableManu->setChecked(true);
        d->gcGroupBox->setEnabled(true);
    }
}
void animaLesionsSegmentationToolBox::ChangeManuState(int state)
{
    // manu enable
    if(state==2){
        d->SelectSourcesButton->setDisabled(false);
        d->SelectSinksButton->setDisabled(false);
        d->multiVarSources->setDisabled(false);
        d->multiVarSinks->setDisabled(false);
        d->PreviewMultiVarButton->setDisabled(false);
    }

    // manu disable
    if(state==0){
        d->enableAuto->setChecked(true);
        d->SelectSourcesButton->setDisabled(true);
        d->SelectSinksButton->setDisabled(true);
        d->multiVarSources->setDisabled(true);
        d->multiVarSinks->setDisabled(true);
        d->PreviewMultiVarButton->setDisabled(true);
    }
}

void animaLesionsSegmentationToolBox::CheckedStrem(bool checked)
{
    if(checked==true){
        d->gcGroupBox->setEnabled(false);
    }
}
void animaLesionsSegmentationToolBox::CheckedFuzzy(bool checked)
{
    if(checked==true){
        d->gcGroupBox->setEnabled(true);
    }
}

void animaLesionsSegmentationToolBox::updateAtlasButton(int index)
{
    if(index==0){
        d->SelectAtlasButton->setEnabled(true);
    }
    else{
        d->SelectAtlasButton->setEnabled(false);
    }
}

void animaLesionsSegmentationToolBox::updateRejectionFeatures(int index)
{
    if(index==0){
        d->rejRatio->setEnabled(false);
        d->emIterConcentration->setEnabled(false);
        d->emBeforeConcentration->setEnabled(false);
    }
    else{
        d->rejRatio->setEnabled(true);
        d->emIterConcentration->setEnabled(true);
        d->emBeforeConcentration->setEnabled(true);
    }
}

void animaLesionsSegmentationToolBox::ChangedIntensityState(int state)
{
    if(state==2){
        d->T2intensityFactor->setEnabled(true);
        d->DPintensityFactor->setEnabled(true);
        d->FLAIRintensityFactor->setEnabled(true);
    }
    if(state==0){
        d->T2intensityFactor->setEnabled(false);
        d->DPintensityFactor->setEnabled(false);
        d->FLAIRintensityFactor->setEnabled(false);
    }
}

///todo set warning segmentation input


// Define get for process
bool animaLesionsSegmentationToolBox::getEnableAuto(void)
{
    return d->enableAuto->isChecked();
}
bool animaLesionsSegmentationToolBox::getEnableManu(void)
{
    return d->enableManu->isChecked();
}

unsigned int animaLesionsSegmentationToolBox::getNumberOfThreads()
{
    return d->threads->value();
}
unsigned int animaLesionsSegmentationToolBox::getInitMethod()
{
    return d->init->currentIndex();
}

double animaLesionsSegmentationToolBox::getRejRatioHierar()
{
    return d->rejRatio->value();
}
unsigned int animaLesionsSegmentationToolBox::getEmAlgo()
{
    return d->algoEM->currentIndex();
}
int animaLesionsSegmentationToolBox::getEmIter()
{
    return d->emIter->value();
}
double animaLesionsSegmentationToolBox::getMinDistance()
{
    return d->minDistance->value();
}
double animaLesionsSegmentationToolBox::getRejRatio()
{
    return d->rejRatio->value();
}
int animaLesionsSegmentationToolBox::getEmIter_concentration()
{
    return d->emIterConcentration->value();
}
bool animaLesionsSegmentationToolBox::getEm_before_concentration()
{
    return d->emBeforeConcentration->isChecked();
}\
bool animaLesionsSegmentationToolBox::getUseStrem()
{
    return d->strem->isChecked();
}
double animaLesionsSegmentationToolBox::getMaha()
{
    return d->mahaDist->value();
}
double animaLesionsSegmentationToolBox::getFuzzyRuleMin()
{
    return d->fuzzyMin->value();
}
double animaLesionsSegmentationToolBox::getFuzzyRuleMax()
{
    return d->fuzzyMax->value();
}
/*
void animaLesionsSegmentationToolBox::getUseT2()
{
    d->useT2 = useT2;
}
void animaLesionsSegmentationToolBox::getUseDP()
{
    d->useDP = useDP;
}
void animaLesionsSegmentationToolBox::getUseFLAIR()
{
    d->useFLAIR = useFLAIR;
}*/

bool animaLesionsSegmentationToolBox::getUseSpecGrad()
{
    return d->useSpectralGrad->isChecked();
}
/*
int animaLesionsSegmentationToolBox::getTLinkMode()
{
    d->TLinkMode = TLinkMode;
}*/
float animaLesionsSegmentationToolBox::getMultiVarSources()
{
    return (float)d->multiVarSources->value();
}
float animaLesionsSegmentationToolBox::getMultiVarSinks()
{
    return (float)d->multiVarSinks->value();
}

float animaLesionsSegmentationToolBox::getSigma()
{
    return d->sigma->value();
}
float animaLesionsSegmentationToolBox::getAlpha()
{
    return d->alpha->value();
}
float animaLesionsSegmentationToolBox::getMinLesionSize()
{
    return d->minLesionsSize->value();
}
float animaLesionsSegmentationToolBox::getMinGMSize()
{
    return d->minGMSize->value();
}
bool animaLesionsSegmentationToolBox::getRemoveBorder()
{
    return d->removeBorderLesions->isChecked();
}
bool animaLesionsSegmentationToolBox::getIntensityRule()
{
    return d->useIntensityRule->isChecked();
}
double animaLesionsSegmentationToolBox::getIntensityT2()
{
    return d->T2intensityFactor->value();
}
double animaLesionsSegmentationToolBox::getIntensityDP()
{
    return d->DPintensityFactor->value();
}
double animaLesionsSegmentationToolBox::getIntensityFLAIR()
{
    return d->FLAIRintensityFactor->value();
}
bool animaLesionsSegmentationToolBox::getUseFormerSegModel()
{
    return d->useFormerSegModel->isChecked();
}
/*QString animaLesionsSegmentationToolBox::getMatrixGrad()
{
    d->matrixGrad = matrixGrad;
}
QString animaLesionsSegmentationToolBox::getReadSolutionFile()
{
    d->readSolutionFile = readSolutionFile;
}*/


/*
void animaLesionsSegmentationToolBox::run(void)
{
    if(!this->segmentationToolBox())
        return;

    d->process = new animaLesionsSegmentation;

    if(!d->MaskisSet)
    {
        // put warning here, 3D brain mask is mandatory
        return;
    }
    else
    {
        d->maskData = medDataManager::instance()->retrieveData(d->indexMask);
        d->process->setMaskInput(d->maskData);
         qDebug() << "mask set";
    }

    if(d->T1isSet)
    {
        d->T1Data = medDataManager::instance()->retrieveData(d->indexT1);
        d->process->setT1Input(d->T1Data);
        qDebug() << "T1 set";
    }
    if(d->T2isSet)
    {
        d->T2Data = medDataManager::instance()->retrieveData(d->indexT2);
        d->process->setT2Input(d->T2Data);
         qDebug() << "T2 set";
    }
    if(d->DPisSet)
    {
        d->DPData = medDataManager::instance()->retrieveData(d->indexDP);
        d->process->setDPInput(d->DPData);
         qDebug() << "DP set";
    }
    if(d->FLAIRisSet)
    {
        d->FLAIRData = medDataManager::instance()->retrieveData(d->indexFLAIR);
        d->process->setFLAIRInput(d->FLAIRData);
         qDebug() << "FLAIR set";
    }
    if(d->T1GdisSet)
    {
        d->T1GdData = medDataManager::instance()->retrieveData(d->indexT1Gd);
        d->process->setT1GdInput(d->T1GdData);
         qDebug() << "T1 Gd set";
    }

    // Parameters setting
    d->process->setSegAutoEnable(d->enableAuto->isChecked());
    d->process->setSeganuEnable(d->enableManu->isChecked());
    d->process->setNumberOfThreads(d->threads->value());
    d->process->setInitMethod(d->init->currentIndex());
    d->process->setRejRatioHierar(d->rejRatio->value());
    d->process->setEmAlgo(d->algoEM->currentIndex());
    d->process->setEmIter(d->emIter->value());
    d->process->setMinDistance(d->minDistance->value());
    d->process->setRejRatio(d->rejRatio->value());
    d->process->setEmIter_concentration(d->emIterConcentration->value());
    d->process->setEm_before_concentration(d->emBeforeConcentration->isChecked());
    d->process->setUseStrem(d->strem);
    d->process->setMaha(d->mahaDist->value());
    d->process->setFuzzyRuleMin(d->fuzzyMin->value());
    d->process->setFuzzyRuleMax(d->fuzzyMax->value());
    //d->process->setUseT2(bool useT2);
    //d->process->setUseDP(bool useDP);
    //d->process->setUseFLAIR(bool useFLAIR);
    d->process->setUseSpecGrad(d->useSpectralGrad->isChecked());
    //d->process->setTLinkMode(d->TLinkMode);
    d->process->setMultiVarSources((float)d->multiVarSources->value());
    d->process->setMultiVarSinks((float)d->multiVarSinks->value());
    d->process->setSigma(d->sigma->value());
    d->process->setAlpha(d->alpha->value());
    d->process->setMinLesionSize(d->minLesionsSize->value());
    d->process->setMinGMSize(d->minGMSize->value());
    d->process->setRemoveBorder(d->removeBorderLesions->isChecked());
    d->process->setIntensityRule(d->useIntensityRule->isChecked());
    d->process->setIntensityT2(d->T2intensityFactor->value());
    d->process->setIntensityDP(d->DPintensityFactor->value());
    d->process->setIntensityFLAIR(d->FLAIRintensityFactor->value());
    //d->process->setMatrixGrad(d->matrixFileEdit);
    //d->process->setReadSolutionFile(QString readSolutionFile);


    // Set your parameters here
    //medRunnableProcess *runProcess = new medRunnableProcess;
    /*medRunnableProcess *runProcess = new medRunnableProcess(d->process, d->process->name());
    runProcess->setProcess (d->process);

    connect (runProcess, SIGNAL (success  (QObject*)),  this, SIGNAL (success ()));
    connect (runProcess, SIGNAL (failure  (QObject*)),  this, SIGNAL (failure ()));
    connect (runProcess, SIGNAL (cancelled (QObject*)),  this, SIGNAL (failure ()));

    d->progression_stack->addJobItem(runProcess, tr("Progress:"));
    d->progression_stack->disableCancel(runProcess);
    //If there is no observer to track the progression,make the progress bar spin:
    d->progression_stack->setActive(runProcess,true);
    //connect (runProcess, SIGNAL(activate(QObject*,bool)),d->progression_stack, SLOT(setActive(QObject*,bool)));

   // medJobManager::instance()->registerJobItem(runProcess);
   // QThreadPool::globalInstance()->start(dynamic_cast<QRunnable*>(runProcess));

}*/
