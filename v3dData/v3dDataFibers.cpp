// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "v3dDataFibers.h"

#include <dtkCore/dtkAbstractDataFactory.h>

#include "vtkSmartPointer.h"
#include "vtkPolyData.h"
#include "vtkPolyDataReader.h"
#include "vtkPolyDataWriter.h"
#include "vtkFiberDataSet.h"

#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>
#include <vtkRenderWindow.h>

#include <QVTKWidget.h>

// /////////////////////////////////////////////////////////////////
// v3dDataFibersPrivate
// /////////////////////////////////////////////////////////////////

class v3dDataFibersPrivate
{
public:
    vtkSmartPointer<vtkFiberDataSet> data;
    QList<QImage>          thumbnails;
    QImage thumbnail;
};

// /////////////////////////////////////////////////////////////////
// v3dDataFibers
// /////////////////////////////////////////////////////////////////

v3dDataFibers::v3dDataFibers(void) : dtkAbstractData(), d(new v3dDataFibersPrivate)
{
    d->data = 0;
}

v3dDataFibers::~v3dDataFibers(void)
{
    delete d;
    d = 0;
}

bool v3dDataFibers::registered(void)
{
    return dtkAbstractDataFactory::instance()->registerDataType("v3dDataFibers", createV3dDataFibers);
}

QString v3dDataFibers::description(void) const
{
    return "v3dDataFibers";
}

void v3dDataFibers::setData(void *data)
{
  if (vtkFiberDataSet *dataset = vtkFiberDataSet::SafeDownCast (static_cast<vtkObject*>(data))) {
      d->data = dataset;

      QStringList bundles;
      
      vtkFiberDataSet::vtkFiberBundleListType bundleList = dataset->GetBundleList();
      vtkFiberDataSet::vtkFiberBundleListType::iterator it = bundleList.begin();
      while (it!=bundleList.end())
      {
	bundles << (*it).first.c_str();
	++it;
      }

      this->setMetaData ("BundleList", bundles);
  }
}

void *v3dDataFibers::data(void)
{
    return d->data;
}

QImage & v3dDataFibers::thumbnail (void) const
{
    if (d->thumbnails.count()==0)
        this->generateThumbnails();
    
    return d->thumbnail;
}

QList<QImage> &v3dDataFibers::thumbnails(void) const
{
    if (d->thumbnails.count()==0)
        generateThumbnails();
    
    return d->thumbnails;
}

void v3dDataFibers::generateThumbnails (void) const
{
    d->thumbnails.clear();
    
    // QVTKWidget *widget = new QVTKWidget;
    
    vtkPolyDataMapper* mapper = vtkPolyDataMapper::New();
    vtkActor* actor = vtkActor::New();
    vtkRenderer* renderer = vtkRenderer::New();
    vtkRenderWindow* window = vtkRenderWindow::New();
    mapper->SetInput (d->data->GetFibers());
    actor->SetMapper (mapper);
    renderer->AddViewProp(actor);
    window->SetSize (128,128);
    window->AddRenderer (renderer);
    window->OffScreenRenderingOn();
    renderer->ResetCamera();
    
    // widget->SetRenderWindow(window);
    // widget->setFixedSize(128,128);
    // widget->show();
    
    window->Render();
    // widget->update();
    // 

    unsigned int w=128, h=128;
    
    d->thumbnail = QImage(w, h, QImage::Format_ARGB32);
    
    vtkUnsignedCharArray* pixels = vtkUnsignedCharArray::New();
    pixels->SetArray(d->thumbnail.bits(), w*h*4, 1);
    window->GetRGBACharPixelData(0, 0, w-1, h-1, 1, pixels);

    d->thumbnails.append (d->thumbnail);
    
    pixels->Delete();
    mapper->Delete();
    actor->Delete();
    renderer->Delete();
    window->Delete(); // crash if window is deleted
    // widget->deleteLater();
}

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractData *createV3dDataFibers(void)
{
    return new v3dDataFibers;
}
