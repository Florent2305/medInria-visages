// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "vistalProcessMidPlaneAlign.h"

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkAbstractDataFactory.h>

#include <Image3D.hh>

#include "Interpolation.hh"
#include "AffineTransform.hh"
#include "ApplyTransform.hh"		// Apply Transformations
#include "Filter.hh"

#include "RigidTransformation.hh"

#include "WorldOrientation.hh"
#include "MutualInformation.hh"
#include "OptimizerNewuoa.hh"
#include "SplineImage.h"

// /////////////////////////////////////////////////////////////////
// vistalProcessMidPlaneAlignPrivate
// /////////////////////////////////////////////////////////////////

class vistalProcessMidPlaneAlignPrivate
{
public:
    dtkAbstractData* input;
    dtkAbstractData* output;

    float rhobeg;
    float rhoend;
    int maxfun;

};

// /////////////////////////////////////////////////////////////////
// vistalProcessMidPlaneAlign
// /////////////////////////////////////////////////////////////////

vistalProcessMidPlaneAlign::vistalProcessMidPlaneAlign(void) : dtkAbstractProcess(), d(new vistalProcessMidPlaneAlignPrivate)
{

}

vistalProcessMidPlaneAlign::~vistalProcessMidPlaneAlign(void)
{

}

bool vistalProcessMidPlaneAlign::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("vistalProcessMidPlaneAlign", createVistalProcessMidPlaneAlign);
}

QString vistalProcessMidPlaneAlign::description(void) const
{
    return "vistalProcessMidPlaneAlign";
}


void vistalProcessMidPlaneAlign::setInput(dtkAbstractData *data)
{
    if (!data) return;
    qDebug() << "Setting input" << data;
    d->input = data->convert("vistalDataImageFloat3");
}

void vistalProcessMidPlaneAlign::setParameter(double  data, int channel)
{
    switch (channel)
    {
    case 0: d->maxfun  = data; return;
    case 1: d->rhobeg  = data; return;
    case 2: d->rhoend  = data; return;
    }
}

int vistalProcessMidPlaneAlign::update(void)
{
    using namespace vistal;
    qDebug() << "Starting process";


    if (!d || !d->input || !dynamic_cast<vistal::Image3D<float>*>((vistal::Image3D<float>*)d->input->data()))
        return -1;

    Image3D<float>& image = *dynamic_cast<vistal::Image3D<float>*>((vistal::Image3D<float>*)d->input->data());

    // Force the type in the image to float
    typedef float ImageDataType;
    // Just use the Symmetry Plane transformation
    typedef Registration::TransformationTrait<Registration::SymmetricPlane> Transfo;
    //Just use the Mutual Information Cost Function
    typedef MutualInformationCostFunctionStatic<ImageDataType, Transfo, PartialVolume> CostFunction;
    // Just perform optimization using newuoa
    int iter = 0;
    float fret;
    Matrix RepIrm(4,4), RepIrmf(4,4);

    float p[CostFunction::Parameters];

    for (int i = 0; i < CostFunction::Parameters; ++i) p[i] = 0;
    CostFunction::Transformation::initialValues(p);

    std::string multiresolution("222111");

    computeWorldOrientationMatrix(image, RepIrm);
    computeWorldOrientationMatrix(image, RepIrmf);

    Image3D<ImageDataType> Decimatedf(image);

    double av = ((CostFunction::Parameters+1)*(CostFunction::Parameters+2))/2;

    long int npt = (int) av;
    double w[(npt+13)*(npt+CostFunction::Parameters)+3*CostFunction::Parameters*(CostFunction::Parameters+3)/2];

    // Loop on resolution
    while (multiresolution != "") {

        int X_factor = multiresolution[0]-'0';
        int Y_factor = multiresolution[1]-'0';
        int Z_factor = multiresolution[2]-'0';


        qDebug() << "SubSample Moving Image by factors [" << X_factor << ", " << Y_factor << ", " << Z_factor <<"]";
        SubSampling(image,Decimatedf,X_factor,Y_factor,Z_factor,2);

        // Construct cost Object with subsampled images
        computeWorldOrientationMatrix(Decimatedf, RepIrmf);
        computeWorldOrientationMatrix(Decimatedf, RepIrm);

        CostFunction cost(Decimatedf, Decimatedf, RepIrm, RepIrmf);
        NewuoaOptimizerStatic<CostFunction> newuoa(cost);

        qDebug() << "-----------NEWUOA Optimization-----------" << CostFunction::Transformation::name();
        qDebug() << "Initial Cost        : " << cost(p);

        fret = newuoa.optimize((double*) w,npt,(float*)p,d->rhobeg, d->rhoend, d->maxfun, iter);


        qDebug() << "Iterations          : " << iter+1;
        qDebug() << "Minimum             : " << fret;
        qDebug() << "Cost Function calls : " << cost.getIterations();

        multiresolution = multiresolution.substr(3,multiresolution.size());
    }


    Matrix A(4,4); A = 0;

    if (CostFunction::Transformation::Realign)
        CostFunction::Transformation::BuildRealignMatrix(p, A, image.nbx, image.nby, image.nbz);
    else
        CostFunction::Transformation::BuildMatrix(p, A, image.nbx, image.nby, image.nbz);

    Image3D<ImageDataType>* tmp = new Image3D<ImageDataType>(image);

    computeNormalizationOrientationMatrix(image, RepIrmf);
    computeNormalizationOrientationMatrix(image, RepIrm);
    qDebug() << "Applying transfo";

    //        ApplyTransform<CostFunction::Transformation>(image, *tmp, RepIrm, RepIrmf, p, 3 /* Cubic Spline interp*/);

    SPlineImage3D<3, Mirror, ClampBoth, true> smov(image);


    A =  RepIrm.i() * A * RepIrmf;
    Matrix Inv(4,4);
    Inv = A.i();


    for (vistal::Image3D<float>::iterator it = tmp->begin(); it != tmp->end(); ++it)
    {
        Vect3Df pos = it.Position();
        const float id = Inv(1,1)*pos.x() + Inv(1,2)*pos.y() + Inv(1,3)*pos.z() + Inv(1,4);
        const float jd = Inv(2,1)*pos.x() + Inv(2,2)*pos.y() + Inv(2,3)*pos.z() + Inv(2,4);
        const float kd = Inv(3,1)*pos.x() + Inv(3,2)*pos.y() + Inv(3,3)*pos.z() + Inv(3,4);

        *it = smov(id,jd,kd);
    }

    qDebug() << "Done";

    d->output = dtkAbstractDataFactory::instance()->create("vistalDataImageFloat3");
    d->output->setData(tmp);

    emit success();

    return DTK_SUCCEED;
}

dtkAbstractData *vistalProcessMidPlaneAlign::output(void)
{
    return d->output;
}


// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createVistalProcessMidPlaneAlign(void)
{
    return new vistalProcessMidPlaneAlign;
}
