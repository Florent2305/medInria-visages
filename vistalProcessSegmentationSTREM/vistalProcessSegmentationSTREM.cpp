// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "vistalProcessSegmentationSTREM.h"

#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractData.h>

#include "mstoolsFiniteModel.h"
#include "Matrice.hh"
#include "Image3D.hh"
#include "GIS.hh"
#include "mstoolsGaussian.h"
#include "mstoolsStraInitializer.h"
#include "mstoolsHierarchicalInitializer.h"


#include "mstoolsClassificationFunctions.h"

#include "mstoolsAtlasRandomInitializer.h"
#include "mstoolsModelInitializer.h"
#include "mstoolsJointHistogramNdims.h"

#include "mstoolsClassEstimator.h"
#include "mstoolsGaussian.h"
#include "mstoolsGaussianREMEstimator.h"
#include "mstoolsGaussianEMEstimator.h"
#include "mstoolsGaussianCeleuxREMEstimator.h"
#include "mstoolsGaussianCeleuxEMEstimator.h"
#include "mstoolsImageClassifier.h" 
#include "mstoolsRulesLesionClassifier.h"

#include "mstoolsClassificationStrategy.h"


//#include "mstoolsIO.h"


// /////////////////////////////////////////////////////////////////
// vistalProcessSegmentationSTREMPrivate
// /////////////////////////////////////////////////////////////////

class vistalProcessSegmentationSTREMPrivate
{
public:
	vistalProcessSegmentationSTREMPrivate();
	~vistalProcessSegmentationSTREMPrivate();
	// Channel 0 to 2
	std::vector< vistal::Image3D<unsigned char>* > input; // Expected Input image to segment (T1, PD , {T2, FLAIR} )
	// Channel 3
	vistal::Image3D<unsigned char>* mask; // Mask image


	enum InitialisationMethod { StraInit, HierarchicalPD, HierarchicalFLAIR } initMethod; // Type of initialisation for the EM, D. Garcia used Hierachical PD or FLAIR depending on the input
	// Rejection Ratio 
	double rejectionRatio;
	
	enum ApproachEM { GaussianEM, GaussianCeleuxREM, GaussianREM } approachEM;
	
	double minDistance; // = 1e-4;
	int emIter; 
	int strem;
	
};

vistalProcessSegmentationSTREMPrivate::vistalProcessSegmentationSTREMPrivate(): 
	input(3), 
	rejectionRatio(0.2),  minDistance(1e-4), emIter(10), strem(0)
// -0 -iter 200 dist 1e-3 
// show outliers, set iteration to 200, mindistance 1e-3, 
{
	
}

vistalProcessSegmentationSTREMPrivate::~vistalProcessSegmentationSTREMPrivate()
{
	for (unsigned i = 0; i < input.size(); ++i)
		delete input[i];
	delete mask;
}


// /////////////////////////////////////////////////////////////////
// vistalProcessSegmentationSTREM
// /////////////////////////////////////////////////////////////////

vistalProcessSegmentationSTREM::vistalProcessSegmentationSTREM(void) : dtkAbstractProcess(), d(new vistalProcessSegmentationSTREMPrivate)
{
}

vistalProcessSegmentationSTREM::~vistalProcessSegmentationSTREM(void)
{
	delete d;
}

bool vistalProcessSegmentationSTREM::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("vistalProcessSegmentationSTREM", createVistalProcessSegmentationSTREM);
}

QString vistalProcessSegmentationSTREM::description(void) const
{
    return "vistalProcessSegmentationSTREM";
}

void vistalProcessSegmentationSTREM::setInput(dtkAbstractData *data, int channel)
{
	if (!data)
		return;
	if (channel >= 0 && channel < 3)
		d->input[channel] = static_cast<vistal::Image3D<unsigned char>* >(data->convert("vistalDataImageUChar3")->data());
	if (channel == 3)
		d->mask = static_cast<vistal::Image3D<unsigned char>* >(data->convert("vistalDataImageUChar3")->data());


}


void vistalProcessSegmentationSTREM::setParameter(double  data, int channel)
{
        switch(channel){

		   case(0):
				//if (data == 0)
//					d->initMethod = vistalProcessSegmentationSTREMPrivate::Unset;
//				else
				if (data == 0)
					d->initMethod = vistalProcessSegmentationSTREMPrivate::StraInit;
				else if (data == 1)
					d->initMethod = vistalProcessSegmentationSTREMPrivate::HierarchicalPD;
				else if (data == 2)
					d->initMethod = vistalProcessSegmentationSTREMPrivate::HierarchicalFLAIR;
				break;				
				
			case 1:
				if (data > 0 && data < 1)				
					d->rejectionRatio = data;
				else d->rejectionRatio = 0;
				
				break;
				
			case 2:
				if (data == 0)
					d->approachEM = vistalProcessSegmentationSTREMPrivate::GaussianEM;
			else if (data == 1)
				d->approachEM = vistalProcessSegmentationSTREMPrivate::GaussianCeleuxREM;
			else if (data == 2)
				d->approachEM = vistalProcessSegmentationSTREMPrivate::GaussianREM  ;
				break;
				
			case 3:
				d->minDistance = data;//1e-4;
				break;
				
			case 4:
				d->emIter = data;
				break;
				
//                    d->alpha = data;
//                    break;
//            case(1):
//                    if(data == 0)
//                        d->tlinkMode = vistal::Tlinks::Gaussian;
//                    else if(data == 1)
//                        d->tlinkMode = vistal::Tlinks::Strem;
//                    else if(data == 2)
//                        d->tlinkMode = vistal::Tlinks::Parzen;
//                    else if(data ==3)
//                        d->tlinkMode = vistal::Tlinks::Density;
//                    else
//                        return;
//
//                    break;
//
//            case(2):
//                    d->beta = data;
//                    break;
//
//            case(3):
//                    d->useSpecGrad = data;
//                    break;
//
//            case(4):
//                    d->sigma = data;
//                    break;

            default:
                return;
        }
}

// Run the STREM Algorithm
int vistalProcessSegmentationSTREM::update(void)
{
	using namespace mstools;
	// Starting  strainit binary code
	
	std::vector<vistal::Image3D<unsigned char> > input;
	for (unsigned i = 0; i < d->input.size(); ++i)
		input.push_back(*d->input[i]);
	
	FiniteModel initia;

	for(unsigned int i=0; i<3; i++)
	{		
		Distribution::Pointer p=Gaussian::New( 3);
		initia.push_back(p);
	}
	
	
	switch (d->initMethod) {
		case vistalProcessSegmentationSTREMPrivate::StraInit:
		{
			StraInitializer init(input,*d->mask);
			init.setDebugMode(false);
				if(!init. getInitialization(initia)) return -1;
			break;
		}
		case vistalProcessSegmentationSTREMPrivate::HierarchicalPD: // If third image is T2 use this init
		{
			std::vector<std::string> seq;
			HierarchicalInitializer init(input,*d->mask,seq,false,0.01,false);
			if(!init. getInitialization(initia)) return -1;
			break;
		}
		case vistalProcessSegmentationSTREMPrivate::HierarchicalFLAIR: // If third image is FLAIR use this init
		{
			std::vector<std::string> seq;
			HierarchicalInitializer init(input,*d->mask,seq,true,0.01,false);
			if(!init. getInitialization(initia)) return -1;
			break;
		}
		default:
		 return -1;
	}
	
	// Starting Classification binary code
	
	int modalities = 3;
	
	JointHistogramNdims jointHistogram;
	std::vector<double> min( modalities, 255.0 ); //min values for random initialization
	std::vector<double> max( modalities, 0.0 ); //max values for random initialization
	
	for (unsigned i = 0; i < 3; ++i) min[i] = vistal::stats::GetMinPixelValue( input[ i ] , *d->mask );
	for (unsigned i = 0; i < 3; ++i) max[i] = vistal::stats::GetMaxPixelValue( input[ i ] , *d->mask );
	
	if (! jointHistogram.createJointHistogram( input, *d->mask, false ))
			return -1;  // Joint histogram construction failure
	
	
	std::vector<unsigned int> emSteps( 1, 1 );
	std::vector<unsigned int> iterSteps( 1, 100 );
	
	ClassEstimator *estimator = NULL;
	
	switch (d->approachEM)
	{
		case vistalProcessSegmentationSTREMPrivate::GaussianCeleuxREM:
				estimator = new GaussianCeleuxREMEstimator( iterSteps[ 0 ], d->minDistance, d->emIter, d->strem );
				dynamic_cast<GaussianCeleuxREMEstimator *>( estimator ) ->setRejectionRatio( d->rejectionRatio );
			break;
		case vistalProcessSegmentationSTREMPrivate::GaussianEM:
			  estimator = new GaussianEMEstimator( iterSteps[ 0 ], d->minDistance );
			break;
		case vistalProcessSegmentationSTREMPrivate::GaussianREM:
			estimator = new GaussianREMEstimator( iterSteps[ 0 ], d->minDistance, d->emIter, d->strem );
			dynamic_cast<GaussianREMEstimator *>( estimator ) ->setRejectionRatio( d->rejectionRatio );

			break;
	}
	
	estimator->setJointHistogram(jointHistogram);
	
	estimator->setModel(initia);
	
	unsigned iterations = 0;
	
	double value = estimator->run(iterations);
	
	
	FiniteModel solution = estimator->getModel();
	
	// Got the segmentation ....
	
	if (solution.size() != 0)
	{
		ImageClassifier classifier;
        //Create classification output
        classifier.setModel( solution );
		
		vistal::Image3D<unsigned char> outima;
		
		classifier.getOutputImage( input , *d->mask, outima );

		// Fixme tell medINRIA that outima is the output....
		
	//	if (d->showOutliers)
//		{
//		}
//		
		
		
	}
	
	delete estimator;
	
	
	// Now apply the nlesions binary
	
	
	
	
	
  return EXIT_SUCCESS;
}

dtkAbstractData * vistalProcessSegmentationSTREM::output(void)
{
	return NULL;
      //  return d->output;
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createVistalProcessSegmentationSTREM(void)
{
    return new vistalProcessSegmentationSTREM;
}
