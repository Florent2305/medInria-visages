// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "vistalProcessSegmentationSTREM.h"

#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractData.h>

#include <QDebug>

#include "mstoolsFiniteModel.h"
#include "Matrice.hh"
#include "Image3D.hh"
#include "GIS.hh"
#include "mstoolsGaussian.h"
#include "mstoolsStraInitializer.h"
#include "mstoolsHierarchicalInitializer.h"


#include "mstoolsClassificationFunctions.h"

#include "mstoolsAtlasRandomInitializer.h"
#include "mstoolsModelInitializer.h"
#include "mstoolsJointHistogramNdims.h"

#include "mstoolsClassEstimator.h"
#include "mstoolsGaussian.h"
#include "mstoolsGaussianREMEstimator.h"
#include "mstoolsGaussianEMEstimator.h"
#include "mstoolsGaussianCeleuxREMEstimator.h"
#include "mstoolsGaussianCeleuxEMEstimator.h"
#include "mstoolsImageClassifier.h" 
#include "mstoolsRulesLesionClassifier.h"

#include "mstoolsClassificationStrategy.h"
#include "Labelize.hh"
#include "mstoolsRulesLesionClassifier.h"
#include "mstoolsMahalanobisThreshold.h"
#include "mstoolsChi2.h"




//#include "mstoolsIO.h"


// /////////////////////////////////////////////////////////////////
// vistalProcessSegmentationSTREMPrivate
// /////////////////////////////////////////////////////////////////

class vistalProcessSegmentationSTREMPrivate
{
public:
	vistalProcessSegmentationSTREMPrivate();
	~vistalProcessSegmentationSTREMPrivate();
	// Channel 0 to 2
	std::vector< vistal::Image3D<unsigned char>* > input; // Expected Input image to segment (T1, PD , {T2, FLAIR} )
	// Channel 3
	vistal::Image3D<unsigned char>* mask; // Mask image
	
	
	enum InitialisationMethod { StraInit, HierarchicalPD, HierarchicalFLAIR } initMethod; // Type of initialisation for the EM, D. Garcia used Hierachical PD or FLAIR depending on the input
	// Rejection Ratio 
	double rejectionRatio;
	
	enum ApproachEM { GaussianEM, GaussianCeleuxREM, GaussianREM } approachEM;
	
	double minDistance; // = 1e-4;
	int emIter; 
	int strem;
	
	/* nlesions parameterts*/
	double mahalanobisThreshold, rulesThreshold;
	int minsize, wmneighbor;

	
	dtkAbstractData *output;

};

vistalProcessSegmentationSTREMPrivate::vistalProcessSegmentationSTREMPrivate(): 
rejectionRatio(0.2),  minDistance(1e-4), emIter(10), strem(0),
mahalanobisThreshold(.4), rulesThreshold(3.),
minsize(6), wmneighbor(0.05)

// -0 -iter 200 dist 1e-3 
// show outliers, set iteration to 200, mindistance 1e-3, 
{
}

vistalProcessSegmentationSTREMPrivate::~vistalProcessSegmentationSTREMPrivate()
{
	for (unsigned i = 0; i < input.size(); ++i)
		delete input[i];
	delete mask;
}






// /////////////////////////////////////////////////////////////////
// vistalProcessSegmentationSTREM
// /////////////////////////////////////////////////////////////////

vistalProcessSegmentationSTREM::vistalProcessSegmentationSTREM(void) : dtkAbstractProcess(), d(new vistalProcessSegmentationSTREMPrivate)
{
}

vistalProcessSegmentationSTREM::~vistalProcessSegmentationSTREM(void)
{
	delete d;
}

bool vistalProcessSegmentationSTREM::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("vistalProcessSegmentationSTREM", createVistalProcessSegmentationSTREM);
}

QString vistalProcessSegmentationSTREM::description(void) const
{
    return "vistalProcessSegmentationSTREM";
}

void vistalProcessSegmentationSTREM::setInput(dtkAbstractData *data, int channel)
{
	
	// data->name().startsWith("vistalDataImage") // special conversion
	qDebug() << d << channel;
	if (!d) return;
	qDebug() << d->input.size();
	if (d->input.size() != 3) d->input.resize(3);
	qDebug() << d->input.size();
	
	qDebug() << "Inside setInput" << data << channel;
	dtkAbstractData *dU8 = data->convert("vistalDataImageUChar3");
	if (!dU8) 
	{
		qDebug() << "DataType conversion error";
		return;
	}
	
	
	
	if (!data)
		return;
	if (channel >= 0 && channel < 3)
		d->input[channel] = static_cast<vistal::Image3D<unsigned char>* >(dU8->data());
	if (channel == 3)
		d->mask = static_cast<vistal::Image3D<unsigned char>* >(dU8->data());
	
	
}


void vistalProcessSegmentationSTREM::setParameter(double  data, int channel)
{
	switch(channel){
			
		case(0):
			//if (data == 0)
			//					d->initMethod = vistalProcessSegmentationSTREMPrivate::Unset;
			//				else
			if (data == 0)
				d->initMethod = vistalProcessSegmentationSTREMPrivate::StraInit;
			else if (data == 1)
				d->initMethod = vistalProcessSegmentationSTREMPrivate::HierarchicalPD;
			else if (data == 2)
				d->initMethod = vistalProcessSegmentationSTREMPrivate::HierarchicalFLAIR;
			break;				
			
		case 1:
			if (data > 0 && data < 1)				
				d->rejectionRatio = data;
			else d->rejectionRatio = 0;
			
			break;
			
		case 2:
			if (data == 0)
				d->approachEM = vistalProcessSegmentationSTREMPrivate::GaussianEM;
			else if (data == 1)
				d->approachEM = vistalProcessSegmentationSTREMPrivate::GaussianCeleuxREM;
			else if (data == 2)
				d->approachEM = vistalProcessSegmentationSTREMPrivate::GaussianREM  ;
			break;
			
		case 3:
			d->minDistance = data;//1e-4;
			break;
			
		case 4:
			d->emIter = data;
			break;
			
		case 5:
			d->strem = data;
			break;
		case 6:
			d->mahalanobisThreshold = data;
			break;
		case 7:
			d->rulesThreshold = data;
			break;
		case 8:
			d->minsize = data;
			break;
		case 9:
			d->wmneighbor = data;
			break;
						

			
			//                    d->alpha = data;
			//                    break;
			//            case(1):
			//                    if(data == 0)
			//                        d->tlinkMode = vistal::Tlinks::Gaussian;
			//                    else if(data == 1)
			//                        d->tlinkMode = vistal::Tlinks::Strem;
			//                    else if(data == 2)
			//                        d->tlinkMode = vistal::Tlinks::Parzen;
			//                    else if(data ==3)
			//                        d->tlinkMode = vistal::Tlinks::Density;
			//                    else
			//                        return;
			//
			//                    break;
			//
			//            case(2):
			//                    d->beta = data;
			//                    break;
			//
			//            case(3):
			//                    d->useSpecGrad = data;
			//                    break;
			//
			//            case(4):
			//                    d->sigma = data;
			//                    break;
			
		default:
			return;
	}
}

// Run the STREM Algorithm
int vistalProcessSegmentationSTREM::update(void)
{
	using namespace mstools;
	// Starting  strainit binary code
	
	std::vector<vistal::Image3D<unsigned char> > input;
	for (unsigned i = 0; i < d->input.size(); ++i)
	{
		if (d->input[i] == 0)
		{
			qDebug() << "Null input, stopping process";
			return -1;
		}
		input.push_back(*d->input[i]);
	}
	
	if (d->mask == 0)
	{
		qDebug() << "Null mask input, stopping process";
		return -1;
	}
	
	FiniteModel initia;
	
	for(unsigned int i=0; i<3; i++)
	{		
		Distribution::Pointer p=Gaussian::New( 3);
		initia.push_back(p);
	}
	
	
	switch (d->initMethod) {
		case vistalProcessSegmentationSTREMPrivate::StraInit:
		{
			StraInitializer init(input,*d->mask);
			init.setDebugMode(false);
			if(!init. getInitialization(initia)) return -1;
			break;
		}
		case vistalProcessSegmentationSTREMPrivate::HierarchicalPD: // If third image is T2 use this init
		{
			std::vector<std::string> seq;
			HierarchicalInitializer init(input,*d->mask,seq,false,0.01,false);
			if(!init. getInitialization(initia)) return -1;
			break;
		}
		case vistalProcessSegmentationSTREMPrivate::HierarchicalFLAIR: // If third image is FLAIR use this init
		{
			std::vector<std::string> seq;
			HierarchicalInitializer init(input,*d->mask,seq,true,0.01,false);
			if(!init. getInitialization(initia)) return -1;
			break;
		}
		default:
			return -1;
	}
	
	// Starting Classification binary code
	
	int modalities = 3;
	
	JointHistogramNdims jointHistogram;
	std::vector<double> min( modalities, 255.0 ); //min values for random initialization
	std::vector<double> max( modalities, 0.0 ); //max values for random initialization
	
	for (unsigned i = 0; i < 3; ++i) min[i] = vistal::stats::GetMinPixelValue( input[ i ] , *d->mask );
	for (unsigned i = 0; i < 3; ++i) max[i] = vistal::stats::GetMaxPixelValue( input[ i ] , *d->mask );
	
	if (! jointHistogram.createJointHistogram( input, *d->mask, false ))
		return -1;  // Joint histogram construction failure
	
	
	std::vector<unsigned int> emSteps( 1, 1 );
	std::vector<unsigned int> iterSteps( 1, 100 );
	
	ClassEstimator *estimator = NULL;
	
	switch (d->approachEM)
	{
		case vistalProcessSegmentationSTREMPrivate::GaussianCeleuxREM:
			estimator = new GaussianCeleuxREMEstimator( iterSteps[ 0 ], d->minDistance, d->emIter, d->strem );
			dynamic_cast<GaussianCeleuxREMEstimator *>( estimator ) ->setRejectionRatio( d->rejectionRatio );
			break;
		case vistalProcessSegmentationSTREMPrivate::GaussianEM:
			estimator = new GaussianEMEstimator( iterSteps[ 0 ], d->minDistance );
			break;
		case vistalProcessSegmentationSTREMPrivate::GaussianREM:
			estimator = new GaussianREMEstimator( iterSteps[ 0 ], d->minDistance, d->emIter, d->strem );
			dynamic_cast<GaussianREMEstimator *>( estimator ) ->setRejectionRatio( d->rejectionRatio );
			
			break;
	}
	
	estimator->setJointHistogram(jointHistogram);
	
	estimator->setModel(initia);
	
	unsigned iterations = 0;
	
	double value = estimator->run(iterations);
	
	
	FiniteModel solution = estimator->getModel();
	
	// Got the segmentation ....
	
	if (solution.size() != 0)
	{
		ImageClassifier classifier;
        //Create classification output
        classifier.setModel( solution );
		
		vistal::Image3D<unsigned char> outima;
		
		classifier.getOutputImage( input , *d->mask, outima );
		
		// Fixme tell medINRIA that outima is the output....
		
		//	if (d->showOutliers)
		//		{
		//		}
		//		
		
		
	}
	
	delete estimator;
	
	
	// Now apply the nlesions binary
	
	
	vistal::Image3D<unsigned char> thImage;
	MahalanobisThreshold threshold;
    threshold.setModel( solution );
    threshold.setThreshold( d->mahalanobisThreshold );
	
	threshold.getThresholdImage( input, *d->mask, thImage );
	
	vistal::Image3D<unsigned char> rulesIma;
	double rules3[3];
	rules3[0]=d->rulesThreshold;
	rules3[1]=d->rulesThreshold;
	rules3[2]=d->rulesThreshold;
	
	// Lesions in rules Ima are ==5
	if(!rulesT2lesions(rulesIma, thImage, input, solution, rules3, false /* verbose*/ ))
		return -1;
	
	vistal::Image3D<unsigned int > labels;
	int numLabels=0;
	vistal::Image3D<unsigned int> tmpIma(*d->mask, 0);
	for (vistal::Image3D<unsigned>::iterator it = tmpIma.begin(); it != tmpIma.end(); ++it)
		if (rulesIma(it.Position()) == 5) 
			*it = 1;
	
	numLabels = Labelize( tmpIma, labels, 0 );
	
	vistal::Image3D<unsigned int> biglesions(tmpIma);
	rulesLesionSize(biglesions,*d->mask,labels, d->minsize,/* verbose = */ false);
	
	// Removing border lesions
	//////////////////////////////
	vistal::Image3D<unsigned int> noborderlesions;
	
	if(!rulesBorder( noborderlesions, *d->mask, biglesions,/* verbose = */false ))
	{
		std::cout<<" ** ERROR in rulesBorder"<<std::endl;
		return -1;
	}
	
	vistal::Image3D<unsigned char> classifIma;
	ImageClassifier classifier;
	classifier.setModel( solution );
	classifier.getOutputImage( input , *d->mask, classifIma );
	
	
	vistal::Image3D<unsigned char> classifplus(classifIma);
	Voxel p;
	
	
	for (vistal::Image3D<unsigned char>::iterator it = classifplus.begin(); it != classifplus.end(); ++it)		
		if(noborderlesions(it.Position()))
			*it = solution.size()+1;
	// Choose and remove small GM regions
	
	vistal::Image3D<unsigned char> nclassif;
	int minGMsize=15;
	//			std::cout<<" -- Cleaning GM in classification: minsize: "<<minGMsize<<std::endl;
	rules4GM(nclassif,classifplus,minGMsize,solution.size()-1,/*verbose=*/false);
	
	
	//			std::cout<<" -- Cleaning lesions that are not neighbors to the WM!"<<std::endl;
	vistal::Image3D<unsigned char> *fclassif = new vistal::Image3D<unsigned char>;
	rulesWM4lesions(*fclassif,noborderlesions,nclassif,solution.size()+1,d->wmneighbor,/*verbose=*/false);
		
	d->output = dynamic_cast <dtkAbstractData *>(dtkAbstractDataFactory::instance()->create("vistalDataImageUChar3"));
	d->output->setData(fclassif);	
		
	return EXIT_SUCCESS;
}

dtkAbstractData * vistalProcessSegmentationSTREM::output(void)
{
	return d->output;
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createVistalProcessSegmentationSTREM(void)
{
    return new vistalProcessSegmentationSTREM;
}
