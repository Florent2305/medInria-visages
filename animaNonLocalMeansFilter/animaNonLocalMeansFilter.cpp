// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaNonLocalMeansFilter.h"

#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <medAbstractDataFactory.h>
#include <medAbstractImageData.h>

#include <medMetaDataKeys.h>

#include <itkImageFileWriter.h>
#include <animaNonLocalMeansImageFilter.h>
#include <animaNonLocalMeansTemporalImageFilter.h>

#include <itkCastImageFilter.h>
#include <itkImageFileWriter.h>


// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilterPrivate
// /////////////////////////////////////////////////////////////////

class animaNonLocalMeansFilterPrivate
{
public:
    dtkSmartPointer <medAbstractImageData> input;
    dtkSmartPointer <medAbstractImageData> output;

    unsigned int patchHalfSize;
    unsigned int searchNeighborhood;
    unsigned int searchStepSize;
    double weightThreshold;
    double betaParameter;
    double meanMinThreshold;
    double varMinThreshold;
    unsigned int nbThread;
    int mode;
    int weightedMethod;
    int temporalImage;

    itk::CStyleCommand::Pointer callback;

    animaNonLocalMeansFilter *parent;
    animaNonLocalMeansFilterPrivate(): parent(NULL) {}

    void update();
    template <class PixelType> void switchDimension(unsigned int const nbDimension);
    template <class ImageType> void switchTemporal();

    template <class ImageType> void updateNLMeans();
    template <class ImageType> void updateNLMeansTemporal();
    static void eventCallback(itk::Object* caller, const itk::EventObject& event, void* clientData);
};

void
animaNonLocalMeansFilterPrivate::update ()
{
    callback = itk::CStyleCommand::New();
    callback->SetClientData((void*) this);
    callback->SetCallback(animaNonLocalMeansFilterPrivate::eventCallback);

    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (input->identifier());
    unsigned int nbDimension =(*(type.end() - 1)).digitValue();

    type.truncate(type.size() - 1);

    if ( type == "itkDataImageChar" )
    {
        switchDimension<char>(nbDimension);
    }
    else if ( type == "itkDataImageUChar" )
    {
        switchDimension<unsigned char>(nbDimension);
    }
    else if ( type == "itkDataImageShort" )
    {
        switchDimension<short>(nbDimension);
    }
    else if ( type == "itkDataImageUShort" )
    {
        switchDimension<unsigned short>(nbDimension);
    }
    else if ( type == "itkDataImageInt" )
    {
        switchDimension<int>(nbDimension);
    }
    else if ( type == "itkDataImageUInt" )
    {
        switchDimension<unsigned int>(nbDimension);
    }
    else if ( type == "itkDataImageLong" )
    {
        switchDimension<long>(nbDimension);
    }
    else if ( type == "itkDataImageULong" )
    {
        switchDimension<unsigned long>(nbDimension);
    }
    else if ( type == "itkDataImageFloat" )
    {
        switchDimension<float>(nbDimension);
    }
    else if ( type == "itkDataImageDouble" )
    {
        switchDimension<double>(nbDimension);
    }
}

template <class PixelType>
void
animaNonLocalMeansFilterPrivate::switchDimension(unsigned int const nbDimension)
{
    switch(nbDimension)
    {
        case 2:
        {
            switchTemporal<itk::Image<PixelType, 2> >();
            break;
        }
        case 3:
        {
            switchTemporal<itk::Image<PixelType, 3> >();
            break;
        }
        case 4:
        {
            switchTemporal<itk::Image<PixelType, 4> >();
            break;
        }
    }
}


template <class ImageType>
void
animaNonLocalMeansFilterPrivate::switchTemporal()
{
    if (!temporalImage)
        updateNLMeans<ImageType>();
    else
        updateNLMeansTemporal<ImageType>();
}

template <class ImageType>
void
animaNonLocalMeansFilterPrivate::updateNLMeans()
{

    typedef anima::NonLocalMeansImageFilter <ImageType>  FilterType;
    typename FilterType::Pointer filter = FilterType::New();

    filter->SetPatchHalfSize(patchHalfSize);
    filter->SetSearchStepSize(searchStepSize);
    filter->SetSearchNeighborhood(searchNeighborhood);
    filter->SetWeightThreshold(weightThreshold);
    filter->SetBetaParameter(betaParameter);
    filter->SetMeanMinThreshold(meanMinThreshold);
    filter->SetVarMinThreshold(varMinThreshold);
    filter->SetNumberOfThreads(nbThread);

    if (!weightedMethod)
        filter->SetWeightMethod(FilterType::EXP);
    else
        filter->SetWeightMethod(FilterType::RICIAN);

    filter->SetInput(dynamic_cast<ImageType*>((itk::Object*)(input->data())));
    filter->AddObserver(itk::ProgressEvent(), callback );
    filter->Update();

    output->setData(filter->GetOutput());
}

template <class ImageType>
void
animaNonLocalMeansFilterPrivate::updateNLMeansTemporal()
{
    typedef anima::NonLocalMeansTemporalImageFilter<ImageType>  FilterType;
    typename FilterType::Pointer filter = FilterType::New();

    filter->SetPatchHalfSize(patchHalfSize);
    filter->SetSearchStepSize(searchStepSize);
    filter->SetSearchNeighborhood(searchNeighborhood);
    filter->SetWeightThreshold(weightThreshold);
    filter->SetBetaParameter(betaParameter);
    filter->SetMeanMinThreshold(meanMinThreshold);
    filter->SetVarMinThreshold(varMinThreshold);
    filter->SetNumberOfThreads(nbThread);

    if (!weightedMethod)
        filter->SetWeightMethod(FilterType::EXP);
    else
        filter->SetWeightMethod(FilterType::RICIAN);

    filter->SetInput(dynamic_cast<ImageType*>((itk::Object*)(input->data())));
    filter->AddObserver(itk::ProgressEvent(), callback );
    filter->Update();

    output->setData(filter->GetOutput());
}

void
animaNonLocalMeansFilterPrivate::eventCallback(itk::Object* caller, const itk::EventObject& event, void* clientData)
{
    animaNonLocalMeansFilterPrivate *d = reinterpret_cast<animaNonLocalMeansFilterPrivate *> (clientData);
    itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;
    d->parent->emitProgressed ( static_cast<int>( (processObject->GetProgress() * 100)));
}


// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilter
// /////////////////////////////////////////////////////////////////

animaNonLocalMeansFilter::animaNonLocalMeansFilter() : dtkAbstractProcess(), d(new animaNonLocalMeansFilterPrivate)
{
    d->parent = this;
}

animaNonLocalMeansFilter::~animaNonLocalMeansFilter()
{

}

bool animaNonLocalMeansFilter::registered()
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaNonLocalMeansFilter", createanimaNonLocalMeansFilter);
}

QString animaNonLocalMeansFilter::description() const
{
    return "animaNonLocalMeansFilter";
}

void animaNonLocalMeansFilter::setInputImage (medAbstractData *data)
{
    medAbstractImageData *medData = dynamic_cast <medAbstractImageData *> (data);

    if (!medData)
        return;

    QString identifier = data->identifier();

    d->output = dynamic_cast <medAbstractImageData *> (medAbstractDataFactory::instance()->create (identifier));

    d->input = medData;
}

void animaNonLocalMeansFilter::setPatchHalfSize(unsigned int patchHalfSize)
{
    d->patchHalfSize = patchHalfSize;
}

void animaNonLocalMeansFilter::setSearchNeighborhood(unsigned int searchNeighborhood)
{
    d->searchNeighborhood = searchNeighborhood;
}

void animaNonLocalMeansFilter::setSearchStepSize(unsigned int searchStepSize)
{
    d->searchStepSize = searchStepSize;
}

void animaNonLocalMeansFilter::setWeightThreshold(double weightThreshold)
{
    d->weightThreshold = weightThreshold;
}

void animaNonLocalMeansFilter::setBetaParameter(double betaParameter)
{
    d->betaParameter = betaParameter;
}

void animaNonLocalMeansFilter::setMeanMinThreshold(double meanMinThreshold)
{
    d->meanMinThreshold = meanMinThreshold;
}

void animaNonLocalMeansFilter::setVarMinThreshold(double varMinThreshold)
{
    d->varMinThreshold = varMinThreshold;
}

void animaNonLocalMeansFilter::setNumberOfThreads(unsigned int nbThread)
{
    d->nbThread = nbThread;
}

void animaNonLocalMeansFilter::setWeightedMethod(int weightedMethod)
{
    d->weightedMethod = weightedMethod;
}

void animaNonLocalMeansFilter::setTemporalImage(int temporalImage)
{
    d->temporalImage = temporalImage;
}

int animaNonLocalMeansFilter::update ()
{
    if ( !d->input )
    {
        qDebug() << "in update method : d->input is NULL";
        return -1;
    }

    d->update();

    return EXIT_SUCCESS;
}

medAbstractData * animaNonLocalMeansFilter::output ()
{
    return d->output;
}

void animaNonLocalMeansFilter::emitProgressed(int progression)
{
    emit progressed(progression);
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaNonLocalMeansFilter(void)
{
    return new animaNonLocalMeansFilter;
}


