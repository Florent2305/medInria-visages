// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaNonLocalMeansFilter.h"

#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkSmartPointer.h>

#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractProcess.h>

#include <medMetaDataKeys.h>

#include <itkImageFileWriter.h>
#include <itkNonLocalMeansImageFilter.h>
#include <itkNonLocalMeansTemporalImageFilter.h>

#include <itkCastImageFilter.h>
#include <itkImageFileWriter.h>


// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilterPrivate
// /////////////////////////////////////////////////////////////////

class animaNonLocalMeansFilterPrivate
{
public:
    dtkSmartPointer <dtkAbstractData> input;
    dtkSmartPointer <dtkAbstractData> output;

    unsigned int patchHalfSize;
    unsigned int searchNeighborhood;
    unsigned int searchStepSize;
    double weightThreshold;
    double betaParameter;
    double meanMinThreshold;
    double varMinThreshold;
    unsigned int nbThread;
    int mode;
    int weightedMethod;
    int temporalImage;

    itk::CStyleCommand::Pointer callback;

    animaNonLocalMeansFilter *parent;
    animaNonLocalMeansFilterPrivate(): parent(NULL) {}

    void update();
    template <class PixelType> void switchDimension(unsigned int const nbDimension);
    template <class ImageType> void switchTemporal();

    template <class ImageType> void updateNLMeans();
    template <class ImageType> void updateNLMeansTemporal();
    static void eventCallback(itk::Object* caller, const itk::EventObject& event, void* clientData);
};



void
animaNonLocalMeansFilterPrivate::update ()
{
    callback = itk::CStyleCommand::New();
    callback->SetClientData((void*) this);
    callback->SetCallback(animaNonLocalMeansFilterPrivate::eventCallback);

    //get the number of dimension and type of the image from the dtk identifier
    QString type = QString (input->identifier());
    unsigned int nbDimension =(*(type.end() - 1)).digitValue();

    type.truncate(type.size() - 1);

    if ( type == "itkDataImageChar" )
    {
        switchDimension<char>(nbDimension);
    }
    else if ( type == "itkDataImageUChar" )
    {
        switchDimension<unsigned char>(nbDimension);
    }
    else if ( type == "itkDataImageShort" )
    {
        switchDimension<short>(nbDimension);
    }
    else if ( type == "itkDataImageUShort" )
    {
        switchDimension<unsigned short>(nbDimension);
    }
    else if ( type == "itkDataImageInt" )
    {
        switchDimension<int>(nbDimension);
    }
    else if ( type == "itkDataImageUInt" )
    {
        switchDimension<unsigned int>(nbDimension);
    }
    else if ( type == "itkDataImageLong" )
    {
        switchDimension<long>(nbDimension);
    }
    else if ( type == "itkDataImageULong" )
    {
        switchDimension<unsigned long>(nbDimension);
    }
    else if ( type == "itkDataImageFloat" )
    {
        switchDimension<float>(nbDimension);
    }
    else if ( type == "itkDataImageDouble" )
    {
        switchDimension<double>(nbDimension);
    }
}

template <class PixelType>
void
animaNonLocalMeansFilterPrivate::switchDimension(unsigned int const nbDimension)
{
    switch(nbDimension)
    {
        case 2:
        {
            switchTemporal<itk::Image<PixelType, 2> >();
            break;
        }
        case 3:
        {
            switchTemporal<itk::Image<PixelType, 3> >();
            break;
        }
        case 4:
        {
            switchTemporal<itk::Image<PixelType, 4> >();
            break;
        }
    }
}


template <class ImageType>
void
animaNonLocalMeansFilterPrivate::switchTemporal()
{
    if (!temporalImage)
        updateNLMeans<ImageType>();
    else
        updateNLMeansTemporal<ImageType>();
}

template <class ImageType>
void
animaNonLocalMeansFilterPrivate::updateNLMeans()
{

    typedef itk::NonLocalMeansImageFilter <ImageType>  FilterType;
    typename FilterType::Pointer filter = FilterType::New();

    filter->SetPatchHalfSize(patchHalfSize);
    filter->SetSearchStepSize(searchStepSize);
    filter->SetSearchNeighborhood(searchNeighborhood);
    filter->SetWeightThreshold(weightThreshold);
    filter->SetBetaParameter(betaParameter);
    filter->SetMeanMinThreshold(meanMinThreshold);
    filter->SetVarMinThreshold(varMinThreshold);
    filter->SetNumberOfThreads(nbThread);

    if (!weightedMethod)
        filter->SetWeightMethod(FilterType::EXP);
    else
        filter->SetWeightMethod(FilterType::RICIAN);

    filter->SetInput(dynamic_cast<ImageType*>((itk::Object*)(input->data())));
    filter->AddObserver(itk::ProgressEvent(), callback );
    filter->Update();

    output->setData(filter->GetOutput());
}

template <class ImageType>
void
animaNonLocalMeansFilterPrivate::updateNLMeansTemporal()
{
    typedef itk::NonLocalMeansTemporalImageFilter<ImageType>  FilterType;
    typename FilterType::Pointer filter = FilterType::New();

    filter->SetPatchHalfSize(patchHalfSize);
    filter->SetSearchStepSize(searchStepSize);
    filter->SetSearchNeighborhood(searchNeighborhood);
    filter->SetWeightThreshold(weightThreshold);
    filter->SetBetaParameter(betaParameter);
    filter->SetMeanMinThreshold(meanMinThreshold);
    filter->SetVarMinThreshold(varMinThreshold);
    filter->SetNumberOfThreads(nbThread);

    if (!weightedMethod)
        filter->SetWeightMethod(FilterType::EXP);
    else
        filter->SetWeightMethod(FilterType::RICIAN);

    filter->SetInput(dynamic_cast<ImageType*>((itk::Object*)(input->data())));
    filter->AddObserver(itk::ProgressEvent(), callback );
    filter->Update();

    output->setData(filter->GetOutput());
}

void
animaNonLocalMeansFilterPrivate::eventCallback(itk::Object* caller, const itk::EventObject& event, void* clientData)
{
    animaNonLocalMeansFilterPrivate *d = reinterpret_cast<animaNonLocalMeansFilterPrivate *> (clientData);
    itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;
    d->parent->emitProgressed ( static_cast<int>( (processObject->GetProgress() * 100)));
}



// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilter
// /////////////////////////////////////////////////////////////////

animaNonLocalMeansFilter::animaNonLocalMeansFilter(void) : dtkAbstractProcess(), d(new animaNonLocalMeansFilterPrivate)
{
    d->parent = this;
}

animaNonLocalMeansFilter::~animaNonLocalMeansFilter(void)
{

}

bool animaNonLocalMeansFilter::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaNonLocalMeansFilter", createanimaNonLocalMeansFilter);
}

QString animaNonLocalMeansFilter::description(void) const
{
    return "animaNonLocalMeansFilter";
}

void animaNonLocalMeansFilter::setInput ( dtkAbstractData *data )
{
    if ( !data )
        return;

    QString identifier = data->identifier();

    d->output = dtkAbstractDataFactory::instance()->createSmartPointer ( identifier );

    d->input = data;
}

void animaNonLocalMeansFilter::setParameter ( double  data, int channel )
{
    switch (channel)
    {
        case (0):
            d->patchHalfSize = (unsigned int)data;
            break;
        case (1):
            d->searchNeighborhood = (unsigned int)data;
            break;
        case (2):
            d->searchStepSize = (unsigned int)data;
            break;
        case (3):
            d->weightThreshold = data;
            break;
        case (4):
            d->betaParameter = data;
            break;
        case (5):
            d->meanMinThreshold = data;
            break;
        case (6):
            d->varMinThreshold= data;
            break;
        case (7):
            d->nbThread = (unsigned int)data;
            break;
        case (8):
            d->weightedMethod = (int)data;
            break;
        case (9):
            d->temporalImage = (int)data;
            break;
        default :
            return;
    }

}

int animaNonLocalMeansFilter::update ( void )
{
    if ( !d->input )
    {
        qDebug() << "in update method : d->input is NULL";
        return -1;
    }

    d->update();

    return EXIT_SUCCESS;
}

dtkAbstractData * animaNonLocalMeansFilter::output ( void )
{
    return ( d->output );
}

void animaNonLocalMeansFilter::emitProgressed(int progression)
{
    emit progressed(progression);
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaNonLocalMeansFilter(void)
{
    return new animaNonLocalMeansFilter;
}


