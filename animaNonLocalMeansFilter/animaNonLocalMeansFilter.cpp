// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaNonLocalMeansFilter.h"

#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkSmartPointer.h>

#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractProcess.h>

#include <medMetaDataKeys.h>

#include <itkImageFileWriter.h>
#include <itkNonLocalMeansImageFilter.h>
#include <itkNonLocalMeansTemporalImageFilter.h>

#include <itkCastImageFilter.h>




// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilterPrivate
// /////////////////////////////////////////////////////////////////

class animaNonLocalMeansFilterPrivate
{
public:
    dtkSmartPointer <dtkAbstractData> input;
    dtkSmartPointer <dtkAbstractData> output;

    unsigned int patchHalfSize;
    unsigned int searchNeighborhood;
    unsigned int searchStepSize;
    double weightThreshold;
    double betaParameter;
    double meanMinThreshold;
    double varMinThreshold;
    unsigned int nbThread;
    int mode;
    int weightedMethod;
    int temporalImage;

    animaNonLocalMeansFilter *parent;
    animaNonLocalMeansFilterPrivate(): parent(NULL) {}

    static void eventCallback (itk::Object* caller, const itk::EventObject& event, void* clientData)
    {
        animaNonLocalMeansFilterPrivate *d = reinterpret_cast<animaNonLocalMeansFilterPrivate *> (clientData);
        itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;
        d->parent->emitProgressed ( static_cast<int>( (processObject->GetProgress() * 100)));
    }
};


// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilter
// /////////////////////////////////////////////////////////////////

animaNonLocalMeansFilter::animaNonLocalMeansFilter(void) : dtkAbstractProcess(), d(new animaNonLocalMeansFilterPrivate)
{
    d->parent = this;
}

animaNonLocalMeansFilter::~animaNonLocalMeansFilter(void)
{

}

bool animaNonLocalMeansFilter::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaNonLocalMeansFilter", createanimaNonLocalMeansFilter);
}

QString animaNonLocalMeansFilter::description(void) const
{
    return "animaNonLocalMeansFilter";
}

void animaNonLocalMeansFilter::setInput ( dtkAbstractData *data )
{
    if ( !data )
        return;

    QString identifier = data->identifier();

    d->output = dtkAbstractDataFactory::instance()->createSmartPointer ( identifier );

    d->input = data;
}

void animaNonLocalMeansFilter::setParameter ( double  data, int channel )
{
    switch (channel)
    {
        case (0):
            d->patchHalfSize = (unsigned int)data;
            break;
        case (1):
            d->searchNeighborhood = (unsigned int)data;
            break;
        case (2):
            d->searchStepSize = (unsigned int)data;
            break;
        case (3):
            d->weightThreshold = data;
            break;
        case (4):
            d->betaParameter = data;
            break;
        case (5):
            d->meanMinThreshold = data;
            break;
        case (6):
            d->varMinThreshold= data;
            break;
        case (7):
            d->nbThread = (unsigned int)data;
            break;
        case (8):
            d->weightedMethod = (int)data;
            break;
        case (9):
            d->temporalImage = (int)data;
            break;
        default :
            return;
    }

}

int animaNonLocalMeansFilter::update ( void )
{
    if ( !d->input )
    {
        qDebug() << "in update method : d->input is NULL";
        return -1;
    }

    //get the number of dimension of the image from the dtk identifier
    QString id = QString (d->input->identifier());
    unsigned int nbDimension =(*(id.end() - 1)).digitValue();

    itk::CStyleCommand::Pointer callback = itk::CStyleCommand::New();
    callback->SetClientData((void*) d);
    callback->SetCallback(animaNonLocalMeansFilterPrivate::eventCallback);


    //Set output description metadata
    QString newSeriesDescription = d->input->metadata( medMetaDataKeys::SeriesDescription.key() );
    newSeriesDescription += "_NLMean_denoising";
    d->output->addMetaData ( medMetaDataKeys::SeriesDescription.key(), newSeriesDescription );

    if (!d->temporalImage)
    {
        switch (nbDimension)
        {
        case 2:
        {
            typedef itk::Image <float, 2> FilteredImageType;
            typedef itk::NonLocalMeansImageFilter <FilteredImageType>  FilterType;
            FilterType::Pointer filter = FilterType::New();

            filter->SetPatchHalfSize(d->patchHalfSize);
            filter->SetSearchStepSize(d->searchStepSize);
            filter->SetSearchNeighborhood(d->searchNeighborhood);
            filter->SetWeightThreshold(d->weightThreshold);
            filter->SetBetaParameter(d->betaParameter);
            filter->SetMeanMinThreshold(d->meanMinThreshold);
            filter->SetVarMinThreshold(d->varMinThreshold);
            filter->SetNumberOfThreads(d->nbThread);

            if (!d->weightedMethod)
                filter->SetWeightMethod(FilterType::EXP);
            else
                filter->SetWeightMethod(FilterType::RICIAN);

            filter->SetInput((const FilteredImageType*)d->input->data());
            filter->AddObserver(itk::ProgressEvent(), callback );
            filter->Update();
            d->output->setData(filter->GetOutput());
            break;
        }
        case 3:
        {
            typedef itk::Image <float, 3> FilteredImageType;
            typedef itk::NonLocalMeansImageFilter <FilteredImageType>  FilterType;
            FilterType::Pointer filter = FilterType::New();

            filter->SetPatchHalfSize(d->patchHalfSize);
            filter->SetSearchStepSize(d->searchStepSize);
            filter->SetSearchNeighborhood(d->searchNeighborhood);
            filter->SetWeightThreshold(d->weightThreshold);
            filter->SetBetaParameter(d->betaParameter);
            filter->SetMeanMinThreshold(d->meanMinThreshold);
            filter->SetVarMinThreshold(d->varMinThreshold);
            filter->SetNumberOfThreads(d->nbThread);

            if (!d->weightedMethod)
                filter->SetWeightMethod(FilterType::EXP);
            else
                filter->SetWeightMethod(FilterType::RICIAN);

            filter->SetInput((const FilteredImageType*)d->input->data());
            filter->AddObserver(itk::ProgressEvent(), callback );
            filter->Update();
            d->output->setData(filter->GetOutput());
            break;
        }
        case 4:
        {
            //TODO: this is not thread safe (sublclass from dtkAbstractProcess and emit signal ?)
            /*QMessageBox msgBox;
            msgBox.setText(tr("Input has more than 3 dimension, you probably should set the temporal option to \"Yes\"."));
            msgBox.setInformativeText(tr("Do you want to continue anyway?"));
            msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
            msgBox.setDefaultButton(QMessageBox::No);
            int ret = msgBox.exec();

            if (ret == QMessageBox::No)
                return 0;*/

            typedef itk::Image <float, 4> FilteredImageType;
            typedef itk::NonLocalMeansImageFilter <FilteredImageType>  FilterType;
            FilterType::Pointer filter = FilterType::New();

            filter->SetPatchHalfSize(d->patchHalfSize);
            filter->SetSearchStepSize(d->searchStepSize);
            filter->SetSearchNeighborhood(d->searchNeighborhood);
            filter->SetWeightThreshold(d->weightThreshold);
            filter->SetBetaParameter(d->betaParameter);
            filter->SetMeanMinThreshold(d->meanMinThreshold);
            filter->SetVarMinThreshold(d->varMinThreshold);
            filter->SetNumberOfThreads(d->nbThread);

            if (!d->weightedMethod)
                filter->SetWeightMethod(FilterType::EXP);
            else
                filter->SetWeightMethod(FilterType::RICIAN);

            filter->SetInput((const FilteredImageType*)d->input->data());
            filter->AddObserver(itk::ProgressEvent(), callback );
            filter->Update();
            d->output->setData(filter->GetOutput());
            break;
        }
        }
    }
    else
    {
        switch (nbDimension)
        {
        case 2:
        {

            //TODO: this is not thread safe (sublclass from dtkAbstractProcess and emit signal ?)
            /*QMessageBox msgBox;
            msgBox.setText(tr("Input has less than 3 dimension, you shoul set the temporal option to \"No\"."));
            msgBox.setStandardButtons(QMessageBox::Ok);
            msgBox.setDefaultButton(QMessageBox::Ok);
            msgBox.exec();*/
            return 0;
        }
        case 3:
        {
            typedef itk::Image <float, 3> FilteredImageType;
            typedef itk::NonLocalMeansTemporalImageFilter <FilteredImageType>  FilterType;
            FilterType::Pointer filter = FilterType::New();

            filter->SetPatchHalfSize(d->patchHalfSize);
            filter->SetSearchStepSize(d->searchStepSize);
            filter->SetSearchNeighborhood(d->searchNeighborhood);
            filter->SetWeightThreshold(d->weightThreshold);
            filter->SetBetaParameter(d->betaParameter);
            filter->SetMeanMinThreshold(d->meanMinThreshold);
            filter->SetVarMinThreshold(d->varMinThreshold);
            filter->SetNumberOfThreads(d->nbThread);

            if (!d->weightedMethod)
                filter->SetWeightMethod(FilterType::EXP);
            else
                filter->SetWeightMethod(FilterType::RICIAN);

            filter->SetInput((const FilteredImageType*)d->input->data());
            filter->AddObserver(itk::ProgressEvent(), callback );
            filter->Update();
            d->output->setData(filter->GetOutput());
            break;
        }
        case 4:
        {
            typedef itk::Image <float, 4> FilteredImageType;
            typedef itk::NonLocalMeansTemporalImageFilter <FilteredImageType>  FilterType;
            FilterType::Pointer filter = FilterType::New();

            filter->SetPatchHalfSize(d->patchHalfSize);
            filter->SetSearchStepSize(d->searchStepSize);
            filter->SetSearchNeighborhood(d->searchNeighborhood);
            filter->SetWeightThreshold(d->weightThreshold);
            filter->SetBetaParameter(d->betaParameter);
            filter->SetMeanMinThreshold(d->meanMinThreshold);
            filter->SetVarMinThreshold(d->varMinThreshold);
            filter->SetNumberOfThreads(d->nbThread);

            if (!d->weightedMethod)
                filter->SetWeightMethod(FilterType::EXP);
            else
                filter->SetWeightMethod(FilterType::RICIAN);

            filter->SetInput((const FilteredImageType*)d->input->data());
            filter->AddObserver(itk::ProgressEvent(), callback );
            filter->Update();
            d->output->setData(filter->GetOutput());
            break;
        }
        }
    }
    return EXIT_SUCCESS;
}

dtkAbstractData * animaNonLocalMeansFilter::output ( void )
{
    return ( d->output );
}

void animaNonLocalMeansFilter::emitProgressed(int progression)
{
    emit progressed(progression);
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaNonLocalMeansFilter(void)
{
    return new animaNonLocalMeansFilter;
}


