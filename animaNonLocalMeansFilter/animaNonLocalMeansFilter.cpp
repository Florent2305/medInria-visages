// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "animaNonLocalMeansFilter.h"

#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkSmartPointer.h>

#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractProcess.h>

#include <itkImageFileWriter.h>
#include <itkNonLocalMeansImageFilter.h>
#include <itkNonLocalMeansTemporalImageFilter.h>

#include <itkCastImageFilter.h>




// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilterPrivate
// /////////////////////////////////////////////////////////////////

class animaNonLocalMeansFilterPrivate
{
public:
    dtkSmartPointer <dtkAbstractData> input;
    dtkSmartPointer <dtkAbstractData> output;

    unsigned int patchHalfSize;
    unsigned int searchNeighborhood;
    unsigned int searchStepSize;
    double weightThreshold;
    double betaParameter;
    double meanMinThreshold;
    double varMinThreshold;
    unsigned int nbThread;
    int mode;
    int weightedMethod;
    int temporalImage;

    animaNonLocalMeansFilter *parent;
    animaNonLocalMeansFilterPrivate(): parent(NULL) {}

    static void eventCallback (itk::Object* caller, const itk::EventObject& event, void* clientData)
    {
        animaNonLocalMeansFilterPrivate *d = reinterpret_cast<animaNonLocalMeansFilterPrivate *> (clientData);
        itk::ProcessObject * processObject = ( itk::ProcessObject* ) caller;
        d->parent->emitProgressed ( static_cast<int>( (processObject->GetProgress() * 100)));
    }
};


// /////////////////////////////////////////////////////////////////
// animaNonLocalMeansFilter
// /////////////////////////////////////////////////////////////////

animaNonLocalMeansFilter::animaNonLocalMeansFilter(void) : dtkAbstractProcess(), d(new animaNonLocalMeansFilterPrivate)
{
    d->parent = this;
}

animaNonLocalMeansFilter::~animaNonLocalMeansFilter(void)
{

}

bool animaNonLocalMeansFilter::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("animaNonLocalMeansFilter", createanimaNonLocalMeansFilter);
}

QString animaNonLocalMeansFilter::description(void) const
{
    return "animaNonLocalMeansFilter";
}

void animaNonLocalMeansFilter::setInput ( dtkAbstractData *data )
{
    if ( !data )
        return;

    QString identifier = "itkDataImageFloat3";

    d->output = dtkAbstractDataFactory::instance()->createSmartPointer ( identifier );

    d->input = data;
}

void animaNonLocalMeansFilter::setParameter ( double  data, int channel )
{
    switch (channel)
    {
        case (0):
            d->patchHalfSize = (unsigned int)data;
            break;
        case (1):
            d->searchNeighborhood = (unsigned int)data;
            break;
        case (2):
            d->searchStepSize = (unsigned int)data;
            break;
        case (3):
            d->weightThreshold = data;
            break;
        case (4):
            d->betaParameter = data;
            break;
        case (5):
            d->meanMinThreshold = data;
            break;
        case (6):
            d->varMinThreshold= data;
            break;
        case (7):
            d->nbThread = (unsigned int)data;
            break;
        case (8):
            d->weightedMethod = (int)data;
            break;
        case (9):
            d->temporalImage = (int)data;
            break;
        default :
            return;
    }

}

int animaNonLocalMeansFilter::update ( void )
{
    if ( !d->input )
    {
        qDebug() << "in update method : d->input is NULL";
        return -1;
    }

    QString id = QString (d->input->identifier());

    qDebug() << d->input->identifier();

    QString::iterator last_charac = id.end() - 1;
    if (*last_charac != '3')
    {
        qDebug() <<"input is not of dimension 3";
        return -1;
    }

    itk::CStyleCommand::Pointer callback = itk::CStyleCommand::New();
    callback->SetClientData((void*) d);
    callback->SetCallback(animaNonLocalMeansFilterPrivate::eventCallback);

    if (1)
    {
        typedef itk::NonLocalMeansImageFilter <itk::Image<float, 3> > FilterType;
        FilterType::Pointer filter = FilterType::New();

        typedef itk::Image <float, 3> FilteredImageType;

        dtkSmartPointer <dtkAbstractData> convertedData = dtkAbstractDataFactory::instance()->create ("itkDataImageFloat3");
        foreach ( QString metaData, d->input->metaDataList() )
            if (!convertedData->hasMetaData(metaData))
                convertedData->addMetaData ( metaData, d->input->metaDataValues ( metaData ) );

        foreach ( QString property, d->input->propertyList() )
            convertedData->addProperty ( property, d->input->propertyValues ( property ) );


        if (id =="itkDataImageDouble3")
        {
            typedef itk::Image< double, 3 > InputImageType;
            typedef itk::CastImageFilter< InputImageType, FilteredImageType > CastFilterType;

            CastFilterType::Pointer  caster = CastFilterType::New();
            caster->SetInput((const InputImageType*)d->input->data());
            qDebug()<<"starting cast";
            caster->Update();
            convertedData->setData(caster->GetOutput());
        }

        filter->SetPatchHalfSize(d->patchHalfSize);
        qDebug()<<"patchHalfSize  : "<<d->patchHalfSize;
        filter->SetSearchStepSize(d->searchStepSize);
        qDebug()<<"searchStepSize : "<<d->searchStepSize;
        filter->SetSearchNeighborhood(d->searchNeighborhood);
        qDebug()<<"searchNeighborhood  : "<<d->searchNeighborhood;
        filter->SetWeightThreshold(d->weightThreshold);
        qDebug()<<"weightThreshold  : "<<d->weightThreshold;
        filter->SetBetaParameter(d->betaParameter);
        qDebug()<<"betaParameter  : "<<d->betaParameter;
        filter->SetMeanMinThreshold(d->meanMinThreshold);
        qDebug()<<"meanMinThreshold  : "<<d->meanMinThreshold;
        filter->SetVarMinThreshold(d->varMinThreshold);
        qDebug()<<"varMinThreshold  : "<<d->varMinThreshold;
        filter->SetNumberOfThreads(d->nbThread);
        qDebug()<<"nbThread : "<<d->nbThread;

        if (d->weightedMethod == 0)
        {
            filter->SetWeightMethod(FilterType::EXP);
            qDebug()<<"weightedMethod : EXP";
        }
        else if (d->weightedMethod== 1)
        {
            filter->SetWeightMethod(FilterType::RICIAN);
            qDebug()<<"weightedMethod : RICIAN";
        }
        else return -1;

        filter->SetInput(dynamic_cast<FilteredImageType *> ((itk::Object*)(convertedData->data())));

        filter->AddObserver(itk::ProgressEvent(), callback );

        qDebug()<<"starting update";
        filter->Update();
        d->output->setData(filter->GetOutput());
    }
    else qDebug()<<"temporal Image";



    return EXIT_SUCCESS;
}

dtkAbstractData * animaNonLocalMeansFilter::output ( void )
{
    return ( d->output );
}

void animaNonLocalMeansFilter::emitProgressed(int progression)
{
    emit progressed(progression);
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createanimaNonLocalMeansFilter(void)
{
    return new animaNonLocalMeansFilter;
}


