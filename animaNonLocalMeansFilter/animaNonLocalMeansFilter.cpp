// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "medtkNLMeansDiffusion.h"

#include <dtkCore/dtkAbstractProcessFactory.h>
#include <dtkCore/dtkSmartPointer.h>

#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractProcess.h>

#include <itkCastImageFilter.h>
#include <itkImageFileWriter.h>

#include "itkNonLocalMeansDiffusionImageFilter.h"

// /////////////////////////////////////////////////////////////////
// medtkNLMeansDiffusionPrivate
// /////////////////////////////////////////////////////////////////

class medtkNLMeansDiffusionPrivate
{
public:
    dtkSmartPointer <dtkAbstractData> input;
    dtkSmartPointer <dtkAbstractData> output;

    unsigned int patchHalfSize;
    unsigned int searchNeighborhood;
    unsigned int searchStepSize;
    double weightThreshold;
    double betaParameter;
    double meanMinThreshold;
    double varMinThreshold;
    unsigned int nbThread;
    int mode;
    int weightedMethod;

    //NLMEANS mode(FilterType::SINGLE);
    //WEIGHT weightMethod(FilterType::EXP);

};


// /////////////////////////////////////////////////////////////////
// medtkNLMeansDiffusion
// /////////////////////////////////////////////////////////////////

medtkNLMeansDiffusion::medtkNLMeansDiffusion(void) : dtkAbstractProcess(), d(new medtkNLMeansDiffusionPrivate)
{

}

medtkNLMeansDiffusion::~medtkNLMeansDiffusion(void)
{

}

bool medtkNLMeansDiffusion::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("medtkNLMeansDiffusion", createMedtkNLMeansDiffusion);
}

QString medtkNLMeansDiffusion::description(void) const
{
    return "medtkNLMeansDiffusion";
}

void medtkNLMeansDiffusion::setInput ( dtkAbstractData *data )
{
    if ( !data )
        return;

    QString identifier = "itkDataImageFloat3";

    d->output = dtkAbstractDataFactory::instance()->createSmartPointer ( identifier );

    d->input = data;
}

void medtkNLMeansDiffusion::setParameter ( double  data, int channel )
{
    switch (channel)
    {
        case (0):
            d->patchHalfSize = (unsigned int)data;
            break;
        case (1):
            d->searchNeighborhood = (unsigned int)data;
            break;
        case (2):
            d->searchStepSize = (unsigned int)data;
            break;
        case (3):
            d->weightThreshold = data;
            break;
        case (4):
            d->betaParameter = data;
            break;
        case (5):
            d->meanMinThreshold = data;
            break;
        case (6):
            d->varMinThreshold= data;
            break;
        case (7):
            d->nbThread = (unsigned int)data;
            qDebug() << "channel = " << channel << "  data = " << data;
            qDebug() << "number of threads : " << d->nbThread;
            break;
        case (8):
            d->mode = (int)data;
            break;
        case (9):
            d->weightedMethod = (int)data;
            break;
        default :
            return;
    }

}

int medtkNLMeansDiffusion::update ( void )
{
    if ( !d->input )
    {
        qDebug() << "in update method : d->input is NULL";
        return -1;
    }

    QString id = QString (d->input->identifier());

    qDebug() << d->input->identifier();

    QString::iterator last_charac = id.end() - 1;
    if (*last_charac != '3')
    {
        qDebug() <<"input is not of dimension 3";
        return -1;
    }

    typedef itk::NonLocalMeansDiffusionImageFilter FilterType;
    FilterType::Pointer filter = FilterType::New();

    typedef itk::Image <float, 3> FilteredImageType;

    dtkSmartPointer <dtkAbstractData> convertedData = dtkAbstractDataFactory::instance()->create ("itkDataImageFloat3");
    foreach ( QString metaData, d->input->metaDataList() )
        if (!convertedData->hasMetaData(metaData))
            convertedData->addMetaData ( metaData, d->input->metaDataValues ( metaData ) );

    foreach ( QString property, d->input->propertyList() )
        convertedData->addProperty ( property, d->input->propertyValues ( property ) );


    if (id =="itkDataImageDouble3")
    {
        typedef itk::Image< double, 3 > InputImageType;
        typedef itk::CastImageFilter< InputImageType, FilteredImageType > CastFilterType;

        CastFilterType::Pointer  caster = CastFilterType::New();
        caster->SetInput((const InputImageType*)d->input->data());
        qDebug()<<"starting cast";
        caster->Update();
        convertedData->setData(caster->GetOutput());
    }

    filter->SetPatchHalfSize(d->patchHalfSize);
    qDebug()<<"patchHalfSize  : "<<d->patchHalfSize;
    filter->SetSearchStepSize(d->searchStepSize);
    qDebug()<<"searchStepSize : "<<d->searchStepSize;
    filter->SetSearchNeighborhood(d->searchNeighborhood);
    qDebug()<<"searchNeighborhood  : "<<d->searchNeighborhood;
    filter->SetWeightThreshold(d->weightThreshold);
    qDebug()<<"weightThreshold  : "<<d->weightThreshold;
    filter->SetBetaParameter(d->betaParameter);
    qDebug()<<"betaParameter  : "<<d->betaParameter;
    filter->SetMeanMinThreshold(d->meanMinThreshold);
    qDebug()<<"meanMinThreshold  : "<<d->meanMinThreshold;
    filter->SetVarMinThreshold(d->varMinThreshold);
    qDebug()<<"varMinThreshold  : "<<d->varMinThreshold;
    filter->SetNumberOfThreads(d->nbThread);
    qDebug()<<"nbThread : "<<d->nbThread;
    if (d->mode == 0)
    {
        filter->SetMode(FilterType::SINGLE);
        qDebug()<<"mode : SINGLE";
    }
    else if (d->mode == 1)
    {
        filter->SetMode(FilterType::MULTI);
        qDebug()<<"mode : MULTI";
    }
    else return -1;
    if (d->weightedMethod == 0)
    {
        filter->SetWeightMethod(FilterType::EXP);
        qDebug()<<"weightedMethod : EXP";
    }
    else if (d->weightedMethod== 1)
    {
        filter->SetWeightMethod(FilterType::RICIAN);
        qDebug()<<"weightedMethod : RICIAN";
    }
    else return -1;

    filter->SetUseGradients(false);
    filter->SetComputeMeanWeightImage(false);
    filter->SetComputePatchRateImage(false);

    filter->AddInputVolume(dynamic_cast<FilteredImageType *> ((itk::Object*)(convertedData->data())));
    filter->SetImageToProcess(0);
    filter->SetInput(filter->GetInputVolume(0));

    qDebug()<<"starting update";
    filter->Update();
    d->output->setData(filter->GetOutput());

    return EXIT_SUCCESS;
}

dtkAbstractData * medtkNLMeansDiffusion::output ( void )
{
    return ( d->output );
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createMedtkNLMeansDiffusion(void)
{
    return new medtkNLMeansDiffusion;
}
